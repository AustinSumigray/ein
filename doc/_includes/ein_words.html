<table><tr><th>Word</th><th>Description</th></tr>
<tr><td>not<br/>!<br/></td><td>Pops a word; pushes a 0 or a 1 depending on its truth value.</td></tr>
<tr><td>mod<br/>%<br/></td><td>Takes two ints and pushes the mod of the two ints on the stack.  25 4 % returns 1.</td></tr>
<tr><td>and<br/>&amp;&amp;<br/></td><td>Returns logical and of its numeric arguments. Back does not have booleans so it treats 0 (and 0.0) as false, and all other numbers as true.</td></tr>
<tr><td>slide<br/>&apos;<br/></td><td>Moves a word from the call stack to the data stack.</td></tr>
<tr><td>oP<br/>(<br/></td><td>Open paren; begin a compound word.</td></tr>
<tr><td>cP<br/>)<br/></td><td>Close paren; end a compound word.</td></tr>
<tr><td>times<br/>*<br/></td><td>Multiply two numeric arguments.</td></tr>
<tr><td>plus<br/>+<br/></td><td>Takes two numbers and adds them.  If two ints, returns an int; otherwise returns a double; otherwise does string.</td></tr>
<tr><td>minus<br/>-<br/></td><td>Takes two numbers and subtracts them.  `2 1 - ` produces 1.  1 2 - produces -1.</td></tr>
<tr><td>divide<br/>/<br/></td><td>Divide two numeric arguments.</td></tr>
<tr><td>executeStack<br/>;<br/></td><td></td></tr>
<tr><td>langle<br/>&lt;<br/></td><td>Takes two words and returns 1 if they are less than (by value) and 0 otherwise.  1 3 &lt; returns true, and 3 1 &lt; returns false.</td></tr>
<tr><td>leq<br/>&lt;=<br/></td><td>Takes two words and returns 1 if they are less than or equal to (by value) and 0 otherwise.</td></tr>
<tr><td>equals<br/>=<br/></td><td>Takes two words and returns 1 if they are equal (by value) and 0 otherwise.</td></tr>
<tr><td>rangle<br/>&gt;<br/></td><td>Takes two words and returns 1 if they are greater than (by value) and 0 otherwise.  1 3 &lt; returns false, and 3 1 &lt; returns true</td></tr>
<tr><td>geq<br/>&gt;=<br/></td><td>Takes two words and returns 1 if they are greater than or equal to (by value) and 0 otherwise.</td></tr>
<tr><td>car<br/>First<br/>Head<br/></td><td>Takes a compound word on the stack and returns the first word in the list.</td></tr>
<tr><td>car<br/>First<br/>Head<br/></td><td>Takes a compound word on the stack and returns the first word in the list.</td></tr>
<tr><td>pauseStackExecution<br/>Pause<br/></td><td></td></tr>
<tr><td>cdr<br/>Rest<br/>Tail<br/></td><td>Takes a compound word on the stack and returns the rest of the word (as a compound word), minus the first word.</td></tr>
<tr><td>cdr<br/>Rest<br/>Tail<br/></td><td>Takes a compound word on the stack and returns the rest of the word (as a compound word), minus the first word.</td></tr>
<tr><td>oSB<br/>[<br/></td><td></td></tr>
<tr><td>cSB<br/>]<br/></td><td></td></tr>
<tr><td>aboutFace<br/></td><td>Rotate the gripper in oZ by 180 degrees.</td></tr>
<tr><td>abs<br/></td><td>Returns the absolute value of its argument.</td></tr>
<tr><td>accumulate<br/></td><td>Accumulate entries in a compound word using an operator word.  Usage:  ( 1 1 1 ) ( + ) accumulate -&gt; 3.</td></tr>
<tr><td>accumulatedDensity<br/></td><td></td></tr>
<tr><td>activateSensorStreaming<br/></td><td>Start streaming data; you might want to set the SiS (&quot;Should I Stream?&quot;) first using setSisFlags or streamSetSis.</td></tr>
<tr><td>add3dGrasp<br/></td><td>Add the current pose as a 3D grasp relative to the focused object.  Must have locked the 3d grasp first so it knows what pose to use relative to the object.</td></tr>
<tr><td>add3dGraspPoseWord<br/></td><td>Takes an argument on the stack of an EEPose and adds that pose as a 3d grasp relative to the base object.</td></tr>
<tr><td>addPlaceOverPoint<br/></td><td></td></tr>
<tr><td>addPlaceUnderPoint<br/></td><td></td></tr>
<tr><td>analogIOCommand<br/></td><td></td></tr>
<tr><td>and<br/>&amp;&amp;<br/></td><td>Returns logical and of its numeric arguments. Back does not have booleans so it treats 0 (and 0.0) as false, and all other numbers as true.</td></tr>
<tr><td>annotate2dGrasp<br/></td><td></td></tr>
<tr><td>append<br/></td><td></td></tr>
<tr><td>applyGraspFilter<br/></td><td></td></tr>
<tr><td>approachSpeed<br/></td><td></td></tr>
<tr><td>arm1By<br/></td><td></td></tr>
<tr><td>arm1Current<br/></td><td></td></tr>
<tr><td>arm1Down<br/></td><td></td></tr>
<tr><td>arm1To<br/></td><td></td></tr>
<tr><td>arm1True<br/></td><td></td></tr>
<tr><td>arm1Up<br/></td><td></td></tr>
<tr><td>arm2By<br/></td><td></td></tr>
<tr><td>arm2Current<br/></td><td></td></tr>
<tr><td>arm2Down<br/></td><td></td></tr>
<tr><td>arm2To<br/></td><td></td></tr>
<tr><td>arm2True<br/></td><td></td></tr>
<tr><td>arm2Up<br/></td><td></td></tr>
<tr><td>arm3By<br/></td><td></td></tr>
<tr><td>arm3Current<br/></td><td></td></tr>
<tr><td>arm3Down<br/></td><td></td></tr>
<tr><td>arm3To<br/></td><td></td></tr>
<tr><td>arm3True<br/></td><td></td></tr>
<tr><td>arm3Up<br/></td><td></td></tr>
<tr><td>arm4By<br/></td><td></td></tr>
<tr><td>arm4Current<br/></td><td></td></tr>
<tr><td>arm4Down<br/></td><td></td></tr>
<tr><td>arm4To<br/></td><td></td></tr>
<tr><td>arm4True<br/></td><td></td></tr>
<tr><td>arm4Up<br/></td><td></td></tr>
<tr><td>arm5By<br/></td><td></td></tr>
<tr><td>arm5Current<br/></td><td></td></tr>
<tr><td>arm5Down<br/></td><td></td></tr>
<tr><td>arm5To<br/></td><td></td></tr>
<tr><td>arm5True<br/></td><td></td></tr>
<tr><td>arm5Up<br/></td><td></td></tr>
<tr><td>arm6By<br/></td><td></td></tr>
<tr><td>arm6Current<br/></td><td></td></tr>
<tr><td>arm6Down<br/></td><td></td></tr>
<tr><td>arm6To<br/></td><td></td></tr>
<tr><td>arm6True<br/></td><td></td></tr>
<tr><td>arm6Up<br/></td><td></td></tr>
<tr><td>arm7By<br/></td><td></td></tr>
<tr><td>arm7Current<br/></td><td></td></tr>
<tr><td>arm7Down<br/></td><td></td></tr>
<tr><td>arm7To<br/></td><td></td></tr>
<tr><td>arm7True<br/></td><td></td></tr>
<tr><td>arm7Up<br/></td><td></td></tr>
<tr><td>armBackButtonState<br/></td><td></td></tr>
<tr><td>armOkButtonState<br/></td><td></td></tr>
<tr><td>armPose1Get<br/></td><td></td></tr>
<tr><td>armPose1Set<br/></td><td></td></tr>
<tr><td>armPose2Get<br/></td><td></td></tr>
<tr><td>armPose2Set<br/></td><td></td></tr>
<tr><td>armPose3Get<br/></td><td></td></tr>
<tr><td>armPose3Set<br/></td><td></td></tr>
<tr><td>armPose4Get<br/></td><td></td></tr>
<tr><td>armPose4Set<br/></td><td></td></tr>
<tr><td>armPose5Get<br/></td><td></td></tr>
<tr><td>armPose5Set<br/></td><td></td></tr>
<tr><td>armPose6Get<br/></td><td></td></tr>
<tr><td>armPose6Set<br/></td><td></td></tr>
<tr><td>armPose7Get<br/></td><td></td></tr>
<tr><td>armPose7Set<br/></td><td></td></tr>
<tr><td>armPoseToEePose<br/></td><td></td></tr>
<tr><td>armPublishJointPositionCommand<br/></td><td></td></tr>
<tr><td>armShowButtonState<br/></td><td></td></tr>
<tr><td>armedThreshold<br/></td><td></td></tr>
<tr><td>assert<br/></td><td></td></tr>
<tr><td>assertNo<br/></td><td></td></tr>
<tr><td>assumeAimedPose<br/></td><td></td></tr>
<tr><td>assumeAny3dGrasp<br/></td><td></td></tr>
<tr><td>assumeBackScanningPose<br/></td><td></td></tr>
<tr><td>assumeBeeHome<br/></td><td></td></tr>
<tr><td>assumeBest3dGrasp<br/></td><td></td></tr>
<tr><td>assumeCalibrationPose<br/></td><td></td></tr>
<tr><td>assumeCrane1<br/></td><td></td></tr>
<tr><td>assumeCurrent3dGrasp<br/></td><td></td></tr>
<tr><td>assumeDeliveryPose<br/></td><td></td></tr>
<tr><td>assumeFacePose<br/></td><td></td></tr>
<tr><td>assumeHandingPose<br/></td><td></td></tr>
<tr><td>assumeLastPickOrientation<br/></td><td></td></tr>
<tr><td>assumePose<br/></td><td></td></tr>
<tr><td>assumeShrugPose<br/></td><td></td></tr>
<tr><td>assumeWinningGgAndXyInLocalPose<br/></td><td></td></tr>
<tr><td>assumeZOfPoseWord<br/></td><td></td></tr>
<tr><td>banditGetPickMode<br/></td><td></td></tr>
<tr><td>banditSetPickMode<br/></td><td></td></tr>
<tr><td>beeHome<br/></td><td></td></tr>
<tr><td>beep<br/></td><td></td></tr>
<tr><td>beginHeightLearning<br/></td><td></td></tr>
<tr><td>&quot;011310P0011_bg_left&quot;<br/></td><td></td></tr>
<tr><td>GaussianMap<br/></td><td></td></tr>
<tr><td>blankFace<br/></td><td></td></tr>
<tr><td>( 1 &quot;left_itb_light_inner&quot; digitalIOCommand 1 &quot;right_itb_light_inner&quot; digitalIOCommand 5.000000e-01 blink_scale times spinForSeconds 1 &quot;left_itb_light_outer&quot; digitalIOCommand 1 &quot;right_itb_light_outer&quot; digitalIOCommand 5.000000e-01 blink_scale times spinForSeconds 0 &quot;left_itb_light_inner&quot; digitalIOCommand 0 &quot;right_itb_light_inner&quot; digitalIOCommand 1 &quot;torso_left_itb_light_inner&quot; digitalIOCommand 1 &quot;torso_right_itb_light_inner&quot; digitalIOCommand 5.000000e-01 blink_scale times spinForSeconds 0 &quot;left_itb_light_outer&quot; digitalIOCommand 0 &quot;right_itb_light_outer&quot; digitalIOCommand 1 &quot;torso_left_itb_light_outer&quot; digitalIOCommand 1 &quot;torso_right_itb_light_outer&quot; digitalIOCommand 5.000000e-01 blink_scale times spinForSeconds 0 &quot;torso_left_itb_light_inner&quot; digitalIOCommand 0 &quot;torso_right_itb_light_inner&quot; digitalIOCommand 5.000000e-01 blink_scale times spinForSeconds 0 &quot;torso_left_itb_light_outer&quot; digitalIOCommand 0 &quot;torso_right_itb_light_outer&quot; digitalIOCommand 1.000000e+00 blink_scale times spinForSeconds )<br/></td><td></td></tr>
<tr><td>1.000000e-02<br/></td><td></td></tr>
<tr><td>( 0 setGreenHalo 0 setRedHalo 0 &quot;blink_breathe_x&quot; store oP blink_breathe_x 2 plus &quot;blink_breathe_x&quot; store blink_breathe_x setGreenHalo blink_breathe_delta spinForSeconds cP 50 replicateWord oP blink_breathe_x 2 minus &quot;blink_breathe_x&quot; store blink_breathe_x setGreenHalo blink_breathe_delta spinForSeconds cP 50 replicateWord )<br/></td><td></td></tr>
<tr><td>5.000000e-01<br/></td><td></td></tr>
<tr><td>2.500000e-01<br/></td><td></td></tr>
<tr><td>( 0 setGreenHalo 0 setRedHalo 5.000000e-01 &quot;blink_scale&quot; store oP blink_arms cP 1 replicateWord 10 &quot;blink_times&quot; store 5.000000e-02 &quot;blink_deltaT&quot; store blink_sonar_times endStackCollapseNoop 3 &quot;blink_times&quot; store 1.000000e-02 &quot;blink_deltaT&quot; store blink_sonar_times endStackCollapseNoop 0 setGreenHalo 100 setRedHalo 5.000000e-02 &quot;blink_easeT&quot; store 5.000000e-02 &quot;blink_swoopT&quot; store oP blink_sonar_swoop cP 1 replicateWord 1.000000e-02 &quot;blink_easeT&quot; store 1.000000e-02 &quot;blink_swoopT&quot; store 50 setGreenHalo 50 setRedHalo blink_sonar_swoop 0 setGreenHalo 50 setRedHalo blink_sonar_swoop 25 setGreenHalo 25 setRedHalo blink_sonar_swoop endStackCollapseNoop 10 setGreenHalo 2.500000e-01 &quot;blink_scale&quot; store oP blink_arms blink_sonar_times cP 1 replicateWord endStackCollapseNoop 25 setGreenHalo 50 setRedHalo 1.000000e-01 &quot;blink_scale&quot; store oP blink_arms blink_sonar_times cP 5 replicateWord 0 setGreenHalo 100 setRedHalo 1.000000e-02 &quot;blink_scale&quot; store oP blink_arms cP 25 replicateWord oP 100 setGreenHalo 0 setRedHalo blink_arms 0 setGreenHalo 100 setRedHalo blink_arms cP 10 replicateWord oP 100 setGreenHalo 0 setRedHalo blink_arms 0 setGreenHalo 0 setRedHalo blink_arms cP 10 replicateWord oP 0 setGreenHalo 0 setRedHalo blink_arms 0 setGreenHalo 100 setRedHalo blink_arms cP 20 replicateWord 100 setGreenHalo 0 setRedHalo endStackCollapseNoop oP blink_breathe_halo endStackCollapseNoop cP 3 replicateWord )<br/></td><td></td></tr>
<tr><td>( 0 &quot;sco_counter&quot; store oP sco_counter 1 plus dup &quot;sco_counter&quot; store 40000 langle cP oP slip cP while sco_counter print )<br/></td><td></td></tr>
<tr><td>( oB sB noop oB sB noop oP 2.500000e-01 &quot;blink_scale&quot; store 1.000000e-02 &quot;blink_deltaT&quot; store oP blink_arms blink_sonar_times cP 1 replicateWord endStackCollapseNoop 1.000000e-01 &quot;blink_scale&quot; store oP blink_arms blink_sonar_times cP 5 replicateWord cP 3 replicateWord cB oB sB noop oP blink_breathe_halo cP 3 replicateWord cB cB )<br/></td><td></td></tr>
<tr><td>1.000000e+00<br/></td><td></td></tr>
<tr><td>( blink_easeT spinForSeconds 1 0 switchSonarLed blink_easeT spinForSeconds 1 1 switchSonarLed blink_easeT spinForSeconds 1 2 switchSonarLed 0 &quot;blink_x&quot; store oP blink_swoopT spinForSeconds 0 blink_x switchSonarLed 1 blink_x 3 plus castToInteger switchSonarLed blink_x 1 plus castToInteger &quot;blink_x&quot; store cP 9 replicateWord blink_easeT spinForSeconds 0 9 switchSonarLed blink_easeT spinForSeconds 0 10 switchSonarLed blink_easeT spinForSeconds 0 11 switchSonarLed )<br/></td><td></td></tr>
<tr><td>( oP blink_deltaT spinForSeconds 4095 setSonarLed blink_deltaT spinForSeconds 0 setSonarLed cP blink_times replicateWord )<br/></td><td></td></tr>
<tr><td>5.000000e-02<br/></td><td></td></tr>
<tr><td>20<br/></td><td></td></tr>
<tr><td>blur<br/></td><td></td></tr>
<tr><td>bringUpAllNonessentialSystems<br/></td><td>Bring up systems that are not important for streaming data.</td></tr>
<tr><td>buildClassSimilarityMatrix<br/></td><td>Builds the matrix of gradients of the current class labels.</td></tr>
<tr><td>buildClassSimilarityMatrixFromDensity<br/></td><td>Builds the matrix of gradients of the current class labels.</td></tr>
<tr><td>c3dPoseBase<br/></td><td></td></tr>
<tr><td>cB<br/>}<br/></td><td></td></tr>
<tr><td>cP<br/>)<br/></td><td>Close paren; end a compound word.</td></tr>
<tr><td>cSB<br/>]<br/></td><td></td></tr>
<tr><td>( /*
  gripper projections
  these parameters interact through the pixelToGlobal function so they might need
    to address data at all heights jointly.

  variance reduction was successful during joint optimization but it lost metric
    calibration somehow in the process. maybe a strange interaction between
    the amount of space over which the average is happening due to the projection&apos;s
    changes and the variance due to focus.

  separate case not fully chased because calibration from spinning was adequate.

  later observation: this likely failed because images should be taken at all heights
    and jointly optimized, but the code at the time did not support it
  */ 200 &quot;tableReconstructStreamTakeSceneSamples&quot; store 0 &quot;tableChrStartHeight&quot; store 3 &quot;tableChrEndHeight&quot; store 1 &quot;magCalDelta&quot; store 16 &quot;magCalSteps&quot; store oP cameraGetCurrentHeightReticleX cP &quot;magCalGetter&quot; store oP cameraSetCurrentHeightReticleX cP &quot;magCalSetter&quot; store calibrateOnBundleOneDimensionJointHeights 1 &quot;magCalDelta&quot; store 16 &quot;magCalSteps&quot; store oP cameraGetCurrentHeightReticleY cP &quot;magCalGetter&quot; store oP cameraSetCurrentHeightReticleY cP &quot;magCalSetter&quot; store calibrateOnBundleOneDimensionJointHeights )<br/></td><td></td></tr>
<tr><td>calibrateCameraAToB<br/></td><td></td></tr>
<tr><td>( setTable currentPose setGripperMaskWithMotion moveEeToPoseWord calibrateRGBCameraIntrinsics /*
  calibrateVanishingPointReticleMultiSample
  */ ) &quot;When you are confident with calibrateRGBCameraIntrinsics, this is a good all-in-one.&quot; setHelp<br/></td><td>When you are confident with calibrateRGBCameraIntrinsics, this is a good all-in-one.</td></tr>
<tr><td>( 4.000000e+00 sceneSetBackgroundStdDevY 4.000000e+02 &quot;calibrateFromZScale&quot; store bg &quot;noGlassBase&quot; plus sceneLoadObservedMap calibrateFromZScale sceneSetObservedRGBFromZ sceneRenderObservedMap bg &quot;noGlassBase&quot; &quot;scaled&quot; plus plus sceneSaveObservedMap bg &quot;noGlassBase&quot; &quot;scaled&quot; plus plus sceneLoadBackgroundMap bg &quot;yesGlassBase&quot; plus sceneLoadObservedMap calibrateFromZScale sceneSetObservedRGBFromZ sceneRenderObservedMap tableUpdateMaps )<br/></td><td></td></tr>
<tr><td>( 8.000000e-07 &quot;magCalBase&quot; store 16 &quot;magCalSteps&quot; store 1.000000e-07 &quot;magCalDelta&quot; store magCalBase setCameraKappaX magCalBase setCameraKappaY 1 changeToHeight magCalBase cameraSetIdxMagX 0 cameraSetCalibrationMode 100 &quot;tableReconstructStreamTakeSceneSamples&quot; store 1 &quot;tableChrStartHeight&quot; store 1 &quot;tableChrEndHeight&quot; store 0.000000e+00 &quot;tableChrExtraZ&quot; store /*
  ( cameraKappaX ) &quot;magCalGetter&quot; store
  ( setCameraKappaX ) &quot;magCalSetter&quot; store
  calibrateOnBundleOneDimension
*/ oP cameraKappaY cP &quot;magCalGetter&quot; store oP setCameraKappaY cP &quot;magCalSetter&quot; store calibrateOnBundleOneDimension ) &quot;Find distortion for new calibration.&quot; setHelp<br/></td><td>Find distortion for new calibration.</td></tr>
<tr><td>( 2.500000e-04 &quot;tableReconstructWithZGridMultiplier&quot; store 2.425000e-03 &quot;magCalBase&quot; store 32 &quot;magCalSteps&quot; store 6.250000e-06 &quot;magCalDelta&quot; store magCalBase setCameraMuX magCalBase setCameraMuY 1 changeToHeight magCalBase cameraSetIdxMagX 0 cameraSetCalibrationMode 2000 &quot;tableReconstructStreamTakeSceneSamples&quot; store tableReconstructStreamTakeSceneSamples &quot;tableSpiralStreamTakeSceneSamples&quot; store 1 &quot;tableChrStartHeight&quot; store 1 &quot;tableChrEndHeight&quot; store 0.000000e+00 &quot;tableChrExtraZ&quot; store oP cameraMuX cP &quot;magCalGetter&quot; store oP setCameraMuX cP &quot;magCalSetter&quot; store calibrateOnBundleOneDimension oP cameraMuY cP &quot;magCalGetter&quot; store oP setCameraMuY cP &quot;magCalSetter&quot; store calibrateOnBundleOneDimension ) &quot;Find magnification for new calibration.&quot; setHelp<br/></td><td>Find magnification for new calibration.</td></tr>
<tr><td>calibrateGripper<br/></td><td></td></tr>
<tr><td>( 0.000000e+00 &quot;tableReconstructWithZTotalZ&quot; store 1 sceneSetFixationMode 200 &quot;tableReconstructStreamTakeSceneSamples&quot; store 0 sceneSetDepthPatchHalfWidth 201 sceneSetAngularApertureRows 201 sceneSetAngularApertureCols quarterImpulse waitUntilAtCurrentPosition /* do binning from this height for good sample size */ 1 changeToHeight currentPose &quot;tableUpdateSpiralPos&quot; store 0 &quot;tableChrThisHeight&quot; store 3 &quot;tableChrEndHeight&quot; store oP tableChrThisHeight tableChrEndHeight langle tableChrThisHeight tableChrEndHeight equals or cP oP tableChrThisHeight changeToHeight /*
    sceneInit 
    */ slfgRebase sceneClearObservedMap clearStreamBuffers tableUpdateSpinCoreNoClean quarterImpulse tableUpdateSpiralPos moveEeToPoseWord tableChrThisHeight changeToHeight waitUntilAtCurrentPosition /* finds the current height difference */ /*
    tableReconstructWithZTopZ 0.388 divide 0.002 times  &quot;slfgRebaseCellWidth&quot; store slfgRebase
    */ 1.000000e-03 &quot;slfgRebaseCellWidth&quot; store slfgRebaseTable /* this actually needs to happen after movement so position is still correct for FIXATION calibrators */ tableReconstructWithZ tableUpdateMaps /*
    tableChrThisHeight sceneSetHeightReticleFromVariance
    */ slide oP scenePushPixelOfMinVariance 1 sP cP tableChrThisHeight 1 plus &quot;tableChrThisHeight&quot; store /*
    pauseStackExecution
    */ cP whileCollapsed calibrateHeightReticlesSetAll 0 sceneSetFixationMode tableReconstructWithZTotalZDefault &quot;tableReconstructWithZTotalZ&quot; store )<br/></td><td></td></tr>
<tr><td>( tableChrEndHeight &quot;tableChrThisHeight&quot; store oP tableChrThisHeight 0 rangle tableChrThisHeight 0 equals or cP oP tableChrThisHeight swap slip sceneSetHeightReticleFromPixel tableChrThisHeight 1 minus &quot;tableChrThisHeight&quot; store cP whileCollapsed )<br/></td><td></td></tr>
<tr><td>( 0.000000e+00 &quot;tableReconstructWithZTotalZ&quot; store /*
  depth dependent magnification 
  don&apos;t bias different heights by the others,
   address each height separately
  */ /* 
  */ 1.375000e+00 &quot;magCalBase&quot; store 64 &quot;magCalSteps&quot; store 4.000000e-02 &quot;magCalDelta&quot; store 0 changeToHeight magCalBase cameraSetIdxMagY magCalBase cameraSetIdxMagX 1 changeToHeight magCalBase cameraSetIdxMagY magCalBase cameraSetIdxMagX 2 changeToHeight magCalBase cameraSetIdxMagY magCalBase cameraSetIdxMagX 3 changeToHeight magCalBase cameraSetIdxMagY magCalBase cameraSetIdxMagX 0 cameraSetCalibrationMode 100 &quot;tableReconstructStreamTakeSceneSamples&quot; store 0 &quot;tableChrStartHeight&quot; store 1 &quot;tableChrEndHeight&quot; store 0.000000e+00 &quot;tableChrExtraZ&quot; store oP cameraGetIdxMagX cP &quot;magCalGetter&quot; store oP cameraSetIdxMagX cP &quot;magCalSetter&quot; store calibrateOnBundleOneDimension oP cameraGetIdxMagY cP &quot;magCalGetter&quot; store oP cameraSetIdxMagY cP &quot;magCalSetter&quot; store calibrateOnBundleOneDimension /*
  */ /* 
  although we don&apos;t use heights 3 and 4 explicitly, setting them to the value of height 1 helps the quadratic
  fit better if we don&apos;t feel like collecting them explicitly
  */ 1 changeToHeight cameraGetIdxMagY dup 2 changeToHeight cameraSetIdxMagY 3 changeToHeight cameraSetIdxMagY 1 changeToHeight cameraGetIdxMagX dup 2 changeToHeight cameraSetIdxMagX 3 changeToHeight cameraSetIdxMagX cameraFitHyperbolic 2 cameraSetCalibrationMode tableReconstructWithZTotalZDefault &quot;tableReconstructWithZTotalZ&quot; store )<br/></td><td></td></tr>
<tr><td>( /*

  make a map with the first camera
  set block filter size appropriately
  * add a detection in the middle of the workspace
	* push pose of cblock in this, the first map 
  create a temporary calibrator block (cblock) class
  grab the most certainly discrepant cblock region as the model
  switch to the second camera
  make a (the) second map and localize the cblock
	* push pose of cblock in second map
      obtain relative transformation between the two cblock poses
      push the second camera offset
    apply the relative transformation to the pushed camera offset
  set the camera offset to the transformed value

  */ cameraWristConfig /*
  tableTakeScene
*/ 1.000000e-01 &quot;tableBlockMaxGraspThickness&quot; store 0.000000e+00 &quot;tableBlockGripperThrow&quot; store 1.000000e-01 &quot;tableBlockTargetContactWidth&quot; store tableSwapToBlocks sceneClearPredictedObjects 0 0 0 sceneAddPredictedFocusedObject 0 scenePushSceneObjectPose &quot;ccOffPredition1&quot; store 1.000000e-02 &quot;sceneGrabDiscrepantCropAsClassDefaultThresh&quot; store sceneGrabDiscrepantCropAsClassDefaultThresh sceneGrabDiscrepantCropAsClass /*
  incrementCamera
  cameraK2QHDConfig

  0.0 sceneSetScoreThresh
  10000000 sceneSetDiscrepancySearchDepth 

  sceneClearPredictedObjects
  scenePredictBestObject tableUpdateMaps
    0 scenePushSceneObjectPose
  &quot;ccOffPredition2&quot; store
  tableTakeScene

    ccOffPredition1 ccOffPredition2 eePoseGetPoseRelativeTo
  &quot;ccOffRelativeTransform&quot; store

    handCameraOffset ccOffRelativeTransform eePoseApplyRelativePoseTo
  &quot;ccOffNewCameraPose&quot; store

  ccOffNewCameraPose setHandCameraOffset
*/ ) &quot;Find the offset of the next (second) camera from the current (first) camera and use this to set the offset of the next camera.&quot; setHelp<br/></td><td>Find the offset of the next (second) camera from the current (first) camera and use this to set the offset of the next camera.</td></tr>
<tr><td>( 0 cameraSetCalibrationMode 351 sceneSetAngularApertureRows 551 sceneSetAngularApertureCols 0 sceneSetFixationMode quarterImpulse waitUntilAtCurrentPosition 1 changeToHeight currentPose &quot;tableUpdateSpiralPos&quot; store tableChrStartHeight &quot;tableChrThisHeight&quot; store oP tableChrThisHeight tableChrEndHeight langle tableChrThisHeight tableChrEndHeight equals or cP oP tableChrThisHeight changeToHeight currentPose currentPose eePosePZ tableChrExtraZ plus setEEPosePZ moveEeToPoseWord waitUntilAtCurrentPosition comeToStop sceneInit sceneClearObservedMap clearStreamBuffers waitUntilAtCurrentPosition tableUpdateMagCoreNoClean quarterImpulse tableUpdateSpiralPos moveEeToPoseWord /* necessary for mag changes to take effect properly */ tableChrThisHeight changeToHeight waitUntilAtCurrentPosition tableMagCalibrationGridSearcher tableChrThisHeight 1 plus &quot;tableChrThisHeight&quot; store /*
    pauseStackExecution
    */ cP whileCollapsed /* this one takes images and optimizes each height only on its images */ )<br/></td><td></td></tr>
<tr><td>( 0 cameraSetCalibrationMode 351 sceneSetAngularApertureRows 351 sceneSetAngularApertureCols 0 sceneSetFixationMode quarterImpulse waitUntilAtCurrentPosition 1 changeToHeight currentPose &quot;tableUpdateSpiralPos&quot; store tableChrStartHeight &quot;tableChrThisHeight&quot; store oP tableChrThisHeight tableChrEndHeight langle tableChrThisHeight tableChrEndHeight equals or cP oP tableChrThisHeight changeToHeight currentPose currentPose eePosePZ tableChrExtraZ plus setEEPosePZ moveEeToPoseWord waitUntilAtCurrentPosition comeToStop sceneInit sceneClearObservedMap clearStreamBuffers waitUntilAtCurrentPosition tableUpdateMagCoreNoClean endStackCollapseNoop tableChrThisHeight 1 plus &quot;tableChrThisHeight&quot; store cP whileCollapsed quarterImpulse tableUpdateSpiralPos moveEeToPoseWord waitUntilAtCurrentPosition tableChrStartHeight &quot;tableChrThisHeight&quot; store oP tableChrThisHeight tableChrEndHeight langle tableChrThisHeight tableChrEndHeight equals or cP oP tableChrThisHeight changeToHeight tableChrThisHeight 1 plus &quot;tableChrThisHeight&quot; store tableMagCalibrationGridSearcher cP whileCollapsed /*
  pauseStackExecution
  */ /* this one takes images at all 4 heights then optimizes each height with images at all 4 heights */ )<br/></td><td></td></tr>
<tr><td>( initializeAndFocusOnNewClass calibrateHeightReticles calibrateMagnification ) &quot;Calibrate the RGB camera; start from a position near the table as we set the table height first.  Make sure you&apos;ve set up the magic circle with magic paper&quot; setHelp<br/></td><td>Calibrate the RGB camera; start from a position near the table as we set the table height first.  Make sure you&apos;ve set up the magic circle with magic paper</td></tr>
<tr><td>calibrateRGBCameraIntrinsicsPoint<br/></td><td>Run the old wrist camera calibration, that uses a single black dot to calibrate.  You should use the new light field calibration with magic paper instead.</td></tr>
<tr><td>( /* Take a scene, add some glass, take another scene, look at discrepant cells, average color, 
store. Then use this to segment specular highlight, which is another channel for discrepancy and
a means by which to infer 3D structure. */ &quot;Make sure the background is clear of objects and unpause.&quot; print pauseStackExecution tableTakeSceneNoReconstruct tableReconstructLightSlabWithoutZ bg &quot;calibrateLM_background&quot; plus sceneSaveObservedMap bg &quot;calibrateLM_background&quot; plus sceneLoadBackgroundMap &quot;Add a sheet of transparent material and unpause.&quot; print pauseStackExecution tableTakeSceneNoReconstruct tableReconstructLightSlabWithoutZ bg &quot;calibrateLM_background&quot; plus sceneSaveObservedMap 5.000000e-01 sceneSetLightModelFromDiscrepancy ) &quot;learn a one color lighting model with the lens array.&quot; setHelp<br/></td><td>learn a one color lighting model with the lens array.</td></tr>
<tr><td>( 0.000000e+00 &quot;tableReconstructWithZTotalZ&quot; store 201 sceneSetAngularApertureRows 201 sceneSetAngularApertureCols 1 sceneSetFixationMode quarterImpulse waitUntilAtCurrentPosition /* do binning from this height for good sample size */ 1 changeToHeight currentPose &quot;tableUpdateSpiralPos&quot; store 0 changeToHeight 1.000000e-02 setGridSize oP zDown cP 12 replicateWord waitUntilAtCurrentPosition sceneInit sceneClearObservedMap clearStreamBuffers 1.000000e-03 &quot;slfgRebaseCellWidth&quot; store slfgRebaseTable tableUpdateZoomCoreNoClean quarterImpulse tableUpdateSpiralPos moveEeToPoseWord waitUntilAtCurrentPosition /* this actually needs to happen after movement so position is still correct for FIXATION calibrators */ tableReconstructFromStream tableUpdateMaps /*
  sceneSetVanishingPointFromVariance
  */ 0 sceneSetFixationMode tableReconstructWithZTotalZDefault &quot;tableReconstructWithZTotalZ&quot; store )<br/></td><td></td></tr>
<tr><td>( 0.000000e+00 &quot;tableReconstructWithZTotalZ&quot; store 3.000000e-02 &quot;thisGridSize&quot; store sceneClearDepthStack /* two types of averaging, variance over depth stack and again by averaging coordinatewise estimates */ waitUntilAtCurrentPosition calibrateVanishingPointReticle scenePushOntoDepthStack scenePushPixelOfMinVariance thisGridSize setGridSize xUp yUp calibrateVanishingPointReticle scenePushOntoDepthStack scenePushPixelOfMinVariance thisGridSize setGridSize xDown xDown calibrateVanishingPointReticle scenePushOntoDepthStack scenePushPixelOfMinVariance thisGridSize setGridSize yDown yDown calibrateVanishingPointReticle scenePushOntoDepthStack scenePushPixelOfMinVariance thisGridSize setGridSize xUp xUp calibrateVanishingPointReticle scenePushOntoDepthStack scenePushPixelOfMinVariance thisGridSize setGridSize xDown yUp waitUntilAtCurrentPosition /* average the coordinates that were on the stack */ printStacks 0 &quot;vanishingXTotal&quot; store 0 &quot;vanishingYTotal&quot; store 0 &quot;vanishingNumSamples&quot; store oP vanishingXTotal plus &quot;vanishingXTotal&quot; store vanishingYTotal plus &quot;vanishingYTotal&quot; store vanishingNumSamples 1 plus &quot;vanishingNumSamples&quot; store cP 5 replicateWord vanishingXTotal vanishingNumSamples divide &quot;vanishingXAve&quot; store vanishingYTotal vanishingNumSamples divide &quot;vanishingYAve&quot; store vanishingYAve vanishingXAve sceneSetVanishingPointFromPixel /* 
  scenePushPixelOfMinStackVariance sceneSetVanishingPointFromPixel
  */ tableReconstructWithZTotalZDefault &quot;tableReconstructWithZTotalZ&quot; store )<br/></td><td></td></tr>
<tr><td>cameraCenterX<br/></td><td></td></tr>
<tr><td>cameraCenterY<br/></td><td></td></tr>
<tr><td>cameraCreate<br/></td><td>Creates a new camera, usage in kinect2.back</td></tr>
<tr><td>cameraCropUpperLeftCornerX<br/></td><td></td></tr>
<tr><td>cameraCropUpperLeftCornerY<br/></td><td></td></tr>
<tr><td>cameraExposure<br/></td><td></td></tr>
<tr><td>cameraFitHyperbolic<br/></td><td></td></tr>
<tr><td>cameraFitQuadratic<br/></td><td></td></tr>
<tr><td>cameraGain<br/></td><td></td></tr>
<tr><td>cameraGetCalibrationMode<br/></td><td></td></tr>
<tr><td>cameraGetCurrentHeightReticleX<br/></td><td></td></tr>
<tr><td>cameraGetCurrentHeightReticleY<br/></td><td></td></tr>
<tr><td>cameraGetIdxMagX<br/></td><td></td></tr>
<tr><td>cameraGetIdxMagY<br/></td><td></td></tr>
<tr><td>cameraGetTransformMatrix<br/></td><td></td></tr>
<tr><td>cameraGetVpX<br/></td><td></td></tr>
<tr><td>cameraGetVpY<br/></td><td></td></tr>
<tr><td>cameraInitializeConfig<br/></td><td>Initialize the configuration of the camera (reticles) with reasonable default values based on image size.</td></tr>
<tr><td>( 1 setCameraR00 0 setCameraR01 0 setCameraR10 1 setCameraR11 3.815000e-02 1.144000e-02 1.589000e-02 0 0 0 1 createEEPose setHandCameraOffset 1.900000e-03 setCameraMuX 1.950000e-03 setCameraMuY 0.000000e+00 setCameraKappaX 2.000000e-07 setCameraKappaY 250 setCameraCenterX 250 setCameraCenterY 0 setCameraCropUpperLeftCornerX 0 setCameraCropUpperLeftCornerY /*
960
540
*/ )<br/></td><td></td></tr>
<tr><td>( 1 setCameraR00 0 setCameraR01 0 setCameraR10 1 setCameraR11 3.815000e-02 1.144000e-02 1.589000e-02 0 0 0 1 createEEPose setHandCameraOffset 1.900000e-03 setCameraMuX 1.950000e-03 setCameraMuY 0.000000e+00 setCameraKappaX 2.000000e-07 setCameraKappaY 480 setCameraCenterX 270 setCameraCenterY 0 setCameraCropUpperLeftCornerX 0 setCameraCropUpperLeftCornerY /*
960
540
*/ )<br/></td><td></td></tr>
<tr><td>cameraKappaX<br/></td><td></td></tr>
<tr><td>cameraKappaY<br/></td><td></td></tr>
<tr><td>cameraMuX<br/></td><td></td></tr>
<tr><td>cameraMuY<br/></td><td></td></tr>
<tr><td>cameraName<br/></td><td></td></tr>
<tr><td>cameraPrintParams<br/></td><td></td></tr>
<tr><td>cameraR00<br/></td><td></td></tr>
<tr><td>cameraR01<br/></td><td></td></tr>
<tr><td>cameraR10<br/></td><td></td></tr>
<tr><td>cameraR11<br/></td><td></td></tr>
<tr><td>cameraSetCalibrationMode<br/></td><td></td></tr>
<tr><td>cameraSetCurrentHeightReticleX<br/></td><td></td></tr>
<tr><td>cameraSetCurrentHeightReticleY<br/></td><td></td></tr>
<tr><td>cameraSetIdxMagX<br/></td><td></td></tr>
<tr><td>cameraSetIdxMagY<br/></td><td></td></tr>
<tr><td>cameraSetTransformMatrix<br/></td><td></td></tr>
<tr><td>cameraSetVpX<br/></td><td></td></tr>
<tr><td>cameraSetVpY<br/></td><td></td></tr>
<tr><td>cameraWhiteBalanceBlue<br/></td><td></td></tr>
<tr><td>cameraWhiteBalanceGreen<br/></td><td></td></tr>
<tr><td>cameraWhiteBalanceRed<br/></td><td></td></tr>
<tr><td>( 0 setCameraR00 1 setCameraR01 -1 setCameraR10 0 setCameraR11 /* 
  0.03815 0.01144 0.01589 0 0 0 1 createEEPose setHandCameraOffset 
  0.027 0.012 0.01589 0 0 0 1 createEEPose setHandCameraOffset 
  0.0024 setCameraMuX 0.00245 setCameraMuY
  0.0 setCameraKappaX 0.0000002 setCameraKappaY

  0.027 0.012 0.01589 0 0 0 1 createEEPose setHandCameraOffset
  0.05 0.015 0.01589 0 0 0 1 createEEPose setHandCameraOffset
  */ 2.400000e-03 setCameraMuX 2.450000e-03 setCameraMuY 0.000000e+00 setCameraKappaX 0.000000e+00 setCameraKappaY 640 setCameraCenterX 400 setCameraCenterY 320 setCameraCropUpperLeftCornerX 200 setCameraCropUpperLeftCornerY )<br/></td><td></td></tr>
<tr><td>cameraZeroNonLinear<br/></td><td></td></tr>
<tr><td>car<br/>First<br/>Head<br/></td><td>Takes a compound word on the stack and returns the first word in the list.</td></tr>
<tr><td>castToInteger<br/></td><td></td></tr>
<tr><td>( oP 1 cP oP setPlaceModeToShake 1 changeToHeight clearMapForPatrol clearBlueBoxMemories tableMapBestAndPick playWorkspace moveEeToPoseWord 1 changeToHeight currentPose scan_findObjectAfterDrop &quot;scan_catScanSees&quot; store scan_catPickCounter 1 plus &quot;scan_catPickCounter&quot; store cP whileCollapsed )<br/></td><td></td></tr>
<tr><td>( /* expects an eePose on the stack */ clearClassLabels setGraspModeTo3D tenthImpulse /* eePose */ moveEeToPoseWord 1 changeToHeight waitUntilAtCurrentPosition 0 &quot;scan_catScanCounter&quot; store &quot;catScan5_&quot; robotSerial leftOrRightArm dateString &quot;/&quot; plus plus plus plus &quot;scan_catScanObjectName&quot; store scan_catScanObjectName setScanGroup currentPose scan_findObjectAfterDrop &quot;scan_catScanSees&quot; store /* 
  tableSpiralTakeScene
  */ setBoundingBoxModeToMapping clearMapForPatrol 1 changeToHeight waitUntilAtCurrentPosition 0 currentTableZ minus pickFlushFactor plus &quot;scan_gripperTouchTableZ&quot; store setPickModeToLearningAlgorithmC oP scan_catScanCounter scan_catScanLimit langle scan_catScanSees and cP oP setPickModeToLearningAlgorithmC setPlaceModeToShake tableAddBlockGraspSaveModelAndPickAfterFind currentPose scan_findObjectAfterDrop &quot;scan_catScanSees&quot; store currentPose &quot;catScan5Pos&quot; store /* 
    tableSpiralTakeScene
    */ scan_catScanCounter 1 plus &quot;scan_catScanCounter&quot; store cP whileCollapsed 0 &quot;scan_catPickCounter&quot; store playWorkspace moveEeToPoseWord 1 changeToHeight oP scan_catPickCounter scan_catPickLimit langle scan_catScanSees and cP oP 1 changeToHeight clearMapForPatrol clearBlueBoxMemories dateString &quot;catScan5VarianceTrialBatchTime&quot; store oP catScan5VarianceTrial cP catScan5NumVarianceTrials replicateWord tableMapBestAndPickInPlace playWorkspace moveEeToPoseWord 1 changeToHeight waitUntilAtCurrentPosition /* press until effort here to deposit cleanly */ comeToStop pressUntilEffortInit 3.000000e-02 setSpeed pressUntilEffortCombo openGripper liftArm waitUntilAtCurrentPosition currentPose scan_findObjectAfterDrop &quot;scan_catScanSees&quot; store scan_catPickCounter 1 plus &quot;scan_catPickCounter&quot; store cP whileCollapsed /*
    catScan5 uses bandits over 3d grasps to select the best grasp, perform
    redundant servoing and collect data for localization and classification studies
  */ tableSaveFocusedThumbnails )<br/></td><td></td></tr>
<tr><td>( halfImpulse catScan5InputPileTakeScene bg &quot;_green_back&quot; leftOrRightArm plus plus sceneSaveObservedMap catScan5SaveInputBgRAM catScan5SaveInputBgDisk halfImpulse assumeCrane1 catScan5OutputPileTakeScene bg &quot;_green_front&quot; leftOrRightArm plus plus sceneSaveObservedMap bg &quot;_cat_temp&quot; leftOrRightArm plus plus sceneSaveObservedMap currentObservedMap sceneCopyGaussianMap &quot;bg_cat_tempRAM&quot; store )<br/></td><td></td></tr>
<tr><td>( halfImpulse inputPileWorkspace moveEeToPoseWord 1 changeToHeight shiftIntoGraspGear3 1.000000e-02 setGridSize oP xDown cP 2 replicateWord oP yDown cP 2 replicateWord shoreUp tableTakeScene )<br/></td><td></td></tr>
<tr><td>( bg &quot;_green_back&quot; leftOrRightArm plus plus sceneLoadObservedMap catScan5SaveInputBgRAM catScan5SaveInputBgDisk bg &quot;_green_front&quot; leftOrRightArm plus plus sceneLoadObservedMap bg &quot;_cat_temp&quot; leftOrRightArm plus plus sceneSaveObservedMap currentObservedMap sceneCopyGaussianMap &quot;bg_cat_tempRAM&quot; store )<br/></td><td></td></tr>
<tr><td>( catScan5LoadInputBgRAM /*
  bg sceneSaveBackgroundMap
  */ /*
  tableRegularizeBackground
  */ )<br/></td><td></td></tr>
<tr><td>( &quot;catScan5InputBg&quot; &quot;_&quot; leftOrRightArm plus plus sceneLoadBackgroundMap bg sceneSaveBackgroundMap )<br/></td><td></td></tr>
<tr><td>( leftOrRightArm &quot;right&quot; equals oP &quot;loading INPUT background map for RIGHT side from RAM.&quot; print currentScene catScan5InputBgRAM_right sceneSetBackgroundMap sceneRenderScene cP oP leftOrRightArm &quot;left&quot; equals oP &quot;loading INPUT background map for LEFT side from RAM.&quot; print currentScene catScan5InputBgRAM_left sceneSetBackgroundMap sceneRenderScene cP oP &quot;Neither left or right arm, not loading INPUT background map from RAM&quot; leftOrRightArm pauseStackExecution cP ifte cP ifte currentBackgroundMap sceneCopyGaussianMap &quot;bgRAM&quot; store )<br/></td><td></td></tr>
<tr><td>( catScan5LoadPlayBgRAM /*
  bg sceneSaveBackgroundMap
  */ /*
  tableRegularizeBackground
  */ )<br/></td><td></td></tr>
<tr><td>( &quot;catScan5PlayBg&quot; &quot;_&quot; leftOrRightArm plus plus sceneLoadBackgroundMap bg sceneSaveBackgroundMap )<br/></td><td></td></tr>
<tr><td>( leftOrRightArm &quot;right&quot; equals oP &quot;loading PLAY background map for RIGHT side from RAM.&quot; print currentScene catScan5PlayBgRAM_right sceneSetBackgroundMap sceneRenderScene cP oP leftOrRightArm &quot;left&quot; equals oP &quot;loading PLAY background map for LEFT side from RAM.&quot; print currentScene catScan5PlayBgRAM_left sceneSetBackgroundMap sceneRenderScene cP oP &quot;Neither left or right arm, not loading PLAY background map from RAM&quot; leftOrRightArm pauseStackExecution cP ifte cP ifte currentBackgroundMap sceneCopyGaussianMap &quot;bgRAM&quot; store )<br/></td><td></td></tr>
<tr><td>0<br/></td><td></td></tr>
<tr><td>( halfImpulse /*
  outputPileWorkspace moveEeToPoseWord 1 changeToHeight shiftIntoGraspGear1 
*/ outputPileWorkspace moveEeToPoseWord 1 changeToHeight shiftIntoGraspGear3 waitUntilAtCurrentPosition 1.000000e-02 setGridSize oP xDown cP 2 replicateWord oP yDown cP 2 replicateWord shoreUp tableTakeScene )<br/></td><td></td></tr>
<tr><td>( halfImpulse playWorkspace moveEeToPoseWord 1 changeToHeight shiftIntoGraspGear1 shoreUp tableTakeScene )<br/></td><td></td></tr>
<tr><td>( &quot;catScan5InputBg&quot; &quot;_&quot; leftOrRightArm plus plus sceneSaveObservedMap )<br/></td><td></td></tr>
<tr><td>( leftOrRightArm &quot;right&quot; equals oP &quot;saving INPUT background map for RIGHT side to RAM.&quot; print currentObservedMap sceneCopyGaussianMap &quot;catScan5InputBgRAM_right&quot; store cP oP leftOrRightArm &quot;left&quot; equals oP &quot;saving INPUT background map for LEFT side to RAM.&quot; print currentObservedMap sceneCopyGaussianMap &quot;catScan5InputBgRAM_left&quot; store cP oP &quot;Neither left or right arm, not saving INPUT background map to RAM&quot; leftOrRightArm pauseStackExecution cP ifte cP ifte ) &quot;saves the current observed map to the input workspace background variable.&quot; setHelp<br/></td><td>saves the current observed map to the input workspace background variable.</td></tr>
<tr><td>( &quot;catScan5PlayBg&quot; &quot;_&quot; leftOrRightArm plus plus sceneSaveObservedMap )<br/></td><td></td></tr>
<tr><td>( leftOrRightArm &quot;right&quot; equals oP &quot;saving PLAY background map for RIGHT side to RAM.&quot; print currentObservedMap sceneCopyGaussianMap &quot;catScan5PlayBgRAM_right&quot; store cP oP leftOrRightArm &quot;left&quot; equals oP &quot;saving PLAY background map for LEFT side to RAM.&quot; print currentObservedMap sceneCopyGaussianMap &quot;catScan5PlayBgRAM_left&quot; store cP oP &quot;Neither left or right arm, not saving PLAY background map to RAM&quot; leftOrRightArm pauseStackExecution cP ifte cP ifte ) &quot;saves the current observed map to the play workspace background variable.&quot; setHelp<br/></td><td>saves the current observed map to the play workspace background variable.</td></tr>
<tr><td>( inputPileWorkspace &quot;temp&quot; store outputPileWorkspace &quot;inputPileWorkspace&quot; store temp &quot;outputPileWorkspace&quot; store 0 &quot;pileSwitchCounter&quot; store catScan5SwapInputOutputRAM )<br/></td><td></td></tr>
<tr><td>( bg &quot;_cat_temp_2&quot; leftOrRightArm plus plus sceneSaveBackgroundMap bg &quot;_cat_temp&quot; leftOrRightArm plus plus sceneLoadBackgroundMap &quot;catScan5InputBg&quot; &quot;_&quot; leftOrRightArm plus plus sceneSaveBackgroundMap bg &quot;_cat_temp_2&quot; leftOrRightArm plus plus sceneLoadObservedMap bg &quot;_cat_temp&quot; leftOrRightArm plus plus sceneSaveObservedMap )<br/></td><td></td></tr>
<tr><td>( currentBackgroundMap sceneCopyGaussianMap &quot;bg_cat_temp_2RAM&quot; store /* loads into observed map so that catScan5SaveInputBgRAM works, 
     loads background so that the above call to currentBackgroundMap succeeds. */ currentScene bg_cat_tempRAM sceneCopyGaussianMap sceneSetObservedMap sceneRenderScene currentScene bg_cat_tempRAM sceneCopyGaussianMap sceneSetBackgroundMap sceneRenderScene catScan5SaveInputBgRAM bg_cat_temp_2RAM sceneCopyGaussianMap &quot;bg_cat_tempRAM&quot; store )<br/></td><td></td></tr>
<tr><td>( initializeAndFocusOnTempClass catScan5InputPileTakeScene /*
  catScan5SaveInputBgDisk
  */ catScan5SaveInputBgRAM catScan5LoadInputBg )<br/></td><td></td></tr>
<tr><td>( initializeAndFocusOnTempClass catScan5PlayTakeScene /*
  catScan5SavePlayBgDisk
  */ catScan5SavePlayBgRAM catScan5LoadPlayBg )<br/></td><td></td></tr>
<tr><td>( dataDirectory &quot;/objects/&quot; focusedClassLabel &quot;/&quot; catScan5VarianceTrialName &quot;/&quot; plus plus plus plus plus &quot;catScan5VarianceTrialDir&quot; store catScan5VarianceTrialDir mkdirs &quot;catScan5VarianceTrial BEGINNING&quot; print 1.000000e-01 perturbPositionScale waitUntilAtCurrentPosition sceneClearPredictedObjects tableUpdateMaps oP tableSpiralServoToBestSceneObject waitUntilAtCurrentPosition setMovementStateToMoving comeToStop cP 2 replicateWord scenePushNumSceneObjects 1 equals oP dateString &quot;catScan5VarianceTrialThisTime&quot; store catScan5VarianceTrialDir &quot;scene_&quot; catScan5VarianceTrialBatchTime &quot;_&quot; catScan5VarianceTrialThisTime plus plus plus plus &quot;catScan5VarianceTrialThisFileName&quot; store sceneSetAnnotatedClassNameToFocusedClass sceneSetPredictedClassNameToFocusedClass catScan5VarianceTrialThisFileName &quot;.yml&quot; plus sceneSaveSceneAbsolute clearBlueBoxMemories 0 sceneMapSceneObject cP ift &quot;catScan5VarianceTrial ENDING&quot; print )<br/></td><td></td></tr>
<tr><td>catScan5VarianceTrialAuditClassNames<br/></td><td></td></tr>
<tr><td>catScan5VarianceTrialAutolabelClassNames<br/></td><td></td></tr>
<tr><td>&quot;2018-04-12_14:40:18.024800024800&quot;<br/></td><td></td></tr>
<tr><td>catScan5VarianceTrialCalculateAllClassesAccuracy<br/></td><td></td></tr>
<tr><td>catScan5VarianceTrialCalculateConfigurationAccuracy<br/></td><td></td></tr>
<tr><td>catScan5VarianceTrialCalculatePoseVariances<br/></td><td></td></tr>
<tr><td>&quot;trial&quot;<br/></td><td></td></tr>
<tr><td>&quot;2018-04-12_14:40:18.024846024846&quot;<br/></td><td></td></tr>
<tr><td>( dataDirectory &quot;/objects/&quot; focusedClassLabel &quot;/&quot; catScan5VarianceTrialName &quot;/&quot; plus plus plus plus plus &quot;catScan5VarianceTrialDir&quot; store catScan5VarianceTrialDir mkdirs &quot;catScan5VarianceTrialZ BEGINNING&quot; print /*
  0.1 perturbPositionScale waitUntilAtCurrentPosition
  */ 5.000000e-02 perturbPositionScale waitUntilAtCurrentPosition sceneClearPredictedObjects tableUpdateMaps /* XXX Reconstruct Servo */ 10 &quot;tableReconstructStreamTakeSceneSamples&quot; store oP tableReconstructServoToBestSceneObject waitUntilAtCurrentPosition setMovementStateToMoving comeToStop cP 2 replicateWord dateString &quot;catScan5VarianceTrialThisTime&quot; store scenePushNumSceneObjects 1 equals oP catScan5VarianceTrialDir &quot;scene_&quot; catScan5VarianceTrialBatchTime &quot;_&quot; catScan5VarianceTrialThisTime plus plus plus plus &quot;catScan5VarianceTrialThisFileName&quot; store cP oP &quot;catScan5VarianceTrialZ: no scene objects, recording with different label.&quot; print catScan5VarianceTrialDir &quot;no_objects_scene_&quot; catScan5VarianceTrialBatchTime &quot;_&quot; catScan5VarianceTrialThisTime plus plus plus plus &quot;catScan5VarianceTrialThisFileName&quot; store cP ifte sceneSetAnnotatedClassNameToFocusedClass sceneSetPredictedClassNameToFocusedClass 100 &quot;tableReconstructStreamTakeSceneSamples&quot; store /* XXX form Reconstructed */ 1.600000e-01 &quot;tableReconstructWithZTotalZ&quot; store tableReconstructFromStream /* XXX save Reconstructed */ catScan5VarianceTrialThisFileName &quot;_marginals_height&quot; &quot;.yml&quot; plus plus sceneSaveSceneAbsolute sceneMinDepthStackIntoRegister sceneRecallFromRegister sceneRenderZ sceneRenderObservedMap tableUpdateMaps catScan5VarianceTrialThisFileName &quot;_maximum_likelihood_height&quot; &quot;.yml&quot; plus plus sceneSaveSceneAbsolute /* XXX form table height rendered  */ 0.000000e+00 &quot;tableReconstructWithZTotalZ&quot; store tableReconstructFromStream 1.600000e-01 &quot;tableReconstructWithZTotalZ&quot; store /* XXX save table height rendered  */ catScan5VarianceTrialThisFileName &quot;_table_height&quot; &quot;.yml&quot; plus plus sceneSaveSceneAbsolute clearBlueBoxMemories 0 sceneMapSceneObject &quot;catScan5VarianceTrialZ ENDING&quot; print )<br/></td><td></td></tr>
<tr><td>( /* string argument on stack */ &quot;catScan5VarianceTrialName&quot; store halfImpulse oP tableSpiralServoToBestSceneObject waitUntilAtCurrentPosition setMovementStateToMoving comeToStop cP 1 replicateWord currentPose oP catScan5VarianceTrial dup moveEeToPoseWord waitUntilAtCurrentPosition setMovementStateToMoving comeToStop cP 5 replicateWord pop )<br/></td><td></td></tr>
<tr><td>( /* string argument on stack */ &quot;catScan5VarianceTrialName&quot; store catScan5LoadPlayBg halfImpulse 10 &quot;tableReconstructStreamTakeSceneSamples&quot; store oP tableReconstructServoToBestSceneObject waitUntilAtCurrentPosition setMovementStateToMoving comeToStop cP 2 replicateWord currentPose oP catScan5VarianceTrialZ dup moveEeToPoseWord waitUntilAtCurrentPosition setMovementStateToMoving comeToStop cP 5 replicateWord pop )<br/></td><td></td></tr>
<tr><td>5<br/></td><td></td></tr>
<tr><td>cdr<br/>Rest<br/>Tail<br/></td><td>Takes a compound word on the stack and returns the rest of the word (as a compound word), minus the first word.</td></tr>
<tr><td>ceil<br/></td><td></td></tr>
<tr><td>centerHead<br/></td><td></td></tr>
<tr><td>changeAnimationState<br/></td><td></td></tr>
<tr><td>changeTargetClassToClosestBlueBox<br/></td><td></td></tr>
<tr><td>changeToCounterTable<br/></td><td></td></tr>
<tr><td>changeToHeight<br/></td><td></td></tr>
<tr><td>changeToHeight0<br/></td><td></td></tr>
<tr><td>changeToHeight1<br/></td><td></td></tr>
<tr><td>changeToHeight2<br/></td><td></td></tr>
<tr><td>changeToHeight3<br/></td><td></td></tr>
<tr><td>changeToPantryTable<br/></td><td></td></tr>
<tr><td>checkAndCountGrasp<br/></td><td></td></tr>
<tr><td>checkGrasp<br/></td><td></td></tr>
<tr><td>checkIfJammed<br/></td><td></td></tr>
<tr><td>( oP cgTimeParam pi 2.000000e+00 times times sin cgRadius times cP oP cgTimeParam pi 2.000000e+00 times times cos cgRadius times cP oP 0.000000e+00 cP cgAnchor gaitAnchoredTranslation /*
  cgAnchor eePosePX plus cgAnchor swap setEEPosePX moveEeToPoseWord
*/ cgTimeParam cgDeltaT plus &quot;cgTimeParam&quot; store )<br/></td><td></td></tr>
<tr><td>( circleGaitSetRing oP 1 cP oP circleGait cgWaitT waitForSeconds cP whileCollapsed )<br/></td><td></td></tr>
<tr><td>( circleGaitSetRing 2.000000e-01 &quot;cgWaitT&quot; store oP circleGait cgWaitT waitForSeconds cP 33 replicateWord cgAnchor moveEeToPoseWord )<br/></td><td></td></tr>
<tr><td>( 5.000000e-02 &quot;cgThisWaitFactor&quot; store circleGaitSetRing 5.000000e-02 &quot;cgRadius&quot; store 1.000000e+00 cgThisWaitFactor times &quot;cgWaitT&quot; store oP circleGait cgWaitT waitForSeconds cP 33 replicateWord 1.000000e-01 &quot;cgRadius&quot; store 2.000000e+00 cgThisWaitFactor times &quot;cgWaitT&quot; store oP circleGait cgWaitT waitForSeconds cP 33 replicateWord 1.500000e-01 &quot;cgRadius&quot; store 3.000000e+00 cgThisWaitFactor times &quot;cgWaitT&quot; store oP circleGait cgWaitT waitForSeconds cP 33 replicateWord cgAnchor moveEeToPoseWord )<br/></td><td></td></tr>
<tr><td>( &quot;cgWaitT&quot; store &quot;cgDeltaT&quot; store &quot;cgTimeParam&quot; store &quot;cgRadius&quot; store &quot;cgAnchor&quot; store )<br/></td><td></td></tr>
<tr><td>( currentPose 1.000000e-01 0.000000e+00 3.030300e-02 1.000000e-01 circleGaitSet )<br/></td><td></td></tr>
<tr><td>classRangeMapFromRegister1<br/></td><td></td></tr>
<tr><td>clearAllRangeMaps<br/></td><td></td></tr>
<tr><td>clearBlueBoxMemories<br/></td><td></td></tr>
<tr><td>clearStack<br/>clearCallStack<br/></td><td>Clear the call stack.</td></tr>
<tr><td>clearClass3dGrasps<br/></td><td></td></tr>
<tr><td>clearClassLabels<br/></td><td></td></tr>
<tr><td>clearConsole<br/></td><td>Prints a lot of newlines to the console to clear it.</td></tr>
<tr><td>clearData<br/>clearDataStack<br/></td><td>Clear the data stack.</td></tr>
<tr><td>clearData<br/>clearDataStack<br/></td><td>Clear the data stack.</td></tr>
<tr><td>clearIkMap<br/></td><td>Reset the IK Map so that every cell is good.</td></tr>
<tr><td>clearMapForPatrol<br/></td><td></td></tr>
<tr><td>clearStack<br/>clearCallStack<br/></td><td>Clear the call stack.</td></tr>
<tr><td>clearStackIntoMappingPatrol<br/></td><td></td></tr>
<tr><td>clearStacks<br/></td><td>Clear the call stack and the data stack.</td></tr>
<tr><td>clearStreamBuffers<br/></td><td></td></tr>
<tr><td>closeGripper<br/></td><td></td></tr>
<tr><td>cmp<br/></td><td>Takes two words and returns 0 if they are equal, -1 if they are less than, and 1 if they are greater than.  Works on integers, doubles and strings.</td></tr>
<tr><td>collapseStack<br/></td><td></td></tr>
<tr><td>collectMoreCrops<br/></td><td></td></tr>
<tr><td>collectMoreStreams<br/></td><td></td></tr>
<tr><td>comeToHover<br/></td><td></td></tr>
<tr><td>comeToHoverA<br/></td><td></td></tr>
<tr><td>comeToStop<br/></td><td></td></tr>
<tr><td>comeToStopA<br/></td><td></td></tr>
<tr><td>commandOtherArm<br/></td><td>Send a command to the other arm.  It takes a string on the stack and sends it as a program to be executed on the other arm.</td></tr>
<tr><td>continueHeightLearning<br/></td><td></td></tr>
<tr><td>continuousServo<br/></td><td></td></tr>
<tr><td>continuousServoA<br/></td><td></td></tr>
<tr><td>continuousServoL<br/></td><td></td></tr>
<tr><td>continuousServoPrep<br/></td><td></td></tr>
<tr><td>copyIkMapToHeightIdx<br/></td><td>Copy the ik map to the height index.</td></tr>
<tr><td>cornellMugsOnTables<br/></td><td></td></tr>
<tr><td>cos<br/></td><td></td></tr>
<tr><td>countGrasp<br/></td><td></td></tr>
<tr><td>createArmPose<br/></td><td></td></tr>
<tr><td>createCachedClassifierFromClassLabels<br/></td><td></td></tr>
<tr><td>createEEPose<br/></td><td></td></tr>
<tr><td>cruisingSpeed<br/></td><td></td></tr>
<tr><td>currentBackgroundMap<br/></td><td>Pushes the current background map on the stack.</td></tr>
<tr><td>currentIKBoundaryMode<br/></td><td></td></tr>
<tr><td>currentIKFastMode<br/></td><td></td></tr>
<tr><td>currentIKMode<br/></td><td></td></tr>
<tr><td>currentIKModeString<br/></td><td></td></tr>
<tr><td>currentJointWord<br/></td><td></td></tr>
<tr><td>currentObservedMap<br/></td><td>Pushes the current observed map on the stack.</td></tr>
<tr><td>currentPose<br/></td><td></td></tr>
<tr><td>currentPoseToWord<br/></td><td></td></tr>
<tr><td>currentPredictedMap<br/></td><td>Pushes the current predicted map on the stack.</td></tr>
<tr><td>currentScene<br/></td><td>Pushes the current scene on the stack.</td></tr>
<tr><td>currentSceneFixationMode<br/></td><td></td></tr>
<tr><td>currentTableZ<br/></td><td></td></tr>
<tr><td>( tableSwapToBlocks catScan5LoadPlayBg /*
  1 setCurrentIKBoundaryMode
  */ &quot;&gt;&gt;&gt;&gt; clearing workspace scene &lt;&lt;&lt;&lt;&quot; print 0 &quot;cw_clearWorkspace_counter&quot; store 1 &quot;cw_clearWorkspace_rescan&quot; store oP cw_clearWorkspace_counter cw_clearWorkspace_max langle cP oP dup moveEeToPoseWord waitUntilAtCurrentPosition 1 changeToHeight sceneClearPredictedObjects &quot;Attablet &quot; cw_clearWorkspace_counter &quot; out of &quot; cw_clearWorkspace_max plus plus plus print dup /* copy the workspace pose */ cw_workspaceIsClear &quot;cw_clearWorkspace_space_clear&quot; store cw_clearWorkspace_space_clear oP &quot;Great! Workspace clear, moving on.&quot; print cw_clearWorkspace_max &quot;cw_clearWorkspace_counter&quot; store 0 &quot;cw_clearWorkspace_rescan&quot; store cP oP &quot;Workspace not clear, attableting to flick object.&quot; print /* should already be at the right place thanks to cw_workspaceIsClear */ /* 
      tableSpiralServoToAnonymousObject 
      */ waitUntilAtCurrentPosition cw_tri_flick cw_clearWorkspace_counter 1 plus &quot;cw_clearWorkspace_counter&quot; store cP ifte cP whileCollapsed /* 

  cw_clearWorkspace_rescan (
    &quot;Sadly, we timed out and the workspace is not clear. Updating the play workspace background map.&quot; print
    catScan5UpdatePlayBg
  ) ift

  */ /* regardless of the outcome of the scan, replace the play workspace */ &quot;catScan5PlayBg&quot; &quot;_&quot; leftOrRightArm plus plus sceneSaveObservedMap tableRestoreFromBlocks print )<br/></td><td></td></tr>
<tr><td>0<br/></td><td></td></tr>
<tr><td>( 1 waitSetCurrentWaitMode halfImpulse moveEeToPoseWord 1.000000e-02 setGridSize oP localXUp localZUp endStackCollapseNoop cP 20 replicateWord waitUntilAtCurrentPosition comeToStop pressUntilEffortInit 3.000000e-02 setSpeed pressUntilEffortCombo tenthImpulse 1.000000e-02 setGridSize oP localXDown endStackCollapseNoop cP 40 replicateWord oP closeGripper waitUntilGripperNotMoving isGripperGripping not oP openGripper waitUntilGripperNotMoving cP ift cP 3 replicateWord waitUntilAtCurrentPosition liftArm waitUntilAtCurrentPosition currentPose &quot;cw_flick_returnpoint&quot; store isGripperGripping oP tenthImpulse outputPileWorkspace moveEeToPoseWord 0 changeToHeight waitUntilAtCurrentPosition comeToStop pressUntilEffortInit 5.000000e-02 setSpeed pressUntilEffort openGripper waitUntilGripperNotMoving liftArm waitUntilAtCurrentPosition tenthImpulse cw_flick_returnpoint moveEeToPoseWord waitUntilAtCurrentPosition cP oP openGripper waitUntilGripperNotMoving cP ifte 0 waitSetCurrentWaitMode )<br/></td><td></td></tr>
<tr><td>( tableSpiralServoToAnonymousObject shiftIntoGraspGear1 )<br/></td><td></td></tr>
<tr><td>( pointToClearanceMap aboutFace currentPose cw_clearWorkspace )<br/></td><td></td></tr>
<tr><td>( oB noop 1 2 3 4 5 6 print print print print print print cB &quot;test1&quot; store oB noop a b c d e f print print print print print print cB &quot;test2&quot; store test1 &quot;test1&quot; store test2 &quot;test2&quot; store oP oB 1 2 3 4 5 6 print print print print print print cB oB a b c d e f print print print print print print cB cP slide oP swap slip 1 sP cP oB sB oB sB 1 2 3 4 5 6 print print print print print print cB oB sB a b c d e f print print print print print print cB cB 0 &quot;cc&quot; store oP cc 1 plus dup &quot;cc&quot; store 36 langle cP oP slip cP whileCollapsed cc print )<br/></td><td></td></tr>
<tr><td>( cw_servo_for_flick currentPose dup moveEeToPoseWord 1.000000e-02 setGridSize oP yUp cP 4 replicateWord currentPose cw_flick dup cw_flick dup moveEeToPoseWord 1.000000e-02 setGridSize oP yDown cP 4 replicateWord currentPose cw_flick pop )<br/></td><td></td></tr>
<tr><td>( cw_viewIsClear_squareMeterDiscrepancyThresh sceneCellWidth sceneCellWidth times divide &quot;cw_viewIsClear_numCellThresh&quot; store &quot;cw_viewIsClear_numCellThresh is set to &quot; cw_viewIsClear_numCellThresh plus print /* warning, still hardcoded for playworkspace */ /* if you are in blocks, you will end up back in blocks. if not you will get whatever you had. */ tableRestoreFromBlocks tableSwapToBlocks setMovementStateToMoving comeToStop sceneClearObservedMap sceneClearPredictedObjects clearClassLabels initializeAndFocusOnTempClass /* based on tableRecaptureServoSpiral */ sceneClearPredictedObjects sceneClearObservedMap catScan5PlayTakeScene tableUpdateMaps &quot;cw_viewIsClear dT nCT: &quot; cw_viewIsClear_discrepancyThresh &quot; &quot; cw_viewIsClear_numCellThresh plus plus plus print cw_viewIsClear_discrepancyThresh sceneCountDiscrepantCells &quot;cw_viewIsClear_numDiscrepantCells&quot; store cw_viewIsClear_numDiscrepantCells &quot; cells are discrepant&quot; plus print tableCaptureCore tableUpdateMaps tableServoToFocusedSceneObject /* end based on */ /*
  scenePushNumSceneObjects 0 = 
*/ cw_viewIsClear_numDiscrepantCells cw_viewIsClear_numCellThresh rangle oP &quot;NO, view is NOT CLEAR&quot; print 0 cP oP &quot;YES, view is CLEAR&quot; print 1 sceneClearPredictedObjects cP ifte tableRestoreFromBlocks )<br/></td><td></td></tr>
<tr><td>5.000000e-01<br/></td><td></td></tr>
<tr><td>( setMovementStateToMoving comeToStop visionCycleNoClassify numBlueBoxes 0 equals 1 0 ifte )<br/></td><td></td></tr>
<tr><td>4.000000e-04<br/></td><td></td></tr>
<tr><td>( /* warning, still hardcoded for playworkspace */ moveEeToPoseWord waitUntilAtCurrentPosition 1 changeToHeight cw_viewIsClear )<br/></td><td></td></tr>
<tr><td>darkServo<br/></td><td></td></tr>
<tr><td>darkServoA<br/></td><td></td></tr>
<tr><td>darkServoB<br/></td><td></td></tr>
<tr><td>dataDirectory<br/></td><td></td></tr>
<tr><td>dateString<br/></td><td></td></tr>
<tr><td>deactivateSensorStreaming<br/></td><td>Stop streaming data.</td></tr>
<tr><td>decMx<br/></td><td></td></tr>
<tr><td>decMy<br/></td><td></td></tr>
<tr><td>decrementCamera<br/></td><td></td></tr>
<tr><td>decrementCurrentCornellTable<br/></td><td></td></tr>
<tr><td>decrementGraspGear<br/></td><td></td></tr>
<tr><td>decrementTargetClass<br/></td><td></td></tr>
<tr><td>decrementTargetInstanceSprite<br/></td><td></td></tr>
<tr><td>decrementTargetMasterSprite<br/></td><td></td></tr>
<tr><td>define<br/></td><td>Store a new compound word with specified body, description, and name.  Usage:  &lt;compound word&gt; &lt; help text &gt; &lt; name &gt; define. </td></tr>
<tr><td>deliverObject<br/></td><td></td></tr>
<tr><td>deliverTargetBoxMemory<br/></td><td></td></tr>
<tr><td>deliverTargetObject<br/></td><td></td></tr>
<tr><td>( /* demos relative transforms */ /* this prints current pose */ 0 0 0 0 1.000000e+00 0 0 createEEPose currentPose 0 0 0 0 1.000000e+00 0 0 createEEPose eePoseGetPoseRelativeTo eePoseApplyRelativePoseTo print currentPose print )<br/></td><td></td></tr>
<tr><td>density<br/></td><td></td></tr>
<tr><td>densityA<br/></td><td></td></tr>
<tr><td>departureSpeed<br/></td><td></td></tr>
<tr><td>deref<br/></td><td>Takes a symbol word argument from the data stack and pushes its current value back onto the data stack.  Usage:  &lt; symbol word &gt; deref -&gt; &lt; value &gt; </td></tr>
<tr><td>derefToTruth<br/></td><td>Takes a symbol word argument from the data stack and pushes its current value back onto the data stack.  Usage:  &lt; symbol word &gt; deref -&gt; &lt; value &gt; </td></tr>
<tr><td>destroyObjectInEndEffector<br/></td><td></td></tr>
<tr><td>destroyTargetInstanceSprite<br/></td><td></td></tr>
<tr><td>detectionSpin<br/></td><td></td></tr>
<tr><td>diagnosticRelativePose<br/></td><td></td></tr>
<tr><td>digitalIOCommand<br/></td><td></td></tr>
<tr><td>disableDiskStreaming<br/></td><td></td></tr>
<tr><td>disableRobot<br/></td><td></td></tr>
<tr><td>dislodgeEndEffectorFromTable<br/></td><td></td></tr>
<tr><td>divide<br/>/<br/></td><td>Divide two numeric arguments.</td></tr>
<tr><td>( &quot;doUntilAtCurrentPositionTemp&quot; store oP isAtCurrentPosition not cP oP doUntilAtCurrentPositionTemp endStackCollapseNoop cP whileCollapsed )<br/></td><td></td></tr>
<tr><td>downsampleIrScan<br/></td><td></td></tr>
<tr><td>drand48<br/></td><td></td></tr>
<tr><td>drawMapRegisters<br/></td><td></td></tr>
<tr><td>dsr<br/></td><td></td></tr>
<tr><td>ducksInARow<br/></td><td></td></tr>
<tr><td>dup<br/></td><td></td></tr>
<tr><td>eePoseApplyRelativePoseTo<br/></td><td></td></tr>
<tr><td>eePoseGetPoseRelativeTo<br/></td><td></td></tr>
<tr><td>eePosePX<br/></td><td></td></tr>
<tr><td>eePosePY<br/></td><td></td></tr>
<tr><td>eePosePZ<br/></td><td></td></tr>
<tr><td>eePoseQW<br/></td><td></td></tr>
<tr><td>eePoseQX<br/></td><td></td></tr>
<tr><td>eePoseQY<br/></td><td></td></tr>
<tr><td>eePoseQZ<br/></td><td></td></tr>
<tr><td>eePoseRPYOnQ<br/></td><td></td></tr>
<tr><td>eePoseToArmPose<br/></td><td></td></tr>
<tr><td>eeRange<br/></td><td></td></tr>
<tr><td>eeRangeMaxValue<br/></td><td></td></tr>
<tr><td>effortThresh<br/></td><td></td></tr>
<tr><td>eighthTurn<br/></td><td></td></tr>
<tr><td>einSoftwareVersion<br/></td><td></td></tr>
<tr><td>enableDiskStreaming<br/></td><td></td></tr>
<tr><td>enableRobot<br/></td><td></td></tr>
<tr><td>endArgs<br/></td><td></td></tr>
<tr><td>endStackCollapse<br/></td><td></td></tr>
<tr><td>endStackCollapseNoop<br/></td><td></td></tr>
<tr><td>equals<br/>=<br/></td><td>Takes two words and returns 1 if they are equal (by value) and 0 otherwise.</td></tr>
<tr><td>eval<br/></td><td>Takes a string from the data stack; evaluates the string as a back program.  Usage:  &lt; string &gt; eval -&gt; whatever the program does</td></tr>
<tr><td>exec<br/></td><td></td></tr>
<tr><td>executePreparedGrasp<br/></td><td></td></tr>
<tr><td>executeStack<br/>;<br/></td><td></td></tr>
<tr><td>executionModeInstant<br/></td><td></td></tr>
<tr><td>executionModeStep<br/></td><td></td></tr>
<tr><td>exp<br/></td><td></td></tr>
<tr><td>expand<br/></td><td></td></tr>
<tr><td>exportDoc<br/></td><td>Export words to an html file which is displayed on the website.</td></tr>
<tr><td>exportWords<br/></td><td>Export words to a text file for documentation purposes.</td></tr>
<tr><td>faceAnimationFindEmotions<br/></td><td></td></tr>
<tr><td>faceAnimationGetMode<br/></td><td></td></tr>
<tr><td>faceAnimationGetRate<br/></td><td></td></tr>
<tr><td>faceAnimationLoadAllEmotions<br/></td><td></td></tr>
<tr><td>faceAnimationLoadEmotion<br/></td><td></td></tr>
<tr><td>faceAnimationSetEmotionValue<br/></td><td></td></tr>
<tr><td>faceAnimationSetMode<br/></td><td></td></tr>
<tr><td>faceAnimationSetRate<br/></td><td></td></tr>
<tr><td>fakeBBWidth<br/></td><td></td></tr>
<tr><td>fasterRasterScanningSpeed<br/></td><td></td></tr>
<tr><td>fetch<br/></td><td></td></tr>
<tr><td>fileClose<br/></td><td>Close the file.  If you forget to do this, it will be closed automatically when the word is deallocated.</td></tr>
<tr><td>fileOpenInput<br/></td><td>Open an input file for reading; takes a file name as an argument.</td></tr>
<tr><td>fileOpenOutput<br/></td><td>Open an output file for writing; takes a file name as an argument.</td></tr>
<tr><td>fileReadAll<br/></td><td>Read the contents of the file into a string and push it on the data stack.</td></tr>
<tr><td>fileReadLine<br/></td><td>Read one line from the file into a string and leave it on the data stack.</td></tr>
<tr><td>fileWrite<br/></td><td>Write a string to the file.  Takes a file and a word, which is written.  if it is a string, writes it as-is.  Otherwise writes it with repr.</td></tr>
<tr><td>fileWriteLine<br/></td><td>Write a line to the file.  Takes a file and a word, which is written.  if it is a string, writes it as-is.  Otherwise writes it with repr.</td></tr>
<tr><td>fillClearanceMap<br/></td><td></td></tr>
<tr><td>fillIkMap<br/></td><td>Fill the IK map for the current range starting at the i and j and height on the stack.</td></tr>
<tr><td>fillIkMapAtCurrentHeight<br/></td><td>Fill the IK map using data at the current EE height.  We run at height 2 usually.</td></tr>
<tr><td>fillIkMapAtHeights<br/></td><td>Fill the IK map at different heights.</td></tr>
<tr><td>fillIkMapFromCachedHeightIdx<br/></td><td>Fill the IK map by taking the height idx from the cache.</td></tr>
<tr><td>fillIkMapFromCachedHeights<br/></td><td>Fill the IK map by taking the and of the result at all the different heights.</td></tr>
<tr><td>filterBoxMemories<br/></td><td></td></tr>
<tr><td>findBestOfFourGraspsUsingMemory<br/></td><td></td></tr>
<tr><td>fixCameraLighting<br/></td><td>Fix the camera lighting.  Usage:  &lt;exposure&gt; &lt;gain&gt; &lt;red&gt; &lt;green&gt; &lt;blue&gt; fixCameraLighting.  You can see the current values with cameraGain, cameraExposure, cameraWhiteBalanceRed, cameraWhiteBlanaceGreen, cameraWhiteBalanceBlue.</td></tr>
<tr><td>fixCameraLightingNoUpdate<br/></td><td></td></tr>
<tr><td>fixCameraLightingToAutomaticParameters<br/></td><td>Fix the camera lighting using autogain.  The camera parameters will first adjust automatically, then ein will fix them to the automatically adjusted values.</td></tr>
<tr><td>fixCameraLightingToObservedValues<br/></td><td></td></tr>
<tr><td>floor<br/></td><td></td></tr>
<tr><td>focusedCamera<br/></td><td></td></tr>
<tr><td>focusedClassLabel<br/></td><td></td></tr>
<tr><td>focusedGraspLearning<br/></td><td></td></tr>
<tr><td>focusedGraspLearningA<br/></td><td></td></tr>
<tr><td>followPath<br/></td><td></td></tr>
<tr><td>fullImpulse<br/></td><td></td></tr>
<tr><td>fullRender<br/></td><td></td></tr>
<tr><td>gaitAnchoredTranslation<br/></td><td></td></tr>
<tr><td>( cameraWristConfig 80 10 1124 1024 2048 fixCameraLighting /*
  ikModeIkFast 0 setCurrentIKFastMode
*/ )<br/></td><td></td></tr>
<tr><td>( /*
    -0.02 0.02 0.03515 0 0 0.7071 0.7071 createEEPose setHandEndEffectorOffset
    0.0 0.0 0.0 0 0 0 1.0 createEEPose setHandEndEffectorOffset
*/ 0.000000e+00 0.000000e+00 0.000000e+00 0 0 0 1.000000e+00 createEEPose setHandEndEffectorOffset )<br/></td><td></td></tr>
<tr><td>geq<br/>&gt;=<br/></td><td>Takes two words and returns 1 if they are greater than or equal to (by value) and 0 otherwise.</td></tr>
<tr><td>get<br/></td><td>Takes a compound word on the stack and an int.  Returns the ith entry of the compound word.  Uses zero based indexing.</td></tr>
<tr><td>getSpeed<br/></td><td></td></tr>
<tr><td>goClassifyBlueBoxes<br/></td><td></td></tr>
<tr><td>goFindBlueBoxes<br/></td><td></td></tr>
<tr><td>( assumeBeeHome /*
leftOrRightArm &quot;right&quot; =
( 
 0.607890 -0.388495 0.098883 0.000585 0.999998 0.000919 0.001453 createEEPose moveEeToPoseWord
)
( 
leftOrRightArm &quot;left&quot; = 
(
 assumeBeeHome
)
 ( &quot;Neither left or right arm.&quot; leftOrRighArm pauseStackExecution ) 
ifte
)
ifte
*/ 1 changeToHeight waitUntilAtCurrentPosition shoreUp ) &quot;Go to the home position, wait until at current position, and put the joints in a good state.&quot; setHelp<br/></td><td>Go to the home position, wait until at current position, and put the joints in a good state.</td></tr>
<tr><td>goToLastPickPose<br/></td><td></td></tr>
<tr><td>goToPrePickPose<br/></td><td></td></tr>
<tr><td>gradientServo<br/></td><td></td></tr>
<tr><td>gradientServoA<br/></td><td></td></tr>
<tr><td>gradientServoB<br/></td><td></td></tr>
<tr><td>gradientServoHardMaxIterations<br/></td><td></td></tr>
<tr><td>gradientServoIfBlueBoxes<br/></td><td></td></tr>
<tr><td>gradientServoMode<br/></td><td></td></tr>
<tr><td>gradientServoPrep<br/></td><td></td></tr>
<tr><td>gradientServoSoftMaxIterations<br/></td><td></td></tr>
<tr><td>gradientServoTakeClosest<br/></td><td></td></tr>
<tr><td>graspBackoffDistance<br/></td><td></td></tr>
<tr><td>gridSize<br/></td><td></td></tr>
<tr><td>gripperMaskThresh<br/></td><td></td></tr>
<tr><td>guiCustom1<br/></td><td></td></tr>
<tr><td>guiHideAll<br/></td><td></td></tr>
<tr><td>guiShowAll<br/></td><td></td></tr>
<tr><td>halfImpulse<br/></td><td></td></tr>
<tr><td>handCameraOffset<br/></td><td></td></tr>
<tr><td>handEndEffectorOffset<br/></td><td></td></tr>
<tr><td>happyFace<br/></td><td></td></tr>
<tr><td>help<br/></td><td>Return help text for a word.  Takes a compound word as an argument with a single word inside.  Usage:  ( word ) help.</td></tr>
<tr><td>histgramAllExamplesFocusedClass<br/></td><td></td></tr>
<tr><td>histogramDetection<br/></td><td></td></tr>
<tr><td>histogramDetectionIfBlueBoxes<br/></td><td></td></tr>
<tr><td>histogramDetectionInit<br/></td><td></td></tr>
<tr><td>histogramDetectionNormalize<br/></td><td></td></tr>
<tr><td>histogramDetectionReport<br/></td><td></td></tr>
<tr><td>histogramExampleAsFocusedClass<br/></td><td></td></tr>
<tr><td>hover<br/></td><td></td></tr>
<tr><td>hoverA<br/></td><td></td></tr>
<tr><td>hoverThreshold<br/></td><td></td></tr>
<tr><td>hundredthImpulse<br/></td><td></td></tr>
<tr><td>( cgRadiusOuter cgRadiusInner minus &quot;cgRadiusOuterDeed&quot; store cgRadiusOuterDeed cgRadiusInner divide &quot;cgTimeRatio&quot; store cgDistance &quot;cgRadiusInnerDeed&quot; store oP cgTimeParam pi 2.000000e+00 times times sin cgRadiusOuterDeed times cgTimeParam cgTimeRatio times pi 2.000000e+00 times times sin -1.000000e+00 times cgRadiusInnerDeed times plus cP oP cgTimeParam pi 2.000000e+00 times times cos cgRadiusOuterDeed times cgTimeParam cgTimeRatio times pi 2.000000e+00 times times cos cgRadiusInnerDeed times plus cP oP 0.000000e+00 cP cgAnchor gaitAnchoredTranslation /*
  cgAnchor eePosePX plus cgAnchor swap setEEPosePX moveEeToPoseWord
*/ cgTimeParam cgDeltaT plus &quot;cgTimeParam&quot; store )<br/></td><td></td></tr>
<tr><td>( &quot;cgWaitT&quot; store &quot;cgDeltaT&quot; store &quot;cgTimeParam&quot; store &quot;cgRadiusOuter&quot; store &quot;cgRadiusInner&quot; store &quot;cgDistance&quot; store &quot;cgAnchor&quot; store )<br/></td><td></td></tr>
<tr><td>( currentPose 1.000000e-01 6.000000e-02 1.000000e-01 0.000000e+00 3.030300e-02 1.000000e-01 hypotrochoidGaitSet )<br/></td><td></td></tr>
<tr><td>( hypotrochoidGaitSetStar oP 1 cP oP hypotrochoidGait cgWaitT waitForSeconds cP whileCollapsed )<br/></td><td></td></tr>
<tr><td>iRCalibrationSpeed<br/></td><td></td></tr>
<tr><td>idler<br/></td><td></td></tr>
<tr><td>ifGrasp<br/></td><td></td></tr>
<tr><td>ifNoGrasp<br/></td><td></td></tr>
<tr><td>ift<br/></td><td>Takes two words on the stack, executes the second word if the first word is true.  For example, &quot; ( &quot;hello&quot; print ) 1 ift&quot; will print hello, while &quot; ( &quot;hello&quot; print ) 0 ift&quot; will not do it.</td></tr>
<tr><td>ifte<br/></td><td>If then else takes two compound words and a condition and does the first one if the condition is true and the second if it is false.   Usage: 0 ( &quot;condition was true&quot; print ) ( &quot;condition was false&quot; print )   ifte</td></tr>
<tr><td>ikMapEndHeight<br/></td><td></td></tr>
<tr><td>ikMapStartHeight<br/></td><td></td></tr>
<tr><td>ikModeIkFast<br/></td><td></td></tr>
<tr><td>ikModeIkFastDebug<br/></td><td></td></tr>
<tr><td>ikModeService<br/></td><td></td></tr>
<tr><td>imageStreamBufferLoadCurrent<br/></td><td></td></tr>
<tr><td>import<br/></td><td></td></tr>
<tr><td>inc<br/></td><td>Adds one to its argument.  1 inc produces 2.</td></tr>
<tr><td>incMx<br/></td><td></td></tr>
<tr><td>incMy<br/></td><td></td></tr>
<tr><td>incrementCamera<br/></td><td></td></tr>
<tr><td>incrementCurrentCornellTable<br/></td><td></td></tr>
<tr><td>incrementGraspGear<br/></td><td></td></tr>
<tr><td>incrementImageStreamBuffer<br/></td><td>Increments the current location in the image stream buffer.  Loads it into memory and kicks it out when done.</td></tr>
<tr><td>incrementImageStreamBufferNoLoad<br/></td><td>Increments the current location in the image stream buffer.  Does not load the image into memory, but kicks it out when done.</td></tr>
<tr><td>incrementImageStreamBufferNoLoadNoKick<br/></td><td>Increments the current location in the image stream buffer.  Does not load the image into memory or kick it out when done.</td></tr>
<tr><td>incrementTargetClass<br/></td><td></td></tr>
<tr><td>incrementTargetInstanceSprite<br/></td><td></td></tr>
<tr><td>incrementTargetMasterSprite<br/></td><td></td></tr>
<tr><td>initCumulativeGripperMask<br/></td><td></td></tr>
<tr><td>initDepthScan<br/></td><td></td></tr>
<tr><td>initializeAndFocusOnNewClass<br/></td><td>Initialize a new class with a default date-based name and focus on it.  It will be created in the file system with default values and focused on.</td></tr>
<tr><td>initializeAndFocusOnTempClass<br/></td><td></td></tr>
<tr><td>initializeConfig<br/></td><td></td></tr>
<tr><td>initializeMap<br/></td><td></td></tr>
<tr><td>eePose: { px:-3.4999999999999998e-01, py:5.6874999999999998e-01,
    pz:2.0000000000000001e-01, qw:-2.8010000000000001e-03,
    qx:-1.5540000000000000e-03, qy:9.9999000000000005e-01,
    qz:3.0990000000000002e-03 }
<br/></td><td></td></tr>
<tr><td>integrateImageStreamBufferCrops<br/></td><td></td></tr>
<tr><td>integrateImageStreamBufferServoImages<br/></td><td></td></tr>
<tr><td>integrateRangeStreamBuffer<br/></td><td></td></tr>
<tr><td>interlaceBottom<br/></td><td></td></tr>
<tr><td>interlaceTop<br/></td><td></td></tr>
<tr><td>interpolatePath<br/></td><td></td></tr>
<tr><td>irFixPick<br/></td><td></td></tr>
<tr><td>isAtCurrentPosition<br/></td><td></td></tr>
<tr><td>isGripperGripping<br/></td><td></td></tr>
<tr><td>isGripperMoving<br/></td><td></td></tr>
<tr><td>iterateIsbAndAccumulateHeightImages<br/></td><td></td></tr>
<tr><td>sum<br/>join<br/></td><td>Pops a compound word; sums the entries; pushes the result.  Usage:  ( 1 1 1 ) sum -&gt; 3.</td></tr>
<tr><td>langle<br/>&lt;<br/></td><td>Takes two words and returns 1 if they are less than (by value) and 0 otherwise.  1 3 &lt; returns true, and 3 1 &lt; returns false.</td></tr>
<tr><td>leftOrRightArm<br/></td><td></td></tr>
<tr><td>-1.000000e-02<br/></td><td></td></tr>
<tr><td>1.200000e-02<br/></td><td></td></tr>
<tr><td>0.000000e+00<br/></td><td></td></tr>
<tr><td>50<br/></td><td></td></tr>
<tr><td>2.400000e-02<br/></td><td></td></tr>
<tr><td>4.000000e-05<br/></td><td></td></tr>
<tr><td>4.000000e+00<br/></td><td></td></tr>
<tr><td>-3.200000e+01<br/></td><td></td></tr>
<tr><td>2.000000e+00<br/></td><td></td></tr>
<tr><td>leq<br/>&lt;=<br/></td><td>Takes two words and returns 1 if they are less than or equal to (by value) and 0 otherwise.</td></tr>
<tr><td>( 1.000000e-02 setGridSize oP zUp cP 15 replicateWord comeToStop )<br/></td><td></td></tr>
<tr><td>lightsOff<br/></td><td></td></tr>
<tr><td>lightsOn<br/></td><td></td></tr>
<tr><td>loadCalibration<br/></td><td></td></tr>
<tr><td>loadCalibrationRaw<br/></td><td></td></tr>
<tr><td>loadConfig<br/></td><td></td></tr>
<tr><td>loadDefaultCalibration<br/></td><td></td></tr>
<tr><td>loadGripperMask<br/></td><td></td></tr>
<tr><td>loadIkMap<br/></td><td></td></tr>
<tr><td>loadIkMapAtHeight<br/></td><td></td></tr>
<tr><td>loadMarginalGraspMemory<br/></td><td></td></tr>
<tr><td>loadMarginalHeightMemory<br/></td><td></td></tr>
<tr><td>loadPriorGraspMemoryAnalytic<br/></td><td></td></tr>
<tr><td>loadPriorGraspMemoryUniform<br/></td><td></td></tr>
<tr><td>loadPriorHeightMemoryAnalytic<br/></td><td></td></tr>
<tr><td>loadPriorHeightMemoryUniform<br/></td><td></td></tr>
<tr><td>loadSampledGraspMemory<br/></td><td></td></tr>
<tr><td>loadSampledHeightMemory<br/></td><td></td></tr>
<tr><td>loadTargetClassRangeMapIntoRegister1<br/></td><td></td></tr>
<tr><td>localXDown<br/></td><td></td></tr>
<tr><td>localXUp<br/></td><td></td></tr>
<tr><td>localYDown<br/></td><td></td></tr>
<tr><td>localYUp<br/></td><td></td></tr>
<tr><td>localZDown<br/></td><td></td></tr>
<tr><td>localZUp<br/></td><td></td></tr>
<tr><td>lock3dGraspBase<br/></td><td></td></tr>
<tr><td>lockTargetIfBlueBoxes<br/></td><td></td></tr>
<tr><td>2.000000e-01<br/></td><td></td></tr>
<tr><td>( cameraGetIdxMagX )<br/></td><td></td></tr>
<tr><td>0.000000e+00<br/></td><td></td></tr>
<tr><td>( cameraSetIdxMagX )<br/></td><td></td></tr>
<tr><td>10<br/></td><td></td></tr>
<tr><td>map<br/></td><td></td></tr>
<tr><td>mapAndPick<br/></td><td></td></tr>
<tr><td>mapAndPickL<br/></td><td></td></tr>
<tr><td>mapClosestBlueBox<br/></td><td></td></tr>
<tr><td>mapEmptySpace<br/></td><td></td></tr>
<tr><td>mapFreeSpacePixelSkirt<br/></td><td></td></tr>
<tr><td>mapGrayBoxPixelSkirtCols<br/></td><td></td></tr>
<tr><td>mapGrayBoxPixelSkirtRows<br/></td><td></td></tr>
<tr><td>mapGrayBoxPixelWaistCols<br/></td><td></td></tr>
<tr><td>mapGrayBoxPixelWaistRows<br/></td><td></td></tr>
<tr><td>mapLocal<br/></td><td></td></tr>
<tr><td>mapSearchFenceXMax<br/></td><td></td></tr>
<tr><td>mapSearchFenceXMin<br/></td><td></td></tr>
<tr><td>mapSearchFenceYMax<br/></td><td></td></tr>
<tr><td>mapSearchFenceYMin<br/></td><td></td></tr>
<tr><td>mapServo<br/></td><td></td></tr>
<tr><td>mapWaypoints<br/></td><td>Maps objects at locations specified by EePoseWords underneath.</td></tr>
<tr><td>mappingPatrol<br/></td><td></td></tr>
<tr><td>mappingPatrolA<br/></td><td></td></tr>
<tr><td>mappingServoTimeout<br/></td><td></td></tr>
<tr><td>markMapAsCompleted<br/></td><td></td></tr>
<tr><td>max<br/></td><td></td></tr>
<tr><td>measureTime<br/></td><td></td></tr>
<tr><td>measureTimeA<br/></td><td></td></tr>
<tr><td>measureTimeEnd<br/></td><td></td></tr>
<tr><td>measureTimeInit<br/></td><td></td></tr>
<tr><td>measureTimeInitSinceStart<br/></td><td></td></tr>
<tr><td>measureTimeSetPeriod<br/></td><td></td></tr>
<tr><td>measureTimeSinceStart<br/></td><td></td></tr>
<tr><td>measureTimeStart<br/></td><td></td></tr>
<tr><td>min<br/></td><td></td></tr>
<tr><td>minus<br/>-<br/></td><td>Takes two numbers and subtracts them.  `2 1 - ` produces 1.  1 2 - produces -1.</td></tr>
<tr><td>mkdir<br/></td><td></td></tr>
<tr><td>mkdirs<br/></td><td></td></tr>
<tr><td>mod<br/>%<br/></td><td>Takes two ints and pushes the mod of the two ints on the stack.  25 4 % returns 1.</td></tr>
<tr><td>mostRecentUntabledZ<br/></td><td></td></tr>
<tr><td>moveAndStreamAimedShot<br/></td><td></td></tr>
<tr><td>moveArmToPoseWord<br/></td><td></td></tr>
<tr><td>moveCropToCenter<br/></td><td></td></tr>
<tr><td>moveCropToCenterVanishingPoint<br/></td><td>Move the crop to the center/vanishing point of the camera.</td></tr>
<tr><td>moveCropToCenterVanishingPointSlideHeightReticles<br/></td><td></td></tr>
<tr><td>moveCropToProperValue<br/></td><td></td></tr>
<tr><td>moveCropToProperValueNoUpdate<br/></td><td></td></tr>
<tr><td>moveEeToPoseWord<br/></td><td></td></tr>
<tr><td>moveJointsByAngles<br/></td><td></td></tr>
<tr><td>moveJointsToAngles<br/></td><td></td></tr>
<tr><td>moveObjectBetweenObjectAndObject<br/></td><td></td></tr>
<tr><td>moveObjectToObjectByAmount<br/></td><td></td></tr>
<tr><td>moveObjectToPose<br/></td><td></td></tr>
<tr><td>moveTargetObjectToPose<br/></td><td></td></tr>
<tr><td>moveToCurrentCornellTable<br/></td><td></td></tr>
<tr><td>moveToEEPose<br/></td><td></td></tr>
<tr><td>moveToMappingHeight<br/></td><td></td></tr>
<tr><td>moveToNextMapPosition<br/></td><td></td></tr>
<tr><td>( setPickModeToStaticMarginals 1 setSnapToFlushGrasp 1 &quot;somethingsThere&quot; store 0 &quot;violatedMax&quot; store 1 &quot;moveToOutputPile2ThisPick&quot; store oP isGripperGripping not somethingsThere violatedMax not and and cP oP &quot;&gt;&gt;&gt;&gt; entering moveToOutputPile2 &lt;&lt;&lt;&lt; with iteration &quot; moveToOutputPile2ThisPick plus print setPlaceModeToHold openGripper halfImpulse playWorkspace moveEeToPoseWord 1 changeToHeight waitUntilAtCurrentPosition playWorkspace cw_workspaceIsClear not &quot;somethingsThere&quot; store 1 changeToHeight waitUntilAtCurrentPosition &quot;somethingsThere: &quot; print somethingsThere print somethingsThere oP /* if we didnt succeed when we used an object model, it is likely that something went wrong, and so we should try to find a new grasp */ tableSwapToBlocks setPickModeToStaticMarginals tableMapBestAndPickInPlace tableRestoreFromBlocks cP oP cP ifte isGripperGripping oP liftArm cP oP /* oops didn&apos;t get it */ openGripper cP ifte moveToOutputPile2ThisPick 1 plus &quot;moveToOutputPile2ThisPick&quot; store moveToOutputPile2ThisPick moveToOutputPile2MaxPicks rangle oP 1 &quot;violatedMax&quot; store liftArm cP ift cP whileCollapsed somethingsThere isGripperGripping and oP halfImpulse outputPileWorkspace moveEeToPoseWord waitUntilAtCurrentPosition waitUntilEndpointCallbackReceived isGripperGripping oP 1.500000e-01 perturbPositionScale comeToStop pressUntilEffortInit 3.000000e-02 setSpeed pressUntilEffortCombo openGripper liftArm waitUntilAtCurrentPosition cP oP openGripper cP ifte cP oP openGripper cP ifte /* don&apos;t think this is necessary
  &quot;moveToOutputPile2 clearing workspace so it will be clean for the input scan.&quot; print
  playWorkspace cw_clearWorkspace
  */ )<br/></td><td></td></tr>
<tr><td>4<br/></td><td></td></tr>
<tr><td>moveToRegister<br/></td><td></td></tr>
<tr><td>moveToRegister1<br/></td><td></td></tr>
<tr><td>moveToRegister2<br/></td><td></td></tr>
<tr><td>moveToRegister3<br/></td><td></td></tr>
<tr><td>moveToRegister4<br/></td><td></td></tr>
<tr><td>moveToRegister5<br/></td><td></td></tr>
<tr><td>moveToRegister6<br/></td><td></td></tr>
<tr><td>moveToSetVanishingPointHeightHigh<br/></td><td></td></tr>
<tr><td>moveToSetVanishingPointHeightLow<br/></td><td></td></tr>
<tr><td>moveToTargetZAndGrasp<br/></td><td></td></tr>
<tr><td>moveToTargetZAndGraspA<br/></td><td></td></tr>
<tr><td>movingThreshold<br/></td><td></td></tr>
<tr><td>neutralFace<br/></td><td></td></tr>
<tr><td>neutralScan<br/></td><td></td></tr>
<tr><td>neutralScanA<br/></td><td></td></tr>
<tr><td>neutralScanB<br/></td><td></td></tr>
<tr><td>neutralScanH<br/></td><td></td></tr>
<tr><td>next<br/></td><td></td></tr>
<tr><td>nil<br/></td><td>The empty list.  ( ) .</td></tr>
<tr><td>nod<br/></td><td></td></tr>
<tr><td>noop<br/></td><td></td></tr>
<tr><td>not<br/>!<br/></td><td>Pops a word; pushes a 0 or a 1 depending on its truth value.</td></tr>
<tr><td>now<br/></td><td></td></tr>
<tr><td>numBlueBoxes<br/></td><td></td></tr>
<tr><td>numCameras<br/></td><td></td></tr>
<tr><td>numClasses<br/></td><td></td></tr>
<tr><td>oB<br/>{<br/></td><td></td></tr>
<tr><td>oP<br/>(<br/></td><td>Open paren; begin a compound word.</td></tr>
<tr><td>oSB<br/>[<br/></td><td></td></tr>
<tr><td>oXDown<br/></td><td></td></tr>
<tr><td>oXUp<br/></td><td></td></tr>
<tr><td>oYDown<br/></td><td></td></tr>
<tr><td>oYUp<br/></td><td></td></tr>
<tr><td>oZDown<br/></td><td></td></tr>
<tr><td>oZUp<br/></td><td></td></tr>
<tr><td>observedCameraExposure<br/></td><td></td></tr>
<tr><td>observedCameraFlip<br/></td><td></td></tr>
<tr><td>observedCameraGain<br/></td><td></td></tr>
<tr><td>observedCameraMirror<br/></td><td></td></tr>
<tr><td>observedCameraWhiteBalanceBlue<br/></td><td></td></tr>
<tr><td>observedCameraWhiteBalanceGreen<br/></td><td></td></tr>
<tr><td>observedCameraWhiteBalanceRed<br/></td><td></td></tr>
<tr><td>observedCameraWindowX<br/></td><td></td></tr>
<tr><td>observedCameraWindowY<br/></td><td></td></tr>
<tr><td>openClEchoTest<br/></td><td></td></tr>
<tr><td>openClNbodyDemo<br/></td><td></td></tr>
<tr><td>openGripper<br/></td><td></td></tr>
<tr><td>openGripperInt<br/></td><td></td></tr>
<tr><td>or<br/>||<br/></td><td>Returns logical or of its numeric arguments. Back does not have booleans so it treats 0 (and 0.0) as false, and all other numbers as true.</td></tr>
<tr><td>eePose: { px:5.7499999999999996e-01, py:3.6875000000000002e-01,
    pz:2.0124500000000001e-01, qw:-2.8010000000000001e-03,
    qx:-1.5540000000000000e-03, qy:9.9999000000000005e-01,
    qz:3.0990000000000002e-03 }
<br/></td><td></td></tr>
<tr><td>paintReticles<br/></td><td></td></tr>
<tr><td>20<br/></td><td></td></tr>
<tr><td>pauseAndReset<br/></td><td></td></tr>
<tr><td>3.000000e+00<br/></td><td></td></tr>
<tr><td>pauseStackExecution<br/>Pause<br/></td><td></td></tr>
<tr><td>perturbPosition<br/></td><td></td></tr>
<tr><td>perturbPositionScale<br/></td><td></td></tr>
<tr><td>5<br/></td><td></td></tr>
<tr><td>5.000000e-09<br/></td><td></td></tr>
<tr><td>8.000000e-02<br/></td><td></td></tr>
<tr><td>0.000000e+00<br/></td><td></td></tr>
<tr><td>1.000000e+00<br/></td><td></td></tr>
<tr><td>1.000000e-03<br/></td><td></td></tr>
<tr><td>800<br/></td><td></td></tr>
<tr><td>photoSpin<br/></td><td></td></tr>
<tr><td>pi<br/></td><td></td></tr>
<tr><td>pickAllBlueBoxes<br/></td><td></td></tr>
<tr><td>pickClosestBlueBox<br/></td><td></td></tr>
<tr><td>pickFlushFactor<br/></td><td></td></tr>
<tr><td>pickFocusedClass<br/></td><td></td></tr>
<tr><td>( quarterImpulse playWorkspace moveEeToPoseWord playWorkspace cw_clearWorkspace openGripper waitUntilGripperNotMoving &quot;&gt;&gt;&gt;&gt; entering pickFromInputPile2 &lt;&lt;&lt;&lt;&quot; print oP isGripperGripping not cP oP tableSwapToBlocks 0 &quot;pileSwitchCounter&quot; store oP isGripperGripping not cP oP &quot;&gt;&gt;&gt;&gt; re-entering pickFromInputPile2 &lt;&lt;&lt;&lt;&quot; print openGripper halfImpulse inputPileWorkspace moveEeToPoseWord 1 changeToHeight waitUntilAtCurrentPosition catScan5LoadInputBg catScan5InputPileTakeScene /*
      quarterImpulse
      tableServoToBestSceneObject waitUntilAtCurrentPosition
      */ /* if it starts missing, you can uncomment this to recenter */ /* 
      tableSpiralTakeScene
      tableServoToBestSceneObject waitUntilAtCurrentPosition
      */ tableMapBestAndPickInPlace /* 
      quarterImpulse
      tableSpiralServoToBestSceneObject waitUntilAtCurrentPosition
      setPickModeToStaticMarginals tableMapBestAndPick
      */ /* 
	clearMapForPatrol clearBlueBoxMemories mapLocal
	deliverTargetObject
      */ liftArm pileSwitchCounter 1 plus &quot;pileSwitchCounter&quot; store pileSwitchCounter pileSwitchThreshold rangle oP &quot;  &gt;&gt;&gt;&gt; switching piles &quot; print catScan5SwapInputOutput cP ift cP whileCollapsed halfImpulse playWorkspace moveEeToPoseWord waitUntilAtCurrentPosition oP zDown cP 15 replicateWord isGripperGripping not oP openGripper playWorkspace cw_clearWorkspace cP ift cP whileCollapsed tableRestoreFromBlocks )<br/></td><td></td></tr>
<tr><td>pickObjectUnderEndEffector<br/></td><td></td></tr>
<tr><td>3<br/></td><td></td></tr>
<tr><td>pixelGlobalTest<br/></td><td></td></tr>
<tr><td>pixelServo<br/></td><td></td></tr>
<tr><td>pixelServoA<br/></td><td></td></tr>
<tr><td>pixelServoPickUnderVanishingPoint<br/></td><td></td></tr>
<tr><td>pixelServoPutGripperUnderVanishingPoint<br/></td><td></td></tr>
<tr><td>pixelServoPutVanishingPointUnderGripper<br/></td><td></td></tr>
<tr><td>placeHeldObjectOnObject<br/></td><td></td></tr>
<tr><td>placeObjectInDeliveryZone<br/></td><td></td></tr>
<tr><td>placeObjectInEndEffector<br/></td><td></td></tr>
<tr><td>planCommandJointsAtRateSpin<br/></td><td></td></tr>
<tr><td>planToPointCraneFourStroke<br/></td><td></td></tr>
<tr><td>planToPointCraneThreeStroke<br/></td><td></td></tr>
<tr><td>planToPointCraneThreeStrokeOpenJointHyperPlanner<br/></td><td></td></tr>
<tr><td>( &quot;&gt;&gt;&gt;&gt; entering playWithObject &lt;&lt;&lt;&lt;&quot; print comeToStop pressUntilEffortInit 3.000000e-02 setSpeed pressUntilEffortCombo openGripper stay 1.000000e-02 setGridSize oP zUp cP scan_IRheight replicateWord comeToStop setScanModeCentered currentPose catScan5 )<br/></td><td></td></tr>
<tr><td>eePose: { px:2.8125000000000000e-01, py:8.0125000000000002e-01,
    pz:2.0000000000000001e-01, qw:-2.8010000000000001e-03,
    qx:-1.5540000000000000e-03, qy:9.9999000000000005e-01,
    qz:3.0990000000000002e-03 }
<br/></td><td></td></tr>
<tr><td>plus<br/>+<br/></td><td>Takes two numbers and adds them.  If two ints, returns an int; otherwise returns a double; otherwise does string.</td></tr>
<tr><td>pointToClearanceMap<br/></td><td></td></tr>
<tr><td>pop<br/></td><td></td></tr>
<tr><td>populateStreamBuffers<br/></td><td></td></tr>
<tr><td>pow<br/></td><td></td></tr>
<tr><td>preAnnotateCenterGrasp<br/></td><td></td></tr>
<tr><td>preAnnotateOffsetGrasp<br/></td><td></td></tr>
<tr><td>prepareForAndExecuteGraspFromMemory<br/></td><td></td></tr>
<tr><td>prepareForAndExecuteGraspFromMemoryLearning<br/></td><td></td></tr>
<tr><td>prepareForGraspFromMemory<br/></td><td></td></tr>
<tr><td>prepareForSearch<br/></td><td></td></tr>
<tr><td>prepareToApplyGraspFilterFor1<br/></td><td></td></tr>
<tr><td>prepareToApplyGraspFilterFor2<br/></td><td></td></tr>
<tr><td>prepareToApplyGraspFilterFor3<br/></td><td></td></tr>
<tr><td>prepareToApplyGraspFilterFor4<br/></td><td></td></tr>
<tr><td>pressAndGrasp<br/></td><td></td></tr>
<tr><td>pressAndGraspA<br/></td><td></td></tr>
<tr><td>pressAndRelease<br/></td><td></td></tr>
<tr><td>pressAndReleaseA<br/></td><td></td></tr>
<tr><td>( currentPose 0 currentTableZ minus pickFlushFactor plus 1.450000e-01 plus setEEPosePZ assumePose pressUntilEffortInit 4.000000e-02 setSpeed pressUntilEffortCombo )<br/></td><td></td></tr>
<tr><td>pressUntilEffort<br/></td><td></td></tr>
<tr><td>pressUntilEffortA<br/></td><td></td></tr>
<tr><td>pressUntilEffortAllInOne<br/></td><td>Push down until there is effort sensed; top level word that can be called all in one.</td></tr>
<tr><td>pressUntilEffortCombo<br/></td><td>Press down until effort is larger than a threshold.  Pushes down once more quickly with a coarse press, then does a fine-grained press (to unwined the springs), so at the end you are lightly touching the surface.</td></tr>
<tr><td>pressUntilEffortInit<br/></td><td>Initialize parameters for pressUntilEffort.</td></tr>
<tr><td>pressUntilEffortOrTwist<br/></td><td></td></tr>
<tr><td>pressUntilEffortOrTwistA<br/></td><td></td></tr>
<tr><td>pressUntilEffortOrTwistInit<br/></td><td></td></tr>
<tr><td>pressUntilEffortStart<br/></td><td></td></tr>
<tr><td>print<br/></td><td>Pop a word from the stack and print it to the Ein console.</td></tr>
<tr><td>printClassLabels<br/></td><td>Print class labels to standard output.</td></tr>
<tr><td>printJointAngles<br/></td><td></td></tr>
<tr><td>( &quot;mencoder mf://depthStackB*/*.png -mf w=600:h=600:fps=25 -ovc x264 -x264encopts pass=1:crf=0 -oac copy -o outputAll.avi&quot; print )<br/></td><td></td></tr>
<tr><td>printStacks<br/></td><td></td></tr>
<tr><td>printState<br/></td><td></td></tr>
<tr><td>prod<br/></td><td>Pops a compound word; multiplies the entries; pushes the result.  Usage:  ( 1 1 1 ) prod -&gt; 1.</td></tr>
<tr><td>publishCommandsMode<br/></td><td></td></tr>
<tr><td>publishCommandsOff<br/></td><td>Do not publish commands to the robot; useful if someone else (like MoveIt) is going to move the robot.</td></tr>
<tr><td>publishCommandsOn<br/></td><td>Turn on publishing movement commands and other changing commands (lights, sonar).</td></tr>
<tr><td>publishImageFileToFace<br/></td><td></td></tr>
<tr><td>publishImageToFace<br/></td><td></td></tr>
<tr><td>publishRecognizedObjectArrayFromBlueBoxMemory<br/></td><td></td></tr>
<tr><td>publishState<br/></td><td></td></tr>
<tr><td>publishWristViewToFace<br/></td><td></td></tr>
<tr><td>pursuitProximity<br/></td><td></td></tr>
<tr><td>pushClassLabels<br/></td><td>Push the class labels on the stack.</td></tr>
<tr><td>pushClassLabelsReport<br/></td><td></td></tr>
<tr><td>pushCurrentJointAngle<br/></td><td></td></tr>
<tr><td>pushCurrentJointAngles<br/></td><td></td></tr>
<tr><td>pushHelp<br/></td><td>Push help text for the word on the data stack.</td></tr>
<tr><td>pushState<br/></td><td></td></tr>
<tr><td>putCameraOverPhotoPin<br/></td><td></td></tr>
<tr><td>quarterImpulse<br/></td><td></td></tr>
<tr><td>quarterTurn<br/></td><td></td></tr>
<tr><td>quiveringPalm<br/></td><td></td></tr>
<tr><td>rangle<br/>&gt;<br/></td><td>Takes two words and returns 1 if they are greater than (by value) and 0 otherwise.  1 3 &lt; returns false, and 3 1 &lt; returns true</td></tr>
<tr><td>rasterScanningSpeed<br/></td><td></td></tr>
<tr><td>rayBufferInit<br/></td><td></td></tr>
<tr><td>rayBufferPopulateFromImageBuffer<br/></td><td></td></tr>
<tr><td>rayBufferPopulateFromRangeBuffer<br/></td><td></td></tr>
<tr><td>rayBufferSaveRaw<br/></td><td></td></tr>
<tr><td>rayBufferSize<br/></td><td></td></tr>
<tr><td>recordAllBlueBoxes<br/></td><td></td></tr>
<tr><td>recordAllExamplesFocusedClass<br/></td><td></td></tr>
<tr><td>recordExampleAsFocusedClass<br/></td><td></td></tr>
<tr><td>recordGraspZ<br/></td><td></td></tr>
<tr><td>recordHeightLearnTrial<br/></td><td></td></tr>
<tr><td>recordPostTargetLock<br/></td><td></td></tr>
<tr><td>recordPreTargetLock<br/></td><td></td></tr>
<tr><td>registerEffort<br/></td><td></td></tr>
<tr><td>registerEffortA<br/></td><td></td></tr>
<tr><td>registerWrench<br/></td><td></td></tr>
<tr><td>registerWrenchA<br/></td><td></td></tr>
<tr><td>reinitRangeMaps<br/></td><td></td></tr>
<tr><td>reloadCamera<br/></td><td></td></tr>
<tr><td>reloadClassLabels<br/></td><td></td></tr>
<tr><td>renameFocusedClass<br/></td><td></td></tr>
<tr><td>renderSetWristViewBrightnessScalar<br/></td><td></td></tr>
<tr><td>renderWristViewBrightnessScalar<br/></td><td></td></tr>
<tr><td>repeatHalo<br/></td><td></td></tr>
<tr><td>replaceBlueBoxesWithFocusedClass<br/></td><td></td></tr>
<tr><td>replaceBlueBoxesWithHistogramWinner<br/></td><td></td></tr>
<tr><td>replicateWord<br/></td><td></td></tr>
<tr><td>repr<br/></td><td>Takes an argument from the data stack pushes the string representation onto the data stack.  Usage:  &lt; word &gt; repr -&gt; string</td></tr>
<tr><td>resetAccumulatedDensity<br/></td><td></td></tr>
<tr><td>resetAccumulatedStreamImage<br/></td><td></td></tr>
<tr><td>resetAerialGradientTemporalFrameAverage<br/></td><td></td></tr>
<tr><td>resetAuxiliary<br/></td><td></td></tr>
<tr><td>resetAveragedWrenchNorm<br/></td><td></td></tr>
<tr><td>resetCurrentFocusedClass<br/></td><td></td></tr>
<tr><td>resetTemporalMap<br/></td><td></td></tr>
<tr><td>resetW1ThreshToDefault<br/></td><td></td></tr>
<tr><td>restoreIkShare<br/></td><td></td></tr>
<tr><td>retrainVocabOff<br/></td><td></td></tr>
<tr><td>retrainVocabOn<br/></td><td></td></tr>
<tr><td>returnObject<br/></td><td></td></tr>
<tr><td>reverseCompound<br/></td><td></td></tr>
<tr><td>reversePath<br/></td><td></td></tr>
<tr><td>rewindImageStreamBuffer<br/></td><td></td></tr>
<tr><td>rewindImageStreamBufferNLNK<br/></td><td></td></tr>
<tr><td>rgbScan<br/></td><td></td></tr>
<tr><td>robotSerial<br/></td><td></td></tr>
<tr><td>robotSoftwareVersion<br/></td><td></td></tr>
<tr><td>robotType<br/></td><td></td></tr>
<tr><td>rock<br/></td><td></td></tr>
<tr><td>rockA<br/></td><td></td></tr>
<tr><td>rockB<br/></td><td></td></tr>
<tr><td>rockC<br/></td><td></td></tr>
<tr><td>rockD<br/></td><td></td></tr>
<tr><td>rockDA<br/></td><td></td></tr>
<tr><td>rockInit<br/></td><td></td></tr>
<tr><td>roll<br/></td><td></td></tr>
<tr><td>sB<br/>|B<br/></td><td></td></tr>
<tr><td>sP<br/>|S<br/></td><td></td></tr>
<tr><td>sadFace<br/></td><td></td></tr>
<tr><td>sampleHeight<br/></td><td></td></tr>
<tr><td>save3dGrasps<br/></td><td></td></tr>
<tr><td>saveAccumulatedStreamToServoImage<br/></td><td></td></tr>
<tr><td>saveAerialGradientMap<br/></td><td></td></tr>
<tr><td>saveCalibration<br/></td><td></td></tr>
<tr><td>saveCalibrationToClass<br/></td><td></td></tr>
<tr><td>saveConfig<br/></td><td></td></tr>
<tr><td>saveCurrentClassDepthAndGraspMaps<br/></td><td></td></tr>
<tr><td>saveGripperMask<br/></td><td></td></tr>
<tr><td>saveIkMap<br/></td><td></td></tr>
<tr><td>saveIkMapAtHeight<br/></td><td></td></tr>
<tr><td>saveRegister1<br/></td><td></td></tr>
<tr><td>saveRegister2<br/></td><td></td></tr>
<tr><td>saveRegister3<br/></td><td></td></tr>
<tr><td>saveRegister4<br/></td><td></td></tr>
<tr><td>scanCentered<br/></td><td></td></tr>
<tr><td>scanGroup<br/></td><td></td></tr>
<tr><td>scanObject<br/></td><td>Scans an object, including the IR scan.</td></tr>
<tr><td>scanObjectFast<br/></td><td>Scans an object without an IR scan, and with an annotated grasp.</td></tr>
<tr><td>scanObjectScene<br/></td><td>Scans a stack of objects in stream mode with an annotated 3d grasps in stack.</td></tr>
<tr><td>scanObjectStream<br/></td><td>Scans an object in stream mode with an annotated grasp.</td></tr>
<tr><td>scanObjectStreamAnnotated<br/></td><td>Scans an object in stream mode with an annotated grasp.</td></tr>
<tr><td>scanObjectStreamWaypoints<br/></td><td>Scans a stack of objects in stream mode with an annotated grasps in stack.</td></tr>
<tr><td>scanObjectStreamWaypoints3d<br/></td><td>Scans a stack of objects in stream mode with an annotated 3d grasps in stack.</td></tr>
<tr><td>scanObjectStreamWaypoints3dNoPick<br/></td><td>Scans a stack of objects in stream mode with an annotated 3d grasps in stack.</td></tr>
<tr><td>scanObjectStreamWaypointsIR<br/></td><td>Scans a stack of objects in stream mode using IR raster scan to infer grasp points.</td></tr>
<tr><td>8<br/></td><td></td></tr>
<tr><td>( clearMapForPatrol /*
  start3dGraspAnnotationNoChange 
  c3dPoseBase &quot;scan_catScan2_base&quot; store 
  */ lock3dGraspBase c3dPoseBase eePosePZ &quot;scan_catScan2_basePZ&quot; store synchronicServo gradientServo currentPose scan_catScan2_basePZ setEEPosePZ &quot;scan_catScan2_base&quot; store scan_swapToBars /* 
  start3dGraspAnnotationNoChange 
  */ gradientServo prepareForGraspFromMemory currentPose scan_catScan2_basePZ pickFlushFactor plus setEEPosePZ &quot;scan_catScan2_newGrasp&quot; store scan_restoreFromBars scan_catScan2_base setC3dPoseBase scan_catScan2_newGrasp add3dGraspPoseWord writeFocusedClassGrasps )<br/></td><td></td></tr>
<tr><td>0<br/></td><td></td></tr>
<tr><td>1<br/></td><td></td></tr>
<tr><td>&quot;catScan_011310P0011_left_2018-04-12_14:40:18.008144008144&quot;<br/></td><td></td></tr>
<tr><td>( setIdleModeToEmpty openGripper oP 1 changeToHeight scan_isNewComponent not cP oP pickFocusedClass isGripperGripping oP playWorkspace moveEeToPoseWord comeToStop pressUntilEffortInit 3.000000e-02 setSpeed pressUntilEffortCombo quarterImpulse 1.000000e-02 setGridSize oP zUp cP catScan_dropHeight setMovementStateToMoving replicateWord comeToStop cP ift openGripper cP whileCollapsed )<br/></td><td></td></tr>
<tr><td>( 0 &quot;scan_breakInd&quot; store moveEeToPoseWord waitUntilAtCurrentPosition 1 changeToHeight catScan5LoadPlayBg &quot;scan_findObjectAfterDrop: &quot; print currentPose cw_workspaceIsClear &quot;scan_findObjectAfterDrop_space_clear&quot; store scan_findObjectAfterDrop_space_clear oP &quot;Found no object.&quot; print 0 &quot;scan_breakInd&quot; store cP oP &quot;Found an object, moving to it.&quot; print 1 &quot;scan_breakInd&quot; store /* probably unnecessary */ /* 
    tableSpiralServoToAnonymousObject waitUntilAtCurrentPosition
    */ cP ifte scan_breakInd )<br/></td><td></td></tr>
<tr><td>( moveEeToPoseWord waitUntilAtCurrentPosition 0 &quot;scan_pointCounter&quot; store 0 &quot;scan_breakInd&quot; store /* 0.01 setGridSize ( xDown ) 20 replicateWord */ 1.000000e-02 setGridSize oP xDown cP 10 replicateWord oP yDown cP 5 replicateWord oP scan_pointCounter 3 /* 4 */ langle scan_breakInd not and cP oP oP yUp cP 10 replicateWord cw_viewIsClear oP oP yDown cP 10 replicateWord cw_viewIsClear oP oP xUp cP 10 replicateWord cP oP 1 &quot;scan_breakInd&quot; store cP ifte cP oP 1 &quot;scan_breakInd&quot; store cP ifte scan_pointCounter 1 plus &quot;scan_pointCounter&quot; store cP whileCollapsed scan_breakInd )<br/></td><td></td></tr>
<tr><td>( clearMapForPatrol synchronicServo gradientServoPrep buildClassSimilarityMatrixFromDensity 8.000000e-01 rangle oP 0.000000e+00 &quot; **** not a new component &quot; print cP oP 1.000000e+00 &quot; **** is a new component &quot; print cP ifte )<br/></td><td></td></tr>
<tr><td>( endArgs scan_swap_classLabels setClassLabels scan_swap_targetClass setFocusedClass createCachedClassifierFromClassLabels 0 setGradientServoMode setGraspModeTo3D )<br/></td><td></td></tr>
<tr><td>( slide oP pushClassLabels 1 sP cP &quot;scan_swap_classLabels&quot; store focusedClassLabel &quot;scan_swap_targetClass&quot; store setPickModeToStaticMarginals /* endArgs &quot;kr_bars/10_5_2&quot; &quot;kr_bars/10_5_4&quot; &quot;kr_bars/10_5_6&quot; &quot;kr_bars/10_5_8&quot; &quot;kr_bars/10_5_10&quot; setClassLabels */ endArgs &quot;kr_bars/10_4_0&quot; &quot;kr_bars/10_5_2&quot; &quot;kr_bars/10_5_4&quot; &quot;kr_bars/10_5_6&quot; &quot;kr_bars/10_5_8&quot; &quot;kr_bars/10_5_10&quot; setClassLabels &quot;kr_bars/10_5_2&quot; setFocusedClass /* endArgs &quot;kr_bars/10_5_6&quot; &quot;kr_bars/10_5_8&quot; &quot;kr_bars/10_5_10&quot; setClassLabels
  &quot;kr_bars/10_5_6&quot; setTargetClass */ createCachedClassifierFromClassLabels 1 setGradientServoMode setGraspModeToCrane 2 setGradientServoSoftMaxIterations 2 setGradientServoHardMaxIterations 1 setMappingServoTimeout )<br/></td><td></td></tr>
<tr><td>( oB sB oP 1 cP oP 5.000000e-01 setHeadPanTargetSpeed drand48 20 times spinForSeconds drand48 5.000000e-01 rangle oP &quot;ursula_yes.tif&quot; publishImageFileToFace cP oP &quot;ursula_no.tif&quot; publishImageFileToFace cP ifte endStackCollapseNoop cP whileCollapsed cB oB sB oP 1 cP oP 30006 &quot;gazeNumber&quot; store &quot;gaze&quot; gazeNumber &quot;.tif&quot; plus plus publishImageFileToFace gazeDelta spinForSeconds oP gazeNumber 1 plus &quot;gazeNumber&quot; store &quot;gaze&quot; gazeNumber &quot;.tif&quot; plus plus publishImageFileToFace gazeDelta spinForSeconds cP 6 replicateWord oP gazeNumber -1 plus &quot;gazeNumber&quot; store &quot;gaze&quot; gazeNumber &quot;.tif&quot; plus plus publishImageFileToFace gazeDelta spinForSeconds cP 5 replicateWord endStackCollapseNoop cP whileCollapsed cB )<br/></td><td></td></tr>
<tr><td>( 70 30 fixCameraLightingExposureGain oB sB 1.000000e-01 &quot;gazeDelta&quot; store oB sB oP 1 cP oP blink_lightshow cP whileCollapsed cB oB sB oP playWorkspace catScan2 cP 5 replicateWord cB oB sB oP 1 cP oP 5.000000e-01 setHeadPanTargetSpeed drand48 20 times spinForSeconds endStackCollapseNoop cP whileCollapsed cB oB sB oP 1 cP oP 30006 &quot;gazeNumber&quot; store &quot;gaze&quot; gazeNumber &quot;.tif&quot; plus plus publishImageFileToFace gazeDelta spinForSeconds oP gazeNumber 1 plus &quot;gazeNumber&quot; store &quot;gaze&quot; gazeNumber &quot;.tif&quot; plus plus publishImageFileToFace gazeDelta spinForSeconds cP 6 replicateWord oP gazeNumber -1 plus &quot;gazeNumber&quot; store &quot;gaze&quot; gazeNumber &quot;.tif&quot; plus plus publishImageFileToFace gazeDelta spinForSeconds cP 5 replicateWord endStackCollapseNoop cP whileCollapsed cB oB sB oP 1 cP oP isGripperGripping oP nod cP ift cP whileCollapsed cB cB oP 1 cP oP slip cP whileCollapsed )<br/></td><td></td></tr>
<tr><td>( 70 30 fixCameraLightingExposureGain oB sB 1.000000e-01 &quot;gazeDelta&quot; store oB sB oP 1 cP oP blink_lightshow cP whileCollapsed cB oB sB oP playWorkspace catScan2 cP 5 replicateWord cB oB sB oP 1 cP oP 5.000000e-01 setHeadPanTargetSpeed drand48 20 times spinForSeconds endStackCollapseNoop cP whileCollapsed cB oB sB oP 1 cP oP isGripperGripping oP nod cP ift cP whileCollapsed cB cB oP 1 cP oP slip cP whileCollapsed )<br/></td><td></td></tr>
<tr><td>( 70 30 fixCameraLightingExposureGain oB sB 1.000000e-01 &quot;gazeDelta&quot; store oB sB oP 1 cP oP blink_lightshow cP whileCollapsed cB oB sB oP playWorkspace catScan2 cP 5 replicateWord cB oB sB oP 1 cP oP 5.000000e-01 setHeadPanTargetSpeed drand48 20 times spinForSeconds endStackCollapseNoop cP whileCollapsed cB oB sB oP 1 cP oP publishWristViewToFace cP whileCollapsed cB oB sB oP 1 cP oP isGripperGripping oP nod cP ift cP whileCollapsed cB cB oP 1 cP oP slip cP whileCollapsed )<br/></td><td></td></tr>
<tr><td>sceneAddDiscrepantPredictedToObserved<br/></td><td></td></tr>
<tr><td>sceneAddPredictedFocusedObject<br/></td><td></td></tr>
<tr><td>sceneAddPredictedObject<br/></td><td></td></tr>
<tr><td>sceneAddPredictedToObserved<br/></td><td></td></tr>
<tr><td>sceneAnchorPose<br/></td><td>Takes a gaussian map on the stack and returns its anchor eePose.</td></tr>
<tr><td>sceneAngularApertureCols<br/></td><td></td></tr>
<tr><td>sceneAngularApertureRows<br/></td><td></td></tr>
<tr><td>sceneAngularBaffleCols<br/></td><td></td></tr>
<tr><td>sceneAngularBaffleRows<br/></td><td></td></tr>
<tr><td>sceneBackgroundMap<br/></td><td>Takes a scene on the stack and returns its background map.</td></tr>
<tr><td>sceneCellCountThreshold<br/></td><td></td></tr>
<tr><td>sceneCellWidth<br/></td><td></td></tr>
<tr><td>sceneClearDepthStack<br/></td><td></td></tr>
<tr><td>sceneClearObservedMap<br/></td><td></td></tr>
<tr><td>sceneClearPredictedObjects<br/></td><td></td></tr>
<tr><td>sceneCoalesceClassHarmonics<br/></td><td></td></tr>
<tr><td>sceneComposePredictedMap<br/></td><td></td></tr>
<tr><td>sceneComposePredictedMapThreshed<br/></td><td></td></tr>
<tr><td>sceneComputeProbabilityOfMap<br/></td><td></td></tr>
<tr><td>sceneComputeScore<br/></td><td></td></tr>
<tr><td>sceneCopyGaussianMap<br/></td><td>Takes a gaussian map on the stack and performs a deep copy, leaving a new gaussian map on the stack.</td></tr>
<tr><td>sceneCopyObservedToReprojectionBuffer<br/></td><td></td></tr>
<tr><td>sceneCopyScene<br/></td><td>Takes a scene on the stack and performs a deep copy, leaving a new scene on the stack.</td></tr>
<tr><td>sceneCountDiscrepantCells<br/></td><td></td></tr>
<tr><td>sceneCropToDiscrepantRegion<br/></td><td></td></tr>
<tr><td>sceneDensityFromDiscrepancy<br/></td><td></td></tr>
<tr><td>sceneDepthPatchHalfWidth<br/></td><td></td></tr>
<tr><td>sceneDepthStackLoadAndCropRaw<br/></td><td></td></tr>
<tr><td>sceneDepthStackLoadAndMarginalizeRaw<br/></td><td></td></tr>
<tr><td>sceneDepthStackLoadAndMinRaw<br/></td><td></td></tr>
<tr><td>sceneDepthStackLoadAndPushRaw<br/></td><td></td></tr>
<tr><td>sceneDepthStackSavePngRaw<br/></td><td></td></tr>
<tr><td>sceneDepthStackSaveRaw<br/></td><td></td></tr>
<tr><td>sceneDiscrepancyMode<br/></td><td></td></tr>
<tr><td>sceneDiscrepancySearchDepth<br/></td><td></td></tr>
<tr><td>sceneExponentialAverageObservedIntoBackground<br/></td><td></td></tr>
<tr><td>sceneFabricateIdealBlockModel<br/></td><td></td></tr>
<tr><td>sceneFlattenUncertainZWithDepthStack<br/></td><td></td></tr>
<tr><td>sceneGetAnnotatedClassName<br/></td><td></td></tr>
<tr><td>sceneGetClassificationMode<br/></td><td></td></tr>
<tr><td>sceneGetFixationMode<br/></td><td></td></tr>
<tr><td>sceneGetPredictedClassName<br/></td><td></td></tr>
<tr><td>sceneGrabDiscrepantCropAsClass<br/></td><td></td></tr>
<tr><td>5.000000e-01<br/></td><td></td></tr>
<tr><td>sceneHighPrecisionBeforeAfterDiffOfLogs<br/></td><td></td></tr>
<tr><td>sceneInit<br/></td><td></td></tr>
<tr><td>sceneInitDefaultBackgroundMap<br/></td><td>Check if the map exists; otherwise create a default one.</td></tr>
<tr><td>sceneInitDimensions<br/></td><td></td></tr>
<tr><td>sceneInitFromEePose<br/></td><td></td></tr>
<tr><td>sceneInitFromEePoseScale<br/></td><td></td></tr>
<tr><td>sceneInitFromEePoseScaleDimensions<br/></td><td></td></tr>
<tr><td>sceneInitRegisterMax<br/></td><td></td></tr>
<tr><td>sceneInitRegisterZero<br/></td><td></td></tr>
<tr><td>sceneInitSmall<br/></td><td></td></tr>
<tr><td>sceneIsNewConfiguration<br/></td><td></td></tr>
<tr><td>sceneLoadBackgroundMap<br/></td><td></td></tr>
<tr><td>sceneLoadDiscrepancyMap<br/></td><td></td></tr>
<tr><td>sceneLoadFocusedObjectModel<br/></td><td>Load the object model of the focused class from disk.</td></tr>
<tr><td>sceneLoadFocusedSceneModel<br/></td><td>Loads a scene from disk into the scene model for the focused class.  Requires the name of a scene that is saved to disk.</td></tr>
<tr><td>sceneLoadGaussianMap<br/></td><td>Takes a string, loads the gaussian map and puts it on the stack.</td></tr>
<tr><td>sceneLoadLightingModelFromGaussianMapFile<br/></td><td></td></tr>
<tr><td>sceneLoadMonochromeBackground<br/></td><td></td></tr>
<tr><td>sceneLoadObjectModel<br/></td><td>Load the object model.  Takes an object name as argument, which must be a directory name in the objects directory.</td></tr>
<tr><td>sceneLoadObservedMap<br/></td><td></td></tr>
<tr><td>sceneLoadScene<br/></td><td></td></tr>
<tr><td>sceneLoadSceneRaw<br/></td><td></td></tr>
<tr><td>sceneMapSceneObject<br/></td><td></td></tr>
<tr><td>sceneMarginalizeDepthStackIntoRegister<br/></td><td></td></tr>
<tr><td>sceneMinDepthStackIntoRegister<br/></td><td></td></tr>
<tr><td>sceneMinIntoRegister<br/></td><td></td></tr>
<tr><td>sceneMinSigmaSquared<br/></td><td></td></tr>
<tr><td>sceneNumPredictedObjects<br/></td><td></td></tr>
<tr><td>sceneObjectLabelToSceneObjectIdx<br/></td><td></td></tr>
<tr><td>sceneObservedMap<br/></td><td>Takes a scene on the stack and returns its observed map.</td></tr>
<tr><td>scenePredictBestObject<br/></td><td></td></tr>
<tr><td>scenePredictFocusedObject<br/></td><td></td></tr>
<tr><td>scenePredictedMap<br/></td><td>Takes a scene on the stack and returns its predicted map.</td></tr>
<tr><td>5.000000e-01<br/></td><td></td></tr>
<tr><td>5.000000e-01<br/></td><td></td></tr>
<tr><td>scenePushAnchorPose<br/></td><td></td></tr>
<tr><td>scenePushAverageCrCbSigmaSquared<br/></td><td></td></tr>
<tr><td>scenePushDepthStackSize<br/></td><td></td></tr>
<tr><td>scenePushFocusedClassModelArea<br/></td><td></td></tr>
<tr><td>scenePushFocusedClassTotalDiscrepancy<br/></td><td></td></tr>
<tr><td>scenePushLightingModel<br/></td><td></td></tr>
<tr><td>scenePushNumSceneObjects<br/></td><td></td></tr>
<tr><td>scenePushOntoDepthStack<br/></td><td></td></tr>
<tr><td>scenePushPixelOfMinStackVariance<br/></td><td></td></tr>
<tr><td>scenePushPixelOfMinVariance<br/></td><td></td></tr>
<tr><td>scenePushSceneObjectLabel<br/></td><td></td></tr>
<tr><td>scenePushSceneObjectPose<br/></td><td>Takes an index; pushes the pose for this predicted object.</td></tr>
<tr><td>scenePushTotalDiscrepancy<br/></td><td></td></tr>
<tr><td>scenePushTotalDiscrepancyMagnitude<br/></td><td></td></tr>
<tr><td>scenePushTotalLogDiscrepancy<br/></td><td></td></tr>
<tr><td>scenePushTotalRelevantOneMinusDiscrepancy<br/></td><td></td></tr>
<tr><td>sceneRecalculateObservedMusAndSigmas<br/></td><td></td></tr>
<tr><td>sceneRecallDepthStackIndex<br/></td><td></td></tr>
<tr><td>sceneRecallFromRegister<br/></td><td></td></tr>
<tr><td>sceneRegularizeSceneL2<br/></td><td></td></tr>
<tr><td>sceneRenderBackgroundMap<br/></td><td></td></tr>
<tr><td>sceneRenderDiscrepancy<br/></td><td></td></tr>
<tr><td>sceneRenderObservedMap<br/></td><td></td></tr>
<tr><td>sceneRenderPredictedMap<br/></td><td></td></tr>
<tr><td>sceneRenderScene<br/></td><td></td></tr>
<tr><td>( sceneClearPredictedObjects 2.600000e-01 7.950000e-01 1.500000e+00 sceneAddPredictedFocusedObject sceneClearObservedMap sceneUpdateObservedFromWrist 30 sceneSetBackgroundStdDev sceneComposePredictedMap sceneUpdateDiscrepancy sceneDensityFromDiscrepancy 60 20 fixCameraLightingExposureGain sceneGrabDiscrepantCropAsClassDefaultThresh sceneGrabDiscrepantCropAsClass )<br/></td><td></td></tr>
<tr><td>sceneRenderZ<br/></td><td></td></tr>
<tr><td>sceneSaveBackgroundMap<br/></td><td></td></tr>
<tr><td>sceneSaveDiscrepancyDensityImage<br/></td><td></td></tr>
<tr><td>sceneSaveDiscrepancyMap<br/></td><td></td></tr>
<tr><td>sceneSaveFocusedSceneModel<br/></td><td></td></tr>
<tr><td>sceneSaveGaussianMap<br/></td><td>Takes a string and saves a gaussian map to that string.</td></tr>
<tr><td>sceneSaveLightingModelToGaussianMapFile<br/></td><td></td></tr>
<tr><td>sceneSaveObservedMap<br/></td><td></td></tr>
<tr><td>sceneSaveObservedMapImage<br/></td><td></td></tr>
<tr><td>sceneSaveScene<br/></td><td></td></tr>
<tr><td>sceneSaveSceneAbsolute<br/></td><td></td></tr>
<tr><td>( sceneScanXUp oP yUp cP 20 replicateWord sceneScanXDown )<br/></td><td></td></tr>
<tr><td>( oP sceneUpdateObservedFromWrist oP xDown cP 10 replicateWord waitUntilAtCurrentPosition comeToStop cP 5 replicateWord )<br/></td><td></td></tr>
<tr><td>( oP sceneUpdateObservedFromWrist oP xUp cP 10 replicateWord waitUntilAtCurrentPosition comeToStop cP 5 replicateWord )<br/></td><td></td></tr>
<tr><td>sceneScoreObjectAtPose<br/></td><td></td></tr>
<tr><td>sceneScoreThresh<br/></td><td></td></tr>
<tr><td>sceneSetAngularApertureCols<br/></td><td></td></tr>
<tr><td>sceneSetAngularApertureRows<br/></td><td></td></tr>
<tr><td>sceneSetAngularBaffleCols<br/></td><td></td></tr>
<tr><td>sceneSetAngularBaffleRows<br/></td><td></td></tr>
<tr><td>sceneSetAnnotatedClassName<br/></td><td></td></tr>
<tr><td>sceneSetAnnotatedClassNameToFocusedClass<br/></td><td></td></tr>
<tr><td>sceneSetBackgroundFromObserved<br/></td><td></td></tr>
<tr><td>sceneSetBackgroundMap<br/></td><td>Takes a scene and a background map and sets the scene with the background map. </td></tr>
<tr><td>sceneSetBackgroundStdDevColor<br/></td><td></td></tr>
<tr><td>sceneSetBackgroundStdDevY<br/></td><td></td></tr>
<tr><td>sceneSetCellCountThreshold<br/></td><td></td></tr>
<tr><td>sceneSetClassificationMode<br/></td><td></td></tr>
<tr><td>sceneSetCurrentScene<br/></td><td>Sets the current scene with its argument.</td></tr>
<tr><td>sceneSetDepthPatchHalfWidth<br/></td><td></td></tr>
<tr><td>sceneSetDiscrepancyDensityFromZ<br/></td><td></td></tr>
<tr><td>sceneSetDiscrepancyModeDot<br/></td><td></td></tr>
<tr><td>sceneSetDiscrepancyModeNoisyAnd<br/></td><td></td></tr>
<tr><td>sceneSetDiscrepancyModeNoisyOr<br/></td><td></td></tr>
<tr><td>sceneSetDiscrepancyModePoint<br/></td><td></td></tr>
<tr><td>sceneSetDiscrepancySearchDepth<br/></td><td></td></tr>
<tr><td>sceneSetFixationMode<br/></td><td></td></tr>
<tr><td>sceneSetFocusedSceneStdDevColor<br/></td><td></td></tr>
<tr><td>sceneSetFocusedSceneStdDevY<br/></td><td></td></tr>
<tr><td>sceneSetHeightReticleFromPixel<br/></td><td></td></tr>
<tr><td>sceneSetHeightReticleFromVariance<br/></td><td></td></tr>
<tr><td>sceneSetLightModelFromDiscrepancy<br/></td><td></td></tr>
<tr><td>sceneSetLightingModelFromStack<br/></td><td></td></tr>
<tr><td>sceneSetLightingModelStdDevColor<br/></td><td></td></tr>
<tr><td>sceneSetLightingModelStdDevY<br/></td><td></td></tr>
<tr><td>sceneSetMinSigmaSquared<br/></td><td></td></tr>
<tr><td>sceneSetObservedMap<br/></td><td>Takes a scene and an observed map and sets the scene with the observed map. </td></tr>
<tr><td>sceneSetObservedRGBFromVariance<br/></td><td></td></tr>
<tr><td>sceneSetObservedRGBFromZ<br/></td><td></td></tr>
<tr><td>sceneSetPredictedClassName<br/></td><td></td></tr>
<tr><td>sceneSetPredictedClassNameToFocusedClass<br/></td><td></td></tr>
<tr><td>sceneSetPredictedStdDevColor<br/></td><td></td></tr>
<tr><td>sceneSetPredictedStdDevY<br/></td><td></td></tr>
<tr><td>sceneSetScoreThresh<br/></td><td></td></tr>
<tr><td>sceneSetVanishingPointFromPixel<br/></td><td></td></tr>
<tr><td>sceneSetVanishingPointFromVariance<br/></td><td></td></tr>
<tr><td>sceneSmoothDepthStackInZ<br/></td><td></td></tr>
<tr><td>sceneSmoothDiscrepancyDensity<br/></td><td></td></tr>
<tr><td>sceneSmoothSquaredCountsAndSamplesXY<br/></td><td></td></tr>
<tr><td>sceneSpawnClassHarmonics<br/></td><td></td></tr>
<tr><td>sceneStoreObservedInRegister<br/></td><td></td></tr>
<tr><td>sceneTakeAfterDensity<br/></td><td></td></tr>
<tr><td>sceneTakeBeforeDensity<br/></td><td></td></tr>
<tr><td>sceneTrimDepthWithDiscrepancy<br/></td><td></td></tr>
<tr><td>sceneUpdateAllClassDiscrepancies<br/></td><td></td></tr>
<tr><td>sceneUpdateDiscrepancy<br/></td><td></td></tr>
<tr><td>sceneUpdateObservedFromRegisterAtZNoRecalcPhasedArray<br/></td><td></td></tr>
<tr><td>sceneUpdateObservedFromRegisterAtZNoRecalcPhasedArrayKernel<br/></td><td></td></tr>
<tr><td>sceneUpdateObservedFromReprojectionBufferAtZNoRecalc<br/></td><td></td></tr>
<tr><td>sceneUpdateObservedFromStreamBuffer<br/></td><td></td></tr>
<tr><td>sceneUpdateObservedFromStreamBufferAtZ<br/></td><td></td></tr>
<tr><td>sceneUpdateObservedFromStreamBufferAtZNoRecalc<br/></td><td></td></tr>
<tr><td>sceneUpdateObservedFromStreamBufferAtZNoRecalcAll<br/></td><td>Updates the observed map from the stream buffer in a big for loop; fastest version without GPU.  This is the one to copy and call.</td></tr>
<tr><td>sceneUpdateObservedFromStreamBufferAtZNoRecalcAllLightModelRenderGlareOnly<br/></td><td></td></tr>
<tr><td>sceneUpdateObservedFromStreamBufferAtZNoRecalcAllLightModelRenderGlareOnlyRising<br/></td><td></td></tr>
<tr><td>sceneUpdateObservedFromStreamBufferAtZNoRecalcAllLightModelRenderWithoutGlare<br/></td><td></td></tr>
<tr><td>sceneUpdateObservedFromStreamBufferAtZNoRecalcAllLightModelRenderWithoutGlareRising<br/></td><td></td></tr>
<tr><td>sceneUpdateObservedFromStreamBufferAtZNoRecalcAllOOP<br/></td><td></td></tr>
<tr><td>sceneUpdateObservedFromStreamBufferAtZNoRecalcAllSelfModelRenderGlareOnly<br/></td><td></td></tr>
<tr><td>sceneUpdateObservedFromStreamBufferAtZNoRecalcAllSelfModelRenderWithoutGlare<br/></td><td></td></tr>
<tr><td>sceneUpdateObservedFromStreamBufferAtZNoRecalcEPI<br/></td><td></td></tr>
<tr><td>sceneUpdateObservedFromStreamBufferAtZNoRecalcPhasedArray<br/></td><td></td></tr>
<tr><td>sceneUpdateObservedFromStreamBufferAtZNoRecalcSecondStageArray<br/></td><td></td></tr>
<tr><td>sceneUpdateObservedFromStreamBufferAtZNoRecalcSecondStageAsymmetricArray<br/></td><td></td></tr>
<tr><td>sceneUpdateObservedFromStreamBufferAtZNoRecalcViewSynthAll<br/></td><td></td></tr>
<tr><td>sceneUpdateObservedFromStreamBufferAtZNoRecalcViewSynthAllGCLightModelRenderGlareOnly<br/></td><td></td></tr>
<tr><td>sceneUpdateObservedFromStreamBufferAtZNoRecalcViewSynthAllGCLightModelRenderWithoutGlare<br/></td><td></td></tr>
<tr><td>sceneUpdateObservedFromStreamBufferAtZNoRecalcViewSynthAllGCSelfRenderGlareOnly<br/></td><td></td></tr>
<tr><td>sceneUpdateObservedFromStreamBufferAtZNoRecalcViewSynthAllGCSelfRenderWithoutGlare<br/></td><td></td></tr>
<tr><td>sceneUpdateObservedFromStreamBufferDepthMap<br/></td><td>Updates the observed map from the stream buffer as a depth map.  Used for the Kinect 2.</td></tr>
<tr><td>sceneUpdateObservedFromStreamBufferNoRecalc<br/></td><td></td></tr>
<tr><td>sceneUpdateObservedFromWrist<br/></td><td></td></tr>
<tr><td>sceneZeroBox<br/></td><td></td></tr>
<tr><td>sceneZeroLowerX<br/></td><td></td></tr>
<tr><td>sceneZeroLowerY<br/></td><td></td></tr>
<tr><td>sceneZeroUpperX<br/></td><td></td></tr>
<tr><td>sceneZeroUpperY<br/></td><td></td></tr>
<tr><td>searchProximity<br/></td><td></td></tr>
<tr><td>seeHz<br/></td><td></td></tr>
<tr><td>selectBestAvailableGrasp<br/></td><td></td></tr>
<tr><td>selectMaxTargetCumulative<br/></td><td></td></tr>
<tr><td>selectMaxTargetNotCumulative<br/></td><td></td></tr>
<tr><td>setAerialGradientsToBarsLengthWidthGap<br/></td><td></td></tr>
<tr><td>setArmedThreshold<br/></td><td></td></tr>
<tr><td>setBeeHome<br/></td><td></td></tr>
<tr><td>setBoundingBoxModeToLearningAlgorithmC<br/></td><td></td></tr>
<tr><td>setBoundingBoxModeToLearningSampling<br/></td><td></td></tr>
<tr><td>setBoundingBoxModeToMapping<br/></td><td></td></tr>
<tr><td>setBoundingBoxModeToStaticMarginals<br/></td><td></td></tr>
<tr><td>setBoundingBoxModeToStaticPrior<br/></td><td></td></tr>
<tr><td>setBreakGraspTiesWithNoise<br/></td><td></td></tr>
<tr><td>setC3dPoseBase<br/></td><td></td></tr>
<tr><td>setCameraCenterX<br/></td><td></td></tr>
<tr><td>setCameraCenterY<br/></td><td></td></tr>
<tr><td>setCameraCropUpperLeftCornerX<br/></td><td></td></tr>
<tr><td>setCameraCropUpperLeftCornerY<br/></td><td></td></tr>
<tr><td>setCameraKappaX<br/></td><td></td></tr>
<tr><td>setCameraKappaY<br/></td><td></td></tr>
<tr><td>setCameraMuX<br/></td><td></td></tr>
<tr><td>setCameraMuY<br/></td><td></td></tr>
<tr><td>setCameraR00<br/></td><td></td></tr>
<tr><td>setCameraR01<br/></td><td></td></tr>
<tr><td>setCameraR10<br/></td><td></td></tr>
<tr><td>setCameraR11<br/></td><td></td></tr>
<tr><td>setClassLabels<br/></td><td>Set the active classes.  useage:  endArgs &quot;class1&quot; &quot;class2&quot; setClassLabels.  The class names must be directorys in the ein/default/objects folder.</td></tr>
<tr><td>setClassLabelsBaseClassAbsolute<br/></td><td></td></tr>
<tr><td>setClassLabelsObjectFolderAbsolute<br/></td><td></td></tr>
<tr><td>setColorReticles<br/></td><td></td></tr>
<tr><td>setColorReticlesA<br/></td><td></td></tr>
<tr><td>setControlModeAngles<br/></td><td></td></tr>
<tr><td>setControlModeEePosition<br/></td><td></td></tr>
<tr><td>setCurrentCornellTableToZero<br/></td><td></td></tr>
<tr><td>setCurrentIKBoundaryMode<br/></td><td></td></tr>
<tr><td>setCurrentIKFastMode<br/></td><td></td></tr>
<tr><td>setCurrentPoseFromJoints<br/></td><td></td></tr>
<tr><td>setCurrentPoseToTruePose<br/></td><td></td></tr>
<tr><td>setCurrentTableZ<br/></td><td></td></tr>
<tr><td>setDefaultHandCameraOffset<br/></td><td>Sets the hand camera offset to the default value (obtained for Baxter&apos;s RGB wrist camera.</td></tr>
<tr><td>setEEPosePX<br/></td><td></td></tr>
<tr><td>setEEPosePY<br/></td><td></td></tr>
<tr><td>setEEPosePZ<br/></td><td></td></tr>
<tr><td>setEEPoseQW<br/></td><td></td></tr>
<tr><td>setEEPoseQX<br/></td><td></td></tr>
<tr><td>setEEPoseQY<br/></td><td></td></tr>
<tr><td>setEEPoseQZ<br/></td><td></td></tr>
<tr><td>setEffortHere<br/></td><td></td></tr>
<tr><td>setEffortThresh<br/></td><td></td></tr>
<tr><td>setExpectedCropsToStream<br/></td><td></td></tr>
<tr><td>setFakeBBWidth<br/></td><td></td></tr>
<tr><td>setFocusedClass<br/>setTargetClass<br/></td><td></td></tr>
<tr><td>setFocusedClassIdx<br/>setTargetClassIdx<br/></td><td></td></tr>
<tr><td>setGradientServoHardMaxIterations<br/></td><td></td></tr>
<tr><td>setGradientServoMode<br/></td><td></td></tr>
<tr><td>setGradientServoSoftMaxIterations<br/></td><td></td></tr>
<tr><td>setGraspBackoffDistance<br/></td><td></td></tr>
<tr><td>setGraspMemoriesFromClassGraspMemories<br/></td><td></td></tr>
<tr><td>setGraspModeTo3D<br/></td><td></td></tr>
<tr><td>setGraspModeToCrane<br/></td><td></td></tr>
<tr><td>setGreenHalo<br/></td><td></td></tr>
<tr><td>setGridSize<br/></td><td></td></tr>
<tr><td>setGridSizeCoarse<br/></td><td></td></tr>
<tr><td>setGridSizeCoarser<br/></td><td></td></tr>
<tr><td>setGridSizeEvenCoarser<br/></td><td></td></tr>
<tr><td>setGridSizeFine<br/></td><td></td></tr>
<tr><td>setGridSizeMedium<br/></td><td></td></tr>
<tr><td>setGridSizeNowThatsCoarse<br/></td><td></td></tr>
<tr><td>setGridSizeVeryFine<br/></td><td></td></tr>
<tr><td>setGripperMask<br/></td><td></td></tr>
<tr><td>setGripperMaskA<br/></td><td></td></tr>
<tr><td>setGripperMaskAA<br/></td><td></td></tr>
<tr><td>setGripperMaskB<br/></td><td></td></tr>
<tr><td>setGripperMaskBA<br/></td><td></td></tr>
<tr><td>setGripperMaskCA<br/></td><td></td></tr>
<tr><td>setGripperMaskCB<br/></td><td></td></tr>
<tr><td>setGripperMaskOnes<br/></td><td></td></tr>
<tr><td>setGripperMaskThresh<br/></td><td></td></tr>
<tr><td>setGripperMaskWithMotion<br/></td><td></td></tr>
<tr><td>setGripperMaskWithMotionA<br/></td><td></td></tr>
<tr><td>setGripperMovingForce<br/></td><td>Set the moving force of the gripper.  Takes an integer between 0-100. </td></tr>
<tr><td>setGripperThresh<br/></td><td></td></tr>
<tr><td>setHandCameraOffset<br/></td><td></td></tr>
<tr><td>setHandEndEffectorOffset<br/></td><td></td></tr>
<tr><td>setHeadPanTargetSpeed<br/></td><td></td></tr>
<tr><td>setHeightMemoriesFromClassHeightMemories<br/></td><td></td></tr>
<tr><td>setHeightReticles<br/></td><td></td></tr>
<tr><td>setHeightReticlesA<br/></td><td></td></tr>
<tr><td>setHelp<br/></td><td>Make a new compound word with specified description text.  Usage:  &lt;compound word&gt; &lt; help text &gt; setHelp -&gt; &lt; compound word with help text &gt;. </td></tr>
<tr><td>setHoverThreshold<br/></td><td></td></tr>
<tr><td>setIROffset<br/></td><td></td></tr>
<tr><td>setIROffsetA<br/></td><td></td></tr>
<tr><td>setIdleModeToCrane<br/></td><td></td></tr>
<tr><td>setIdleModeToEmpty<br/></td><td></td></tr>
<tr><td>setIdleModeToPatrol<br/></td><td></td></tr>
<tr><td>setIdleModeToShrug<br/></td><td></td></tr>
<tr><td>setIdleModeToStopClear<br/></td><td></td></tr>
<tr><td>setLastLabelLearned<br/></td><td></td></tr>
<tr><td>setMagnification<br/></td><td></td></tr>
<tr><td>setMagnificationA<br/></td><td></td></tr>
<tr><td>setMagnificationB<br/></td><td></td></tr>
<tr><td>setMapAutoPick<br/></td><td></td></tr>
<tr><td>setMapFreeSpacePixelSkirt<br/></td><td></td></tr>
<tr><td>setMapGrayBoxPixelSkirtCols<br/></td><td></td></tr>
<tr><td>setMapGrayBoxPixelSkirtRows<br/></td><td></td></tr>
<tr><td>setMapGrayBoxPixelWaistCols<br/></td><td></td></tr>
<tr><td>setMapGrayBoxPixelWaistRows<br/></td><td></td></tr>
<tr><td>setMapSearchFenceXMax<br/></td><td></td></tr>
<tr><td>setMapSearchFenceXMin<br/></td><td></td></tr>
<tr><td>setMapSearchFenceYMax<br/></td><td></td></tr>
<tr><td>setMapSearchFenceYMin<br/></td><td></td></tr>
<tr><td>setMapServoMode<br/></td><td></td></tr>
<tr><td>setMappingServoTimeout<br/></td><td></td></tr>
<tr><td>setMovementStateToMoving<br/></td><td></td></tr>
<tr><td>setMovingThreshold<br/></td><td></td></tr>
<tr><td>setNumClasses<br/></td><td></td></tr>
<tr><td>setPatrolModeToLoop<br/></td><td></td></tr>
<tr><td>setPatrolModeToOnce<br/></td><td></td></tr>
<tr><td>setPatrolStateToHanding<br/></td><td></td></tr>
<tr><td>setPatrolStateToIdling<br/></td><td></td></tr>
<tr><td>setPatrolStateToPatrolling<br/></td><td></td></tr>
<tr><td>setPatrolStateToPicking<br/></td><td></td></tr>
<tr><td>setPatrolStateToPlacing<br/></td><td></td></tr>
<tr><td>setPhotoPinHere<br/></td><td></td></tr>
<tr><td>setPickFixMapAnchor<br/></td><td></td></tr>
<tr><td>setPickFlushFactor<br/></td><td></td></tr>
<tr><td>setPickModeToLearningAlgorithmC<br/></td><td></td></tr>
<tr><td>setPickModeToLearningSampling<br/></td><td></td></tr>
<tr><td>setPickModeToStaticMarginals<br/></td><td></td></tr>
<tr><td>setPickModeToStaticPrior<br/></td><td></td></tr>
<tr><td>setPlaceModeToHand<br/></td><td></td></tr>
<tr><td>setPlaceModeToHold<br/></td><td></td></tr>
<tr><td>setPlaceModeToRegister<br/></td><td></td></tr>
<tr><td>setPlaceModeToShake<br/></td><td></td></tr>
<tr><td>setPressPose<br/></td><td></td></tr>
<tr><td>setPursuitProximity<br/></td><td></td></tr>
<tr><td>setRandomOrientationForPhotospin<br/></td><td></td></tr>
<tr><td>setRandomPositionAfterPick<br/></td><td></td></tr>
<tr><td>setRandomPositionAndOrientationForHeightLearning<br/></td><td></td></tr>
<tr><td>setRangeMapCenterFromCurrentEEPose<br/></td><td></td></tr>
<tr><td>setRedHalo<br/></td><td></td></tr>
<tr><td>setRepeatHalo<br/></td><td></td></tr>
<tr><td>setScanGroup<br/></td><td></td></tr>
<tr><td>setScanModeCentered<br/></td><td></td></tr>
<tr><td>setScanModeNotCentered<br/></td><td></td></tr>
<tr><td>setSearchProximity<br/></td><td></td></tr>
<tr><td>setSisFlags<br/></td><td>Set whether we should save different sensor streams. &lt;pose&gt; &lt;range&gt; &lt;image&gt; &lt;joints&gt; &lt;word&gt; &lt;label&gt; setSisFlags</td></tr>
<tr><td>setSnapToFlushGrasp<br/></td><td></td></tr>
<tr><td>setSonarLed<br/></td><td></td></tr>
<tr><td>setSpeed<br/></td><td></td></tr>
<tr><td>setStiffness<br/></td><td></td></tr>
<tr><td>setStreamPicks<br/></td><td></td></tr>
<tr><td>setTable<br/></td><td></td></tr>
<tr><td>setTableA<br/></td><td></td></tr>
<tr><td>setFocusedClass<br/>setTargetClass<br/></td><td></td></tr>
<tr><td>setFocusedClassIdx<br/>setTargetClassIdx<br/></td><td></td></tr>
<tr><td>setTargetClassToLastLabelLearned<br/></td><td></td></tr>
<tr><td>setTargetReticleToTheMaxMappedPosition<br/></td><td></td></tr>
<tr><td>setTheYcbTable<br/></td><td></td></tr>
<tr><td>setTorsoFanLevel<br/></td><td></td></tr>
<tr><td>setTrackbarLoHi<br/></td><td></td></tr>
<tr><td>setTwistThresh<br/></td><td></td></tr>
<tr><td>setVanishingPoint<br/></td><td></td></tr>
<tr><td>setVanishingPointA<br/></td><td></td></tr>
<tr><td>setVanishingPointB<br/></td><td></td></tr>
<tr><td>setVanishingPointPrep<br/></td><td></td></tr>
<tr><td>setW1AngleThresh<br/></td><td></td></tr>
<tr><td>setW1GoThresh<br/></td><td></td></tr>
<tr><td>shakeHeadNegative<br/></td><td></td></tr>
<tr><td>shakeHeadPositive<br/></td><td></td></tr>
<tr><td>shakeItOff1<br/></td><td></td></tr>
<tr><td>shakeItUpAndDown<br/></td><td></td></tr>
<tr><td>shiftGraspGear<br/></td><td></td></tr>
<tr><td>shiftIntoGraspGear1<br/></td><td></td></tr>
<tr><td>shiftIntoGraspGear2<br/></td><td></td></tr>
<tr><td>shiftIntoGraspGear3<br/></td><td></td></tr>
<tr><td>shiftIntoGraspGear4<br/></td><td></td></tr>
<tr><td>( ikModeIkFast 1 setCurrentIKFastMode halfImpulse setMovementStateToMoving waitUntilAtCurrentPosition ikModeService )<br/></td><td></td></tr>
<tr><td>shutdownAllNonessentialSystems<br/></td><td>Shut down all systems that are not important for streaming data, to maximize the framerate we stream.</td></tr>
<tr><td>shutdownToSensorsAndMovement<br/></td><td></td></tr>
<tr><td>silenceSonar<br/></td><td></td></tr>
<tr><td>sin<br/></td><td></td></tr>
<tr><td>size<br/></td><td>Takes a compound word on the stack and an int.  Returns the ith entry of the compound word.  Uses zero based indexing.</td></tr>
<tr><td>( slfgRebaseCore tableInit )<br/></td><td></td></tr>
<tr><td>1.000000e-03<br/></td><td></td></tr>
<tr><td>( /*
    slfgRebaseCellWidth currentPose 
  sceneInitFromEePoseScale 
  */ /* 0.5 for museum */ /* 0.25 for close */ /* 0.16 for close hi */ 5.000000e-01 &quot;slfgRebaseDesiredMapWidth&quot; store slfgRebaseDesiredMapWidth slfgRebaseCellWidth divide &quot;slfgRebaseCalculatedCellDimension&quot; store slfgRebaseCellWidth slfgRebaseCalculatedCellDimension slfgRebaseCalculatedCellDimension currentPose sceneInitFromEePoseScaleDimensions )<br/></td><td></td></tr>
<tr><td>( slfgRebaseCore tableInitNoBackground )<br/></td><td></td></tr>
<tr><td>( 5.521307e-01 setCurrentTableZ 2.053950e-01 -6.027560e-01 -1.637970e-01 0.000000e+00 1.000000e+00 0.000000e+00 0.000000e+00 createEEPose &quot;slfgTopPoint&quot; store 3.395030e-01 -4.686480e-01 -2.779150e-01 3.573880e-01 -8.628120e-01 1.368220e-01 3.303180e-01 createEEPose &quot;slfgFrontLeftPoint&quot; store 3.500900e-02 -7.271800e-01 -2.775470e-01 8.965700e-01 3.713710e-01 2.229720e-01 -9.235800e-02 createEEPose &quot;slfgBackRightPoint&quot; store /*


    -0.023189 -0.671408 -0.255637 0.661075 0.690562 0.202508 0.212354 createEEPose
    &quot;slfgBackPoint&quot;
  store
*/ )<br/></td><td></td></tr>
<tr><td>slide<br/>&apos;<br/></td><td>Moves a word from the call stack to the data stack.</td></tr>
<tr><td>slip<br/></td><td>Moves a word from the data stack to the call stack.</td></tr>
<tr><td>( 1 changeToHeight currentPose eePosePZ &quot;thisZ&quot; store -5.062500e-01 3.750000e-01 thisZ -3.612000e-02 9.993460e-01 1.199000e-03 -1.060000e-03 createEEPose -5.312500e-01 5.500000e-01 thisZ -3.612000e-02 9.993460e-01 1.199000e-03 -1.060000e-03 createEEPose -3.812500e-01 4.750000e-01 thisZ -3.612000e-02 9.993460e-01 1.199000e-03 -1.060000e-03 createEEPose -4.125000e-01 6.937500e-01 thisZ -3.612000e-02 9.993460e-01 1.199000e-03 -1.060000e-03 createEEPose -2.812500e-01 5.750000e-01 thisZ -3.612000e-02 9.993460e-01 1.199000e-03 -1.060000e-03 createEEPose -2.750000e-01 8.125000e-01 thisZ -3.612000e-02 9.993460e-01 1.199000e-03 -1.060000e-03 createEEPose -1.437500e-01 6.437500e-01 thisZ -3.612000e-02 9.993460e-01 1.199000e-03 -1.060000e-03 createEEPose -7.500000e-02 8.937500e-01 thisZ -3.612000e-02 9.993460e-01 1.199000e-03 -1.060000e-03 createEEPose 2.500000e-02 7.000000e-01 thisZ -3.612000e-02 9.993460e-01 1.199000e-03 -1.060000e-03 createEEPose 1.250000e-01 8.812500e-01 thisZ -3.612000e-02 9.993460e-01 1.199000e-03 -1.060000e-03 createEEPose 1.812500e-01 6.875000e-01 thisZ -3.612000e-02 9.993460e-01 1.199000e-03 -1.060000e-03 createEEPose 3.375000e-01 8.375000e-01 thisZ -3.612000e-02 9.993460e-01 1.199000e-03 -1.060000e-03 createEEPose 3.500000e-01 6.062500e-01 thisZ -3.612000e-02 9.993460e-01 1.199000e-03 -1.060000e-03 createEEPose 5.062500e-01 7.250000e-01 thisZ -3.612000e-02 9.993460e-01 1.199000e-03 -1.060000e-03 createEEPose 4.687500e-01 4.687500e-01 thisZ -3.612000e-02 9.993460e-01 1.199000e-03 -1.060000e-03 createEEPose 6.375000e-01 5.562500e-01 thisZ -3.612000e-02 9.993460e-01 1.199000e-03 -1.060000e-03 createEEPose 5.375000e-01 2.937500e-01 thisZ -3.612000e-02 9.993460e-01 1.199000e-03 -1.060000e-03 createEEPose 7.250000e-01 3.937500e-01 thisZ -3.612000e-02 9.993460e-01 1.199000e-03 -1.060000e-03 createEEPose 6.625000e-01 2.187500e-01 thisZ -3.612000e-02 9.993460e-01 1.199000e-03 -1.060000e-03 createEEPose )<br/></td><td></td></tr>
<tr><td>( 1 changeToHeight currentPose eePosePZ &quot;thisZ&quot; store -5.062500e-01 -3.750000e-01 thisZ -3.612000e-02 9.993460e-01 1.199000e-03 -1.060000e-03 createEEPose -5.312500e-01 -5.500000e-01 thisZ -3.612000e-02 9.993460e-01 1.199000e-03 -1.060000e-03 createEEPose -3.812500e-01 -4.750000e-01 thisZ -3.612000e-02 9.993460e-01 1.199000e-03 -1.060000e-03 createEEPose -4.125000e-01 -6.937500e-01 thisZ -3.612000e-02 9.993460e-01 1.199000e-03 -1.060000e-03 createEEPose -2.812500e-01 -5.750000e-01 thisZ -3.612000e-02 9.993460e-01 1.199000e-03 -1.060000e-03 createEEPose -2.750000e-01 -8.125000e-01 thisZ -3.612000e-02 9.993460e-01 1.199000e-03 -1.060000e-03 createEEPose -1.437500e-01 -6.437500e-01 thisZ -3.612000e-02 9.993460e-01 1.199000e-03 -1.060000e-03 createEEPose -7.500000e-02 -8.937500e-01 thisZ -3.612000e-02 9.993460e-01 1.199000e-03 -1.060000e-03 createEEPose 2.500000e-02 -7.000000e-01 thisZ -3.612000e-02 9.993460e-01 1.199000e-03 -1.060000e-03 createEEPose 1.250000e-01 -8.812500e-01 thisZ -3.612000e-02 9.993460e-01 1.199000e-03 -1.060000e-03 createEEPose 1.812500e-01 -6.875000e-01 thisZ -3.612000e-02 9.993460e-01 1.199000e-03 -1.060000e-03 createEEPose 3.375000e-01 -8.375000e-01 thisZ -3.612000e-02 9.993460e-01 1.199000e-03 -1.060000e-03 createEEPose 3.500000e-01 -6.062500e-01 thisZ -3.612000e-02 9.993460e-01 1.199000e-03 -1.060000e-03 createEEPose 5.062500e-01 -7.250000e-01 thisZ -3.612000e-02 9.993460e-01 1.199000e-03 -1.060000e-03 createEEPose 4.687500e-01 -4.687500e-01 thisZ -3.612000e-02 9.993460e-01 1.199000e-03 -1.060000e-03 createEEPose 6.375000e-01 -5.562500e-01 thisZ -3.612000e-02 9.993460e-01 1.199000e-03 -1.060000e-03 createEEPose 5.375000e-01 -2.937500e-01 thisZ -3.612000e-02 9.993460e-01 1.199000e-03 -1.060000e-03 createEEPose 7.250000e-01 -3.937500e-01 thisZ -3.612000e-02 9.993460e-01 1.199000e-03 -1.060000e-03 createEEPose 6.625000e-01 -2.187500e-01 thisZ -3.612000e-02 9.993460e-01 1.199000e-03 -1.060000e-03 createEEPose )<br/></td><td></td></tr>
<tr><td>( sceneClearPredictedObjects clearMapForPatrol clearBlueBoxMemories socialFeedbackTakeScene scenePredictBestObject scenePredictBestObject scenePredictBestObject tableAddBlueBoxesForSceneObjects )<br/></td><td></td></tr>
<tr><td>( halfImpulse assumeCrane1 assumeBeeHome 1 changeToHeight waitUntilAtCurrentPosition 1.000000e-01 setSpeed 5.000000e-02 setW1GoThresh /* clear it all */ sceneClearObservedMap clearStreamBuffers /* turn streaming on, no disk streaming */ shutdownToSensorsAndMovement disableDiskStreaming /* Pose Range Image Joints Word Label */ 1 0 1 0 0 0 setSisFlags endArgs leftOrRightArm &quot;right&quot; equals oP socialFeedbackMapRightWorkspace cP oP leftOrRightArm &quot;left&quot; equals oP socialFeedbackMapLeftWorkspace cP oP &quot;Neither left or right arm.&quot; leftOrRightArm pauseStackExecution cP ifte cP ifte moveEeToPoseWord waitUntilAtCurrentPosition activateSensorStreaming 1 changeToHeight followPath /* turn streaming off */ deactivateSensorStreaming bringUpAllNonessentialSystems tableUpdateMaps 700 &quot;tableSpiralStreamTakeSceneSamples&quot; store tableUpdateSpiralCoreIntegrate )<br/></td><td></td></tr>
<tr><td>spawnTargetClassAtEndEffector<br/></td><td></td></tr>
<tr><td>spawnTargetMasterSpriteAtEndEffector<br/></td><td></td></tr>
<tr><td>spinForSeconds<br/></td><td></td></tr>
<tr><td>spinForSecondsA<br/></td><td></td></tr>
<tr><td>spinForSecondsInit<br/></td><td></td></tr>
<tr><td>squeezeDuck<br/></td><td></td></tr>
<tr><td>start<br/></td><td></td></tr>
<tr><td>start3dGraspAnnotation<br/></td><td></td></tr>
<tr><td>start3dGraspAnnotationNoChange<br/></td><td></td></tr>
<tr><td>stay<br/></td><td></td></tr>
<tr><td>stayNoRoll<br/></td><td></td></tr>
<tr><td>stayZOnly<br/></td><td></td></tr>
<tr><td>stereoCalculate<br/></td><td></td></tr>
<tr><td>stereoDisplay<br/></td><td></td></tr>
<tr><td>stereoPair<br/></td><td></td></tr>
<tr><td>stereoPairCache1<br/></td><td></td></tr>
<tr><td>stereoPairCache2<br/></td><td></td></tr>
<tr><td>stereoPrep<br/></td><td></td></tr>
<tr><td>store<br/></td><td>Create a new variable.  Usage  &lt;value&gt; &quot;&lt;name&gt;&quot; store.  After that you can say &lt;name&gt; and it will push its contents on the call stack.</td></tr>
<tr><td>streamBasePoseForCurrentImage<br/></td><td>Push the arm pose for the current image in the stream buffer.</td></tr>
<tr><td>streamCenterCropAsFocusedClass<br/></td><td></td></tr>
<tr><td>streamCropsAsFocusedClass<br/></td><td></td></tr>
<tr><td>streamDisableAllSisFlags<br/></td><td>Enable all SIS flags.</td></tr>
<tr><td>streamDiskStreaming<br/></td><td></td></tr>
<tr><td>streamEnableAllSisFlags<br/></td><td>Enable all SIS flags.</td></tr>
<tr><td>streamEnableSisImageAndPoses<br/></td><td>Configure Ein to stream images and poses only.</td></tr>
<tr><td>streamGraspResult<br/></td><td></td></tr>
<tr><td>streamImageBufferCurrentIdx<br/></td><td></td></tr>
<tr><td>streamImageBufferSize<br/></td><td></td></tr>
<tr><td>streamImageSpeed<br/></td><td></td></tr>
<tr><td>streamIncrementImageStreamBuffer<br/></td><td>Increments the current location in the image stream buffer.  The new default word, which does no load and no kick.</td></tr>
<tr><td>streamJointBufferSize<br/></td><td></td></tr>
<tr><td>streamLabel<br/></td><td></td></tr>
<tr><td>streamLabelBufferSize<br/></td><td></td></tr>
<tr><td>streamPlayStreamBuffer<br/></td><td>Play back the stream buffer.  Plays back at a constant rate; is not careful to wait the &apos;correct&apos; amount of time between frames.</td></tr>
<tr><td>streamPoseBufferSize<br/></td><td></td></tr>
<tr><td>streamPoseForCurrentImage<br/></td><td>Push the pose for the current image in the stream buffer.</td></tr>
<tr><td>streamRangeBufferSize<br/></td><td></td></tr>
<tr><td>streamRenderStreamWindow<br/></td><td>Render the stream buffer window.</td></tr>
<tr><td>streamScanCentered<br/></td><td></td></tr>
<tr><td>streamSetDiskStreaming<br/></td><td></td></tr>
<tr><td>streamSetImageBufferCurrentIdx<br/></td><td></td></tr>
<tr><td>streamSetSisImage<br/></td><td></td></tr>
<tr><td>streamSetSisJoints<br/></td><td></td></tr>
<tr><td>streamSetSisLabel<br/></td><td></td></tr>
<tr><td>streamSetSisPose<br/></td><td></td></tr>
<tr><td>streamSetSisRange<br/></td><td></td></tr>
<tr><td>streamSetSisWord<br/></td><td></td></tr>
<tr><td>streamSisImage<br/></td><td></td></tr>
<tr><td>streamSisJoints<br/></td><td></td></tr>
<tr><td>streamSisLabel<br/></td><td></td></tr>
<tr><td>streamSisPose<br/></td><td></td></tr>
<tr><td>streamSisRange<br/></td><td></td></tr>
<tr><td>streamSisWord<br/></td><td></td></tr>
<tr><td>streamSpin<br/></td><td></td></tr>
<tr><td>streamWordBufferSize<br/></td><td></td></tr>
<tr><td>streamWriteBuffersToDisk<br/></td><td>Write what is in the stream buffer to disk.</td></tr>
<tr><td>streamedAccumulatedDensity<br/></td><td></td></tr>
<tr><td>streamedDensity<br/></td><td></td></tr>
<tr><td>subscribeCameraParameterTrackerToRosOut<br/></td><td>Subscribe to rosout.  We don&apos;t want to do this for long periods since it&apos;s very noisy, but this is how we see the current camera parameters, since they aren&apos;t published any other way.</td></tr>
<tr><td>sum<br/>join<br/></td><td>Pops a compound word; sums the entries; pushes the result.  Usage:  ( 1 1 1 ) sum -&gt; 3.</td></tr>
<tr><td>swap<br/></td><td></td></tr>
<tr><td>( oP oXUp cP 30 replicateWord oP localYDown cP 25 replicateWord oP oXUp cP 30 replicateWord waitUntilAtCurrentPosition oP zUp cP 10 replicateWord waitUntilAtCurrentPosition oP oXDown cP 30 replicateWord oP localYUp cP 20 replicateWord oP oXDown cP 30 replicateWord waitUntilAtCurrentPosition oP zDown cP 10 replicateWord )<br/></td><td></td></tr>
<tr><td>( oP oXUp cP 30 replicateWord oP localYDown cP 20 replicateWord oP oXUp cP 30 replicateWord waitUntilAtCurrentPosition oP zUp cP 10 replicateWord waitUntilAtCurrentPosition oP oXDown cP 30 replicateWord oP localYUp cP 20 replicateWord oP oXDown cP 30 replicateWord waitUntilAtCurrentPosition oP zDown cP 10 replicateWord )<br/></td><td></td></tr>
<tr><td>( )<br/></td><td></td></tr>
<tr><td>( oP oXUp cP 30 replicateWord )<br/></td><td></td></tr>
<tr><td>( oP oXDown cP 30 replicateWord )<br/></td><td></td></tr>
<tr><td>switchSonarLed<br/></td><td></td></tr>
<tr><td>synchronicServo<br/></td><td></td></tr>
<tr><td>synchronicServoA<br/></td><td></td></tr>
<tr><td>synchronicServoDoNotTakeClosest<br/></td><td></td></tr>
<tr><td>synchronicServoRepeat<br/></td><td></td></tr>
<tr><td>synchronicServoTakeClosest<br/></td><td></td></tr>
<tr><td>1<br/></td><td></td></tr>
<tr><td>1<br/></td><td></td></tr>
<tr><td>50<br/></td><td></td></tr>
<tr><td>( /* needs an update */ clearMapForPatrol lock3dGraspBase c3dPoseBase eePosePZ &quot;tableScanBasePZ&quot; store tableShortServoToFocusedSceneObject waitUntilAtCurrentPosition setMovementStateToMoving comeToStop tableShortServoToFocusedSceneObject waitUntilAtCurrentPosition setMovementStateToMoving comeToStop tableShortServoToFocusedSceneObject waitUntilAtCurrentPosition setMovementStateToMoving comeToStop currentPose tableScanBasePZ setEEPosePZ &quot;tableScanBase&quot; store scan_swapToBars gradientServo prepareForGraspFromMemory currentPose tableScanBasePZ pickFlushFactor plus setEEPosePZ &quot;tableScanNewGrasp&quot; store scan_restoreFromBars tableScanBase setC3dPoseBase tableScanNewGrasp add3dGraspPoseWord writeFocusedClassGrasps )<br/></td><td></td></tr>
<tr><td>( /* XXX if the number of classes is zero, how does this work out? */ clearMapForPatrol lock3dGraspBase c3dPoseBase eePosePZ &quot;tableScanBasePZ&quot; store oP tableSpiralServoToBestSceneObject quarterImpulse waitUntilAtCurrentPosition cP 2 replicateWord currentPose tableScanBasePZ setEEPosePZ &quot;tableScanBase&quot; store tableSwapToBlocks oP tableSpiralServoToBestSceneObject quarterImpulse waitUntilAtCurrentPosition setMovementStateToMoving comeToStop cP 2 replicateWord quarterTurn /* this gets into orientation to pick so it will be saved next, since this is a block grasp */ currentPose tableScanBasePZ pickFlushFactor plus setEEPosePZ &quot;tableScanNewGrasp&quot; store tableRestoreFromBlocks tableScanBase setC3dPoseBase tableScanNewGrasp add3dGraspPoseWord writeFocusedClassGrasps )<br/></td><td></td></tr>
<tr><td>( /* XXX if the number of classes is zero, how does this work out? */ clearMapForPatrol lock3dGraspBase c3dPoseBase eePosePZ &quot;tableScanBasePZ&quot; store currentPose tableScanBasePZ setEEPosePZ &quot;tableScanBase&quot; store tableSwapToBlocks sceneClearPredictedObjects tableUpdateMaps tableServoToFocusedSceneObject waitUntilAtCurrentPosition setMovementStateToMoving comeToStop quarterTurn /* this gets into orientation to pick so it will be saved next, since this is a block grasp */ currentPose tableScanBasePZ pickFlushFactor plus setEEPosePZ &quot;tableScanNewGrasp&quot; store tableRestoreFromBlocks tableScanBase setC3dPoseBase tableScanNewGrasp add3dGraspPoseWord writeFocusedClassGrasps )<br/></td><td></td></tr>
<tr><td>( /* XXX */ /* this is meant to be run after a sufficiently broad and detailed scan and for the moment interacts with catScan5 variables */ currentPose &quot;catScan5Pos&quot; store tableSpiralIsNewComponentPseudoGeometricInPlace oP catScan5Pos moveEeToPoseWord waitUntilAtCurrentPosition /* tableFullScan */ zeroGOff setPlaceModeToHold setIdleModeToEmpty setBoundingBoxModeToMapping tenthImpulse 1 changeToHeight shiftIntoGraspGear1 waitUntilAtCurrentPosition initializeAndFocusOnNewClass /* like recapture without taking a scene */ tableRecaptureServoInPlace /* */ /* 
      currentPose 

      waitGetCurrentWaitMode
    1 waitSetCurrentWaitMode
    scanObjectScene
    waitSetCurrentWaitMode

    moveEeToPoseWord waitUntilAtCurrentPosition 
*/ writeFocusedClass createCachedClassifierFromClassLabels trainAndWriteFocusedClassKnn clearClass3dGrasps writeFocusedClassGrasps /*
    tableAddBlockGrasp
    */ tableAddBlockGraspInPlace /*
    */ setPlaceModeToHold clearMapForPatrol setPickModeToLearningAlgorithmC tableMapBestAndPickInPlace writeFocusedClassGrasps playWorkspace moveEeToPoseWord waitUntilAtCurrentPosition isGripperGripping oP currentPose scan_gripperTouchTableZ setEEPosePZ moveEeToPoseWord quarterImpulse 1.000000e-02 setGridSize oP zUp cP catScan_dropHeight replicateWord setMovementStateToMoving comeToStop cP ift openGripper cP oP /* sets the target class */ setPlaceModeToHold clearMapForPatrol /*
    tableAddBlockGrasp
    */ tableAddBlockGraspInPlace /*
    */ /* tablePickWithAddedGrasp */ setPickModeToLearningAlgorithmC tableMapBestAndPickInPlace writeFocusedClassGrasps setGridSizeCoarse departureSpeed oP zUp cP 10 replicateWord setMovementStateToMoving comeToStop isGripperGripping oP playWorkspace moveEeToPoseWord currentPose scan_gripperTouchTableZ setEEPosePZ moveEeToPoseWord quarterImpulse 1.000000e-02 setGridSize oP zUp cP catScan_dropHeight replicateWord setMovementStateToMoving comeToStop cP ift openGripper cP ifte )<br/></td><td></td></tr>
<tr><td>( 0 &quot;tableCounter&quot; store oP tableCounter scenePushNumSceneObjects langle cP oP tableCounter sceneMapSceneObject publishRecognizedObjectArrayFromBlueBoxMemory tableCounter 1 plus &quot;tableCounter&quot; store cP whileCollapsed )<br/></td><td></td></tr>
<tr><td>( 2.000000e-02 &quot;viewSynthApertureWidth&quot; store 1.000000e-02 &quot;viewSynthAperturePlane&quot; store )<br/></td><td></td></tr>
<tr><td>2.000000e-02<br/></td><td></td></tr>
<tr><td>1.000000e-02<br/></td><td></td></tr>
<tr><td>2.000000e-02<br/></td><td></td></tr>
<tr><td>4.000000e-02<br/></td><td></td></tr>
<tr><td>5.500000e-02<br/></td><td></td></tr>
<tr><td>0<br/></td><td></td></tr>
<tr><td>( sceneClearObservedMap oP sceneUpdateObservedFromWrist cP 10 replicateWord tableCaptureCore )<br/></td><td></td></tr>
<tr><td>( sceneComposePredictedMap sceneUpdateDiscrepancy sceneDensityFromDiscrepancy sceneGrabDiscrepantCropAsClassDefaultThresh sceneGrabDiscrepantCropAsClass )<br/></td><td></td></tr>
<tr><td>50<br/></td><td></td></tr>
<tr><td>3<br/></td><td></td></tr>
<tr><td>0.000000e+00<br/></td><td></td></tr>
<tr><td>0<br/></td><td></td></tr>
<tr><td>( sceneClearPredictedObjects tablePredictAndRenderBest clearBlueBoxMemories 0 sceneMapSceneObject )<br/></td><td></td></tr>
<tr><td>( sceneLoadFocusedObjectModel tableUpdateClassScene )<br/></td><td></td></tr>
<tr><td>5.000000e-01<br/></td><td></td></tr>
<tr><td>( tableDribblePrep tableDribbleCore )<br/></td><td></td></tr>
<tr><td>( oP shoreUp currentPose dup tableMapFocusedAndPick moveEeToPoseWord tableDribblePlace moveEeToPoseWord waitUntilAtCurrentPosition cP time )<br/></td><td></td></tr>
<tr><td>( oP shoreUp currentPose dup tableMapFocusedAndPick moveEeToPoseWord tableDribblePlace moveEeToPoseWord waitUntilAtCurrentPosition cP time )<br/></td><td></td></tr>
<tr><td>( isGripperGripping oP perturbPosition waitUntilAtCurrentPosition 1.500000e-01 setSpeed pressDown openGripper 1.000000e-02 setGridSize oP zUp cP 5 replicateWord waitUntilAtCurrentPosition cP ift )<br/></td><td></td></tr>
<tr><td>( setPlaceModeToHold 0 waitSetCurrentWaitMode /*
  51 sceneSetAngularApertureRows 51 sceneSetAngularApertureCols
  */ )<br/></td><td></td></tr>
<tr><td>( &quot;/home/aibo/catkin_ws/src/ein/default/objects/scene_eval_set&quot; setClassLabelsObjectFolderAbsolute setPickModeToStaticMarginals setPlaceModeToHold oP playWorkspace scan_findObjectAfterDrop tableMapBestAndPickInPlace playWorkspace moveEeToPoseWord waitUntilAtCurrentPosition 5.000000e-02 perturbPositionScale waitUntilAtCurrentPosition &quot;EVAL CLASSIFICATION &quot; focusedClassLabel plus print pressUntilEffortInit 4.000000e-02 setSpeed pressUntilEffortCombo openGripper liftArm cP 10 replicateWord )<br/></td><td></td></tr>
<tr><td>( /* turn streaming off */ deactivateSensorStreaming bringUpAllNonessentialSystems tableUpdateMaps quarterImpulse tableUpdateSpiralPos moveEeToPoseWord waitUntilAtCurrentPosition /* integrate results */ /* this actually needs to happen after movement so position is still correct for FIXATION calibrators */ /*
  tableUpdateSpiralCoreIntegrate
  */ tableReconstructFromStream tableUpdateMaps )<br/></td><td></td></tr>
<tr><td>( quarterImpulse waitUntilAtCurrentPosition 1.000000e-02 setW1GoThresh 1.625000e-02 &quot;tableSpiralGridSize&quot; store 5.000000e-02 &quot;tableSpiralMoveSpeed&quot; store 6 &quot;tableUpdateSpiralN&quot; store currentPose &quot;tableUpdateSpiralPos&quot; store /* clear it all */ sceneClearObservedMap clearStreamBuffers /* turn streaming on, no disk streaming */ shutdownToSensorsAndMovement disableDiskStreaming /* Pose Range Image Joints Word Label */ 1 1 1 0 0 0 setSisFlags activateSensorStreaming )<br/></td><td></td></tr>
<tr><td>( tableFivePointThreeWidthIsNewComponentNormalizedSumOfLogs )<br/></td><td></td></tr>
<tr><td>( numClasses 0 rangle oP 5.000000e-01 &quot;tableNewComponentThresh&quot; store sceneClearPredictedObjects sceneClearObservedMap tableFivePointThreeWidthTakeScene /*
    tableShortTakeScene
    */ tableUpdateMaps endStackCollapseNoop 1.000000e-01 waitForSeconds /* pauseStackExecution */ /*
	  scenePushTotalDiscrepancy 
    */ scenePushTotalDiscrepancyMagnitude dup &quot;tableFivePointThreeWidthIsNewComponent: total discrepancy before &quot; swap plus print scenePredictBestObject tableUpdateMaps endStackCollapseNoop 1.000000e-01 waitForSeconds /*
	  scenePushTotalDiscrepancy 
    */ scenePushTotalDiscrepancyMagnitude dup &quot;tableFivePointThreeWidthIsNewComponent: total discrepancy after &quot; swap plus print swap divide dup &quot;tableFivePointThreeWidthIsNewComponent: after / before ratio is &quot; swap plus print tableNewComponentThresh rangle oP 1 dup &quot;tableFivePointThreeWidthIsNewComponent: IS a new component, returning &quot; swap plus print cP oP 0 dup &quot;tableFivePointThreeWidthIsNewComponent: AIN&apos;T a new component, returning &quot; swap plus print cP ifte dup &quot;tableFivePointThreeWidthIsNewComponent: returning &quot; swap plus print cP oP &quot;tableFivePointThreeWidthIsNewComponent: numClasses is 0 so returning 1&quot; 1 cP ifte )<br/></td><td></td></tr>
<tr><td>( numClasses 0 rangle oP 1.500000e-01 &quot;tableNewComponentThresh&quot; store sceneClearPredictedObjects sceneClearObservedMap /*
    tableFivePointThreeWidthTakeScene
    tableShortTakeScene
    */ tableUpdateSpiralEccentric endStackCollapseNoop 1.000000e-01 waitForSeconds /* pauseStackExecution */ /*
	  scenePushTotalDiscrepancy 
	  scenePushTotalDiscrepancyMagnitude 
    */ scenePushTotalLogDiscrepancy sceneTakeBeforeDensity dup &quot;tableFivePointThreeWidthIsNewComponent: total log discrepancy before &quot; swap plus print scenePredictBestObject tableUpdateMaps endStackCollapseNoop 1.000000e-01 waitForSeconds /*
	  scenePushTotalDiscrepancy 
	  scenePushTotalDiscrepancyMagnitude 
    */ scenePushTotalLogDiscrepancy sceneTakeAfterDensity dup &quot;tableFivePointThreeWidthIsNewComponent: total log discrepancy after &quot; swap plus print &quot;tableFivePointThreeWidthIsNewComponentNormalizedSum_after&quot; store &quot;tableFivePointThreeWidthIsNewComponentNormalizedSum_before&quot; store tableFivePointThreeWidthIsNewComponentNormalizedSum_before &quot;tableFivePointThreeWidthIsNewComponent: total discrepancy before is &quot; swap plus print tableFivePointThreeWidthIsNewComponentNormalizedSum_after tableFivePointThreeWidthIsNewComponentNormalizedSum_before plus &quot;tableFivePointThreeWidthIsNewComponentNormalizedSum_sum&quot; store tableFivePointThreeWidthIsNewComponentNormalizedSum_sum &quot;tableFivePointThreeWidthIsNewComponent: before after sum is&quot; swap plus print tableFivePointThreeWidthIsNewComponentNormalizedSum_after tableFivePointThreeWidthIsNewComponentNormalizedSum_sum divide &quot;tableFivePointThreeWidthIsNewComponentNormalizedSum_ratio&quot; store tableFivePointThreeWidthIsNewComponentNormalizedSum_ratio &quot;tableFivePointThreeWidthIsNewComponent: after / sum ratio is &quot; swap plus print tableFivePointThreeWidthIsNewComponentNormalizedSum_ratio tableNewComponentThresh rangle oP 1 dup &quot;tableFivePointThreeWidthIsNewComponent: IS a new component, returning &quot; swap plus print cP oP 0 dup &quot;tableFivePointThreeWidthIsNewComponent: AIN&apos;T a new component, returning &quot; swap plus print cP ifte dup &quot;tableFivePointThreeWidthIsNewComponent: returning &quot; swap plus print cP oP &quot;tableFivePointThreeWidthIsNewComponent: numClasses is 0 so returning 1&quot; 1 cP ifte sceneHighPrecisionBeforeAfterDiffOfLogs &quot;tableFivePointThreeWidthIsNewComponent: high precision diff &quot; swap plus print )<br/></td><td></td></tr>
<tr><td>( tableFivePointThreeWidthTakeScene scenePredictBestObject tableUpdateMaps )<br/></td><td></td></tr>
<tr><td>( sceneClearObservedMap tableUpdateFivePointThreeWidth tableUpdateMaps )<br/></td><td></td></tr>
<tr><td>( &quot;tableFullScan: starting&quot; print tableQuickScan 1 waitSetCurrentWaitMode scanObjectScene 0 waitSetCurrentWaitMode writeFocusedClass )<br/></td><td></td></tr>
<tr><td>( streamImageBufferSize tableReconstructStreamTakeSceneSamples min &quot;tableRSTSSMax&quot; store /* find the right stride */ streamImageBufferSize tableRSTSSMax divide ceil &quot;tableSpiralStreamTakeSceneStride&quot; store /* don&apos;t try to use more images than you have */ streamImageBufferSize tableSpiralStreamTakeSceneStride divide floor &quot;tableRSTSSMax&quot; store streamImageBufferSize print tableRSTSSMax print tableSpiralStreamTakeSceneStride print rewindImageStreamBufferNLNK oP 3.880000e-01 rayBufferPopulateFromImageBuffer oP incrementImageStreamBufferNoLoadNoKick cP tableSpiralStreamTakeSceneStride replicateWord /*
    sceneRecalculateObservedMusAndSigmas
    sceneRenderObservedMap
*/ endStackCollapseNoop cP tableRSTSSMax replicateWord )<br/></td><td></td></tr>
<tr><td>( /* turn streaming on, no disk streaming */ shutdownToSensorsAndMovement disableDiskStreaming /* Pose Range Image Joints Word Label */ 1 1 1 0 0 0 setSisFlags activateSensorStreaming /* spiral scan pattern */ tableSpiralMoveSpeed setSpeed tableSpiralGridSize setGridSize /* shiftIntoGraspGear1 waitUntilAtCurrentPosition */ 1 &quot;tableUpdateSpiralIdx&quot; store oP tableUpdateSpiralIdx tableUpdateSpiralN langle cP oP oP localXUp waitUntilAtCurrentPosition cP tableUpdateSpiralIdx replicateWord oP 2.000000e-01 waitForSeconds cP doUntilAtCurrentPosition oP localYUp waitUntilAtCurrentPosition cP tableUpdateSpiralIdx replicateWord oP 2.000000e-01 waitForSeconds cP doUntilAtCurrentPosition oP localXDown waitUntilAtCurrentPosition cP tableUpdateSpiralIdx 1 plus replicateWord oP 2.000000e-01 waitForSeconds cP doUntilAtCurrentPosition oP localYDown waitUntilAtCurrentPosition cP tableUpdateSpiralIdx 1 plus replicateWord oP 2.000000e-01 waitForSeconds cP doUntilAtCurrentPosition &quot;tableUpdateSpiralCoreNoClean&quot; print tableUpdateSpiralIdx 2 plus &quot;tableUpdateSpiralIdx&quot; store cP whileCollapsed /* turn streaming off */ deactivateSensorStreaming bringUpAllNonessentialSystems )<br/></td><td></td></tr>
<tr><td>( quarterImpulse waitUntilAtCurrentPosition 5.000000e-02 &quot;tableSpiralMoveSpeed&quot; store 1.000000e-02 setW1GoThresh /*
  16 &quot;tableUpdateSpiralN&quot; store
  0.01625 &quot;tableSpiralGridSize&quot; store

  32 &quot;tableUpdateSpiralN&quot; store
  0.008125 &quot;tableSpiralGridSize&quot; store

  32 2.0 * &quot;tableUpdateSpiralN&quot; store
  0.008125 2.0 divide &quot;tableSpiralGridSize&quot; store
  */ 32 &quot;tableUpdateSpiralN&quot; store 8.125000e-03 &quot;tableSpiralGridSize&quot; store currentPose &quot;tableUpdateSpiralPos&quot; store /* clear it all */ sceneClearObservedMap clearStreamBuffers tableFusionSpiralCoreNoClean tableUpdateMaps quarterImpulse tableUpdateSpiralPos moveEeToPoseWord waitUntilAtCurrentPosition /* integrate results */ /* this actually needs to happen after movement so position is still correct for FIXATION calibrators */ /*
  tableUpdateSpiralCoreIntegrate
  */ tableReconstructFromStream tableUpdateMaps )<br/></td><td></td></tr>
<tr><td>( oP 1 cP oP neutralFace -1 1.000000e-01 setHeadPanTargetSpeed 4.000000e+00 waitForSeconds 1 1.000000e-01 setHeadPanTargetSpeed 4.000000e+00 waitForSeconds 0 1.000000e-01 setHeadPanTargetSpeed 4.000000e+00 waitForSeconds happyFace oP nod 1.000000e+00 waitForSeconds cP 4 replicateWord oP happyFace 1.000000e-01 waitForSeconds sadFace 1.000000e-01 waitForSeconds cP 2 replicateWord oP publishWristViewToFace 1.000000e+00 2.000000e+01 divide 3.000000e+00 times waitForSeconds cP 80 replicateWord cP whileCollapsed )<br/></td><td></td></tr>
<tr><td>( tableDribblePrep oP 1 cP oP tableDribbleCore endStackCollapseNoop cP whileCollapsed )<br/></td><td></td></tr>
<tr><td>( tableDribblePrep oP 1 cP oP tableDribbleBestCore endStackCollapseNoop cP whileCollapsed )<br/></td><td></td></tr>
<tr><td>( 1 setSnapToFlushGrasp setPlaceModeToHold setBoundingBoxModeToMapping clearMapForPatrol 100 setGripperMovingForce openGripper 800 &quot;tableReconstructStreamTakeSceneSamples&quot; store /*
  sceneSetDiscrepancyModePoint
*/ initializeAndFocusOnTempClass catScan5UpdatePlayBg oP 1 cP oP pickFromInputPile2 playWithObject moveToOutputPile2 cP whileCollapsed )<br/></td><td></td></tr>
<tr><td>( &quot;tableInit RUNNING&quot; print tableInitNoBackground currentScene bgRAM sceneCopyGaussianMap sceneSetBackgroundMap sceneRenderScene tableRegularizeBackground bg sceneInitDefaultBackgroundMap bg sceneLoadBackgroundMap currentBackgroundMap sceneCopyGaussianMap &quot;bgRAM&quot; store ) &quot;Initialize scene parameters.&quot; setHelp<br/></td><td>Initialize scene parameters.</td></tr>
<tr><td>( &quot;init NO BACK&quot; print sceneSetDiscrepancyModePoint tableDefaultScoreThresh sceneSetScoreThresh /* 75 */ tableCellCountThreshold sceneSetCellCountThreshold sceneClearObservedMap sceneClearPredictedObjects ) &quot;Initialize scene parameters, no background map reload.&quot; setHelp<br/></td><td>Initialize scene parameters, no background map reload.</td></tr>
<tr><td>( sceneClearObservedMap 10000 sceneSetDiscrepancySearchDepth 5.000000e-01 sceneSetScoreThresh sceneInit 128 128 128 sceneLoadMonochromeBackground &quot;bgtable&quot; sceneSaveBackgroundMap &quot;bgtable&quot; sceneLoadObservedMap sceneClearObservedMap /* tableRegularizeBackground */ /* tableLoadAverageModel */ tableLoadFirstModel sceneClearPredictedObjects tableUpdateMaps sceneRenderObservedMap /* sceneScoreThresh sceneCropToDiscrepantRegion */ )<br/></td><td></td></tr>
<tr><td>( /*
  &quot;scene&quot; import tableLenticularAutoFocus slfgRebase tableReconstructWithoutZ
  */ 620 sceneSetAngularApertureCols slfgRebaseCellWidth 1.104000e+01 times &quot;lensArraySpacingX&quot; store /* choosing a wider gap captures more angular information and incurs spatial blur */ -3.200000e-01 &quot;lensArrayGap&quot; store -8.000000e-02 &quot;lensArrayGap&quot; store 1.000000e-03 &quot;slfgRebaseCellWidth&quot; store /*
    slfgRebaseCellWidth 11.04 times 
    */ slfgRebaseCellWidth 1.105000e+01 times &quot;lensArraySpacingX&quot; store 0.000000e+00 lensArraySpacingX times &quot;lensArrayPhaseX&quot; store /*
    lensArrayGap 100.0 times 
    */ lensArrayGap 1.000000e+02 times &quot;lensArrayStrengthX&quot; store )<br/></td><td></td></tr>
<tr><td>( tableReconstructWithZTopZ 3.880000e-01 divide 3.000000e-03 times &quot;slfgRebaseCellWidth&quot; store slfgRebase 50 &quot;lensArraySize&quot; store /*
  12.00 &quot;lensArrayStrength&quot; store
  -0.16 &quot;lensArrayGap&quot; store
*/ 2.400000e+01 &quot;lensArrayStrength&quot; store -3.200000e-01 &quot;lensArrayGap&quot; store 3.583000e-01 &quot;tableReconstructWithZTopZ&quot; store 1000 &quot;tableReconstructStreamTakeSceneSamples&quot; store 351 sceneSetAngularApertureRows 351 sceneSetAngularApertureCols )<br/></td><td></td></tr>
<tr><td>( /* takes a string */ sceneLoadFocusedSceneModel )<br/></td><td></td></tr>
<tr><td>( oP incrementTargetClass sceneClearPredictedObjects 0 0 0 sceneAddPredictedFocusedObject tableUpdateMaps 1.000000e+00 sceneAddDiscrepantPredictedToObserved cP numClasses replicateWord )<br/></td><td></td></tr>
<tr><td>( 0 setFocusedClassIdx sceneClearPredictedObjects 0 0 0 sceneAddPredictedFocusedObject tableUpdateMaps 1.000000e+00 sceneAddDiscrepantPredictedToObserved )<br/></td><td></td></tr>
<tr><td>( rewindImageStreamBufferNLNK oP streamPushImageStreamIndex print imageStreamBufferLoadCurrent incrementImageStreamBufferNoLoadNoKick cP streamImageBufferSize replicateWord )<br/></td><td></td></tr>
<tr><td>( lock3dGraspBase c3dPoseBase eePosePZ &quot;tableScanBasePZ&quot; store /*
  tableReconstructServoToBestSceneObject
  */ tableSpiralServoToFocusedSceneObject waitUntilAtCurrentPosition setMovementStateToMoving comeToStop currentPose tableScanBasePZ setEEPosePZ &quot;tableScanBase&quot; store tableScanBase setC3dPoseBase &quot;Ok, check the predicted map and make sure the object was added correctly.&quot; print &quot;If it was, you can add 3d grasps.&quot; print ) &quot;Localize the focused object and prepare to annotate a 3D grasp.&quot; setHelp<br/></td><td>Localize the focused object and prepare to annotate a 3D grasp.</td></tr>
<tr><td>( lock3dGraspBase c3dPoseBase eePosePZ &quot;tableScanBasePZ&quot; store /* predicts and moves, doesn&apos;t scan */ tableServoToFocusedSceneObject waitUntilAtCurrentPosition setMovementStateToMoving comeToStop currentPose tableScanBasePZ setEEPosePZ &quot;tableScanBase&quot; store tableScanBase setC3dPoseBase &quot;Ok, check the predicted map and make sure the object was added correctly.&quot; print &quot;If it was, you can add 3d grasps.&quot; print ) &quot;Localize the focused object and prepare to annotate a 3D grasp after an observed map already exists.&quot; setHelp<br/></td><td>Localize the focused object and prepare to annotate a 3D grasp after an observed map already exists.</td></tr>
<tr><td>( /* this is not consistent with tableReconstruct routines */ sceneClearObservedMap oP waitUntilImageCallbackReceived sceneUpdateObservedFromWrist cP 5 replicateWord tableUpdateMaps )<br/></td><td></td></tr>
<tr><td>( 0 cameraSetCalibrationMode magCalGetter &quot;magCalInitial&quot; store magCalSteps 2.000000e+00 divide -1.000000e+00 times magCalDelta times magCalInitial plus &quot;magCalLo&quot; store magCalSteps 2.000000e+00 divide magCalDelta times magCalInitial plus &quot;magCalHi&quot; store magCalLo &quot;magCalThis&quot; store /*
  sceneClearDepthStack
  */ 1.000000e+15 &quot;magCalMinVar&quot; store -1 &quot;magCalMinVarMag&quot; store 0 &quot;magCalNumWins&quot; store 1.000000e-03 &quot;slfgRebaseCellWidth&quot; store slfgRebaseTable oP magCalThis magCalHi langle magCalThis magCalHi equals or cP oP magCalThis magCalSetter currentPose eePosePZ currentTableZ plus &quot;tableReconstructWithZTopZ&quot; store tableReconstructWithZ /*
    tableUpdateMaps
    */ scenePushAverageCrCbSigmaSquared dup magCalMinVar magCalMinVarImprovement minus langle oP &quot;magCalMinVar&quot; store magCalThis &quot;magCalMinVarMag&quot; store &quot;This WAS INDEED a new winner.&quot; print magCalNumWins 1 plus &quot;magCalNumWins&quot; store cP oP &quot;This was not a new winner.&quot; print pop cP ifte &quot; just tried magnification &quot; magCalThis plus print /*
    scenePushOntoDepthStack
    pauseStackExecution
    */ magCalThis magCalDelta plus &quot;magCalThis&quot; store cP whileCollapsed &quot; The winner was &quot; magCalMinVarMag &quot; with a variance of &quot; magCalMinVar plus plus plus print magCalNumWins 1 rangle oP &quot;We won more than once so setting the new value.&quot; print magCalMinVarMag magCalSetter cP oP &quot;We only won &quot; magCalNumWins &quot; times but we are SETTING THE VALUE ANYWAY.&quot; plus plus print magCalMinVarMag magCalSetter cP ifte )<br/></td><td></td></tr>
<tr><td>( openGripper waitUntilGripperNotMoving /*
  setGraspModeTo3D
  setIdleModeToEmpty
  setPlaceModeToShake
  */ clearMapForPatrol clearBlueBoxMemories tableMapBestClass scenePushNumSceneObjects 0 rangle oP &quot;tableMapBestAndPick: delivering object...&quot; print 0 scenePushSceneObjectLabel setFocusedClass deliverTargetObject cP oP &quot;tableMapBestAndPick: oops, no sceneObjects...&quot; print cP ifte )<br/></td><td></td></tr>
<tr><td>( openGripper waitUntilGripperNotMoving clearMapForPatrol clearBlueBoxMemories sceneClearPredictedObjects tableMapBestClassInPlace scenePushNumSceneObjects 0 rangle oP &quot;tableMapBestAndPick: delivering object...&quot; print 0 scenePushSceneObjectLabel setFocusedClass deliverTargetObject cP oP &quot;tableMapBestAndPick: oops, no sceneObjects...&quot; print cP ifte )<br/></td><td></td></tr>
<tr><td>( /* entering tableMapBestClass */ oP tableSpiralServoToBestSceneObject waitUntilAtCurrentPosition setMovementStateToMoving comeToStop cP 1 replicateWord 0 sceneMapSceneObject recordPreTargetLock /* prepareForGraspFromMemory */ recordPostTargetLock publishRecognizedObjectArrayFromBlueBoxMemory )<br/></td><td></td></tr>
<tr><td>( tableUpdateMaps tableServoToBestSceneObject waitUntilAtCurrentPosition setMovementStateToMoving comeToStop scenePushNumSceneObjects 0 rangle oP &quot;tableMapBestClassInPlace: mapping object...&quot; print scenePushNumSceneObjects 1 minus sceneMapSceneObject recordPreTargetLock /* prepareForGraspFromMemory */ recordPostTargetLock publishRecognizedObjectArrayFromBlueBoxMemory cP oP &quot;tableMapBestClassInPlace: oops, no sceneObjects...&quot; print cP ifte )<br/></td><td></td></tr>
<tr><td>( openGripper waitUntilGripperNotMoving /*
  setGraspModeTo3D
  setIdleModeToEmpty
  setPlaceModeToShake 
  */ clearMapForPatrol clearBlueBoxMemories tableMapFocusedClass deliverTargetObject )<br/></td><td></td></tr>
<tr><td>( openGripper waitUntilGripperNotMoving clearMapForPatrol clearBlueBoxMemories tableServoToFocusedSceneObject scenePushNumSceneObjects 0 rangle oP &quot;tableMapFocusedAndPickInPlace: mapping object...&quot; print scenePushNumSceneObjects 1 minus sceneMapSceneObject recordPreTargetLock /* prepareForGraspFromMemory */ recordPostTargetLock publishRecognizedObjectArrayFromBlueBoxMemory cP oP &quot;tableMapFocusedAndPickInPlace: oops, no sceneObjects...&quot; print cP ifte deliverTargetObject )<br/></td><td></td></tr>
<tr><td>( /* entering tableMapFocusedClass */ oP tableSpiralServoToFocusedSceneObject waitUntilAtCurrentPosition setMovementStateToMoving comeToStop cP 1 replicateWord 0 sceneMapSceneObject recordPreTargetLock /* prepareForGraspFromMemory */ recordPostTargetLock publishRecognizedObjectArrayFromBlueBoxMemory )<br/></td><td></td></tr>
<tr><td>( sceneClearPredictedObjects scenePredictFocusedObject tableUpdateMaps /*  sceneAddPredictedToObserved */ 1.000000e-01 sceneAddDiscrepantPredictedToObserved sceneRenderScene endStackCollapseNoop )<br/></td><td></td></tr>
<tr><td>( /* takes a scene object idx */ /*
  1 changeToHeight
  */ scenePushNumSceneObjects 0 equals oP pop &quot;tableMoveToSceneObject: no scene objects.&quot; print cP oP scenePushSceneObjectPose currentPose eePosePZ setEEPosePZ 0 0 0 0 1.000000e+00 0 0 createEEPose swap eePoseApplyRelativePoseTo moveEeToPoseWord cP ifte )<br/></td><td></td></tr>
<tr><td>( 0 sceneMapSceneObject recordPreTargetLock /* prepareForGraspFromMemory */ recordPostTargetLock publishRecognizedObjectArrayFromBlueBoxMemory setGraspModeTo3D deliverTargetObject )<br/></td><td></td></tr>
<tr><td>( /* takes a scene object idx */ tableMoveToSceneObject oP zDown cP 15 replicateWord oP oZUp cP 150 replicateWord oP localXUp cP 4 replicateWord )<br/></td><td></td></tr>
<tr><td>( tableShortTakeScene scenePredictBestObject tableUpdateMaps )<br/></td><td></td></tr>
<tr><td>( /* takes a string */ tableLoadAndPrepareFocusedModel tableShortTakeScene scenePredictFocusedObject tableUpdateMaps )<br/></td><td></td></tr>
<tr><td>( sceneClearPredictedObjects scenePredictFocusedObject tableUpdateMaps sceneRenderScene )<br/></td><td></td></tr>
<tr><td>( zeroGOff setPlaceModeToHold setIdleModeToEmpty setBoundingBoxModeToMapping /*
  tenthImpulse 1 changeToHeight shiftIntoGraspGear1 waitUntilAtCurrentPosition
  */ initializeAndFocusOnNewClass /*  ( tableRecaptureServo waitUntilAtCurrentPosition setMovementStateToMoving comeToStop ) 3 replicateWord */ sceneClearObservedMap sceneClearPredictedObjects /*
  tableUpdateSpiral
  */ tableTakeScene tableCaptureCore /* no additional scan */ writeFocusedClass )<br/></td><td></td></tr>
<tr><td>( &quot;scene&quot; import rayBufferInit tableFusionTakeScene 3.880000e-01 rayBufferPopulateFromImageBuffer &quot;/home/oberlin/Desktop/slfgRays/test1.ray&quot; rayBufferSaveRaw &quot;scene&quot; import rayBufferInit tableFissionStartScene tableFissionEndScene 3.880000e-01 rayBufferPopulateFromImageBuffer &quot;/home/oberlin/Desktop/slfgRays/test1.ray&quot; rayBufferSaveRaw rayBufferPopulateFromRangeBuffer &quot;/home/oberlin/Desktop/slfgRays/test1.ray&quot; rayBufferSaveRaw )<br/></td><td></td></tr>
<tr><td>( tableRecaptureServoSpiral )<br/></td><td></td></tr>
<tr><td>( sceneClearPredictedObjects tableUpdateMaps tableCaptureCore sceneClearPredictedObjects tableUpdateMaps tableServoToFocusedSceneObject waitUntilAtCurrentPosition )<br/></td><td></td></tr>
<tr><td>( sceneClearPredictedObjects tableShortTakeScene tableCaptureCore tableShortServoToFocusedSceneObject )<br/></td><td></td></tr>
<tr><td>( sceneClearPredictedObjects sceneClearObservedMap tableUpdateSpiral tableCaptureCore tableServoToFocusedSceneObject )<br/></td><td></td></tr>
<tr><td>3.425000e-01<br/></td><td></td></tr>
<tr><td>( /*

    128.0 sceneSetLightingModelStdDevY
    128.0 sceneSetLightingModelStdDevColor

    sceneUpdateObservedFromStreamBufferAtZNoRecalcAllLightModelRenderWithoutGlareRising
    sceneUpdateObservedFromStreamBufferAtZNoRecalcAllLightModelRenderGlareOnlyRising
    sceneUpdateObservedFromStreamBufferAtZNoRecalcAllSelfModelRenderGlareOnly
    sceneUpdateObservedFromStreamBufferAtZNoRecalcAllSelfModelRenderWithoutGlare

    */ &quot;lm&quot; sceneLoadLightingModelFromGaussianMapFile tableSpiralStreamTakeSceneStride tableReconstructWithZThisZ 5.000000e-01 5.000000e-01 sceneUpdateObservedFromStreamBufferAtZNoRecalcAllLightModelRenderWithoutGlare )<br/></td><td></td></tr>
<tr><td>( tableSpiralStreamTakeSceneStride tableReconstructWithZThisZ 5.000000e-01 5.000000e-01 sceneUpdateObservedFromStreamBufferAtZNoRecalcAllLightModelRenderWithoutGlareRising )<br/></td><td></td></tr>
<tr><td>( tableSpiralStreamTakeSceneStride tableReconstructWithZThisZ sceneUpdateObservedFromStreamBufferAtZNoRecalcAll )<br/></td><td></td></tr>
<tr><td>( tableSpiralStreamTakeSceneStride tableReconstructWithZThisZ 5.000000e-01 5.000000e-01 sceneUpdateObservedFromStreamBufferAtZNoRecalcAllSelfModelRenderWithoutGlare )<br/></td><td></td></tr>
<tr><td>( tableSpiralStreamTakeSceneStride tableReconstructWithZThisZ 5.000000e-01 5.000000e-01 sceneUpdateObservedFromStreamBufferAtZNoRecalcAllSelfModelRenderGlareOnly )<br/></td><td></td></tr>
<tr><td>( &quot;lm&quot; sceneLoadLightingModelFromGaussianMapFile tableSpiralStreamTakeSceneStride viewSynthApertureWidth viewSynthAperturePlane tableReconstructWithZThisZ sceneUpdateObservedFromStreamBufferAtZNoRecalcViewSynthAllGCLightModelRenderWithoutGlare )<br/></td><td></td></tr>
<tr><td>( tableSpiralStreamTakeSceneStride viewSynthApertureWidth viewSynthAperturePlane tableReconstructWithZThisZ sceneUpdateObservedFromStreamBufferAtZNoRecalcViewSynthAll )<br/></td><td></td></tr>
<tr><td>( tableSpiralStreamTakeSceneStride tableReconstructWithZThisZ sceneUpdateObservedFromStreamBufferAtZNoRecalcAllOOP )<br/></td><td></td></tr>
<tr><td>( tableReconstructWithZTopZ 3.880000e-01 divide tableReconstructGridMultiplier times 1.000000e+00 times &quot;slfgRebaseCellWidth&quot; store slfgRebase sceneClearObservedMap 400 sceneSetAngularApertureRows 640 sceneSetAngularApertureCols /*
  double z_to_use = 0.0;
  double lens_gap = 0.01;

  double y_slice_meters = 0.01;
  double y_aperture_meters = 0.01;

  double v_slice_unitless = 0.01;
  double v_aperture_unitless = 0.01;

  double lens_strength_u = 0.5;

  int stride = 1;
  */ 1.000000e+00 5.000000e-01 1.000000e-02 0.000000e+00 1.000000e-01 0.000000e+00 1.000000e-01 1.000000e-02 sceneUpdateObservedFromStreamBufferAtZNoRecalcEPI sceneRecalculateObservedMusAndSigmas table1DCellCountThreshold &quot;tableCellCountThreshold&quot; store sceneRenderObservedMap )<br/></td><td></td></tr>
<tr><td>( tableReconstructWithZTopZ 3.880000e-01 divide 1.000000e-03 times &quot;slfgRebaseCellWidth&quot; store slfgRebase 0 0 phasedArrayApertureWidthCells phasedArrayPhase phasedArrayWavelength tableReconstructArrayZ tableReconstructWithZTopZ sceneUpdateObservedFromRegisterAtZNoRecalcPhasedArray sceneRecalculateObservedMusAndSigmas sceneRenderObservedMap )<br/></td><td></td></tr>
<tr><td>( tableReconstructWithZTopZ 3.880000e-01 divide 1.000000e-03 times &quot;slfgRebaseCellWidth&quot; store slfgRebase phasedArrayPlaneScale phasedArrayZoneWidthCells 0 0 phasedArrayGain phasedArrayPhase phasedArrayWavelength tableReconstructArrayZ tableReconstructWithZTopZ sceneUpdateObservedFromRegisterAtZNoRecalcPhasedArrayKernel sceneRecalculateObservedMusAndSigmas sceneRenderObservedMap )<br/></td><td></td></tr>
<tr><td>( currentPose eePosePZ currentTableZ plus &quot;tableReconstructWithZTopZ&quot; store tableReconstructWithZ ) &quot;Reconstruct the entire stream at the table height.&quot; setHelp<br/></td><td>Reconstruct the entire stream at the table height.</td></tr>
<tr><td>( 3.883000e-01 &quot;tableReconstructWithZTopZ&quot; store 1.200000e-01 &quot;tableReconstructWithZTotalZDefault&quot; store tableReconstructWithZTotalZDefault &quot;tableReconstructWithZTotalZ&quot; store 1.000000e-02 &quot;tableReconstructWithZDeltaZ&quot; store 4000 &quot;tableReconstructStreamTakeSceneSamples&quot; store tableReconstructGCNone &quot;gcTempNone&quot; sceneSaveObservedMap /*
    &quot;/home/oberlin/Desktop/slfgRays/icra2016/glareRemoval/icraAsset0/icraAsset0_351_4000_height_&quot; tableReconstructWithZThisZ &quot;.png&quot; + +
  sceneSaveObservedMapImage
*/ 1000 &quot;tableReconstructStreamTakeSceneSamples&quot; store tableReconstructGCSelfFromNone &quot;gcTempSelf&quot; sceneSaveObservedMap &quot;gcTempNone&quot; sceneLoadBackgroundMap tableUpdateMaps 5.000000e-02 sceneSetLightModelFromDiscrepancy scenePushLightingModel pop 2.550000e+02 sceneSetLightingModelFromStack &quot;lm&quot; sceneSaveLightingModelToGaussianMapFile &quot;gcTempNone&quot; sceneLoadObservedMap tableReconstructGCLightRisingFromNone &quot;gcTempOwn&quot; sceneSaveObservedMap &quot;gcTempNone&quot; sceneLoadObservedMap tableReconstructGCLightAllFromNone &quot;gcTempAll&quot; sceneSaveObservedMap &quot;gcTempSelf&quot; sceneLoadObservedMap tableReconstructGCLightRisingFromNone &quot;gcTempSelfThenRising&quot; sceneSaveObservedMap 0.000000e+00 &quot;tableReconstructWithZTotalZDefault&quot; store tableReconstructWithZTotalZDefault &quot;tableReconstructWithZTotalZ&quot; store 3.283000e-01 &quot;tableReconstructWithZTopZ&quot; store 4000 &quot;tableReconstructStreamTakeSceneSamples&quot; store tableReconstructGCNone &quot;gcTempSingle&quot; sceneSaveObservedMap )<br/></td><td></td></tr>
<tr><td>( oP tableReconstructCpLightModelGC cP &quot;tableReconstructWithZCaster&quot; store oP cP &quot;tableReconstructWithZRegisterInitializer&quot; store oP 351 sceneSetAngularApertureRows 351 sceneSetAngularApertureCols cP &quot;tableReconstructWithZApertureSetter&quot; store tableReconstructWithZCore )<br/></td><td></td></tr>
<tr><td>( oP tableReconstructCpLightModelRisingGC cP &quot;tableReconstructWithZCaster&quot; store oP cP &quot;tableReconstructWithZRegisterInitializer&quot; store oP 351 sceneSetAngularApertureRows 351 sceneSetAngularApertureCols cP &quot;tableReconstructWithZApertureSetter&quot; store tableReconstructWithZCore )<br/></td><td></td></tr>
<tr><td>( oP tableReconstructCpNoGC cP &quot;tableReconstructWithZCaster&quot; store oP sceneInitRegisterMax cP &quot;tableReconstructWithZRegisterInitializer&quot; store oP /* XXX undo to 151 */ 151 sceneSetAngularApertureRows 151 sceneSetAngularApertureCols cP &quot;tableReconstructWithZApertureSetter&quot; store tableReconstructWithZCore )<br/></td><td></td></tr>
<tr><td>( oP tableReconstructCpNoGC cP &quot;tableReconstructWithZCaster&quot; store oP sceneInitRegisterMax cP &quot;tableReconstructWithZRegisterInitializer&quot; store oP 51 sceneSetAngularApertureRows 51 sceneSetAngularApertureCols cP &quot;tableReconstructWithZApertureSetter&quot; store tableReconstructWithZCore )<br/></td><td></td></tr>
<tr><td>( oP tableReconstructCpNoGC cP &quot;tableReconstructWithZCaster&quot; store oP sceneInitRegisterMax cP &quot;tableReconstructWithZRegisterInitializer&quot; store oP /* XXX undo to 151 */ 400 sceneSetAngularApertureRows 640 sceneSetAngularApertureCols cP &quot;tableReconstructWithZApertureSetter&quot; store tableReconstructWithZCore )<br/></td><td></td></tr>
<tr><td>( oP tableReconstructCpSelfGC cP &quot;tableReconstructWithZCaster&quot; store oP cP &quot;tableReconstructWithZRegisterInitializer&quot; store oP 351 sceneSetAngularApertureRows 351 sceneSetAngularApertureCols cP &quot;tableReconstructWithZApertureSetter&quot; store tableReconstructWithZCore )<br/></td><td></td></tr>
<tr><td>( oP tableArrayViewSynthesisAutoFocus tableReconstructCpViewSynthLightModelGC cP &quot;tableReconstructWithZCaster&quot; store oP sceneInitRegisterMax cP &quot;tableReconstructWithZRegisterInitializer&quot; store oP 351 sceneSetAngularApertureRows 551 sceneSetAngularApertureCols cP &quot;tableReconstructWithZApertureSetter&quot; store tableReconstructWithZCore )<br/></td><td></td></tr>
<tr><td>( oP viewSynthApertureWidth viewSynthApertureDilateDelta plus &quot;viewSynthApertureWidth&quot; store tableReconstructCpViewSynthLightModelGC cP &quot;tableReconstructWithZCaster&quot; store oP sceneInitRegisterMax cP &quot;tableReconstructWithZRegisterInitializer&quot; store oP 351 sceneSetAngularApertureRows 551 sceneSetAngularApertureCols cP &quot;tableReconstructWithZApertureSetter&quot; store tableReconstructWithZCore )<br/></td><td></td></tr>
<tr><td>( oP tableArrayViewSynthesisAutoFocus tableReconstructCpViewSynthNoGC cP &quot;tableReconstructWithZCaster&quot; store oP sceneInitRegisterMax cP &quot;tableReconstructWithZRegisterInitializer&quot; store oP 351 sceneSetAngularApertureRows 551 sceneSetAngularApertureCols cP &quot;tableReconstructWithZApertureSetter&quot; store tableReconstructWithZCore )<br/></td><td></td></tr>
<tr><td>( 3.883000e-01 &quot;tableReconstructWithZTopZ&quot; store 0.000000e+00 &quot;tableReconstructWithZTotalZDefault&quot; store tableReconstructWithZTotalZDefault &quot;tableReconstructWithZTotalZ&quot; store 1.000000e-02 &quot;tableReconstructWithZDeltaZ&quot; store 1000 &quot;tableReconstructStreamTakeSceneSamples&quot; store tableReconstructGCViewSynthLightModelDilate &quot;gcTempWristNone&quot; sceneSaveObservedMap )<br/></td><td></td></tr>
<tr><td>2.000000e-03<br/></td><td></td></tr>
<tr><td>( )<br/></td><td></td></tr>
<tr><td>3.500000e-01<br/></td><td></td></tr>
<tr><td>( tableLightSlabAutoFocus /*
  171 sceneSetAngularBaffleRows 171 sceneSetAngularBaffleCols

  100 sceneSetAngularApertureRows 100 sceneSetAngularApertureCols
  0 sceneSetAngularBaffleRows 0 sceneSetAngularBaffleCols

  351 sceneSetAngularApertureRows 351 sceneSetAngularApertureCols
  151 sceneSetAngularApertureRows 151 sceneSetAngularApertureCols

  85 sceneSetAngularApertureRows 85 sceneSetAngularApertureCols
  0 sceneSetAngularBaffleRows 0 sceneSetAngularBaffleCols
  151 sceneSetAngularApertureRows 151 sceneSetAngularApertureCols
 */ streamImageBufferSize tableReconstructStreamTakeSceneSamples min &quot;tableRSTSSMax&quot; store &quot;XXX: &quot; tableReconstructStreamTakeSceneSamples plus print tableReconstructWithZTopZ 3.880000e-01 divide tableReconstructGridMultiplier tableReconstructLightSlabGridMultiplier times times &quot;slfgRebaseCellWidth&quot; store slfgRebase /* sceneInitRegisterZero */ sceneInitRegisterMax /* find the right stride */ streamImageBufferSize tableRSTSSMax divide ceil &quot;tableSpiralStreamTakeSceneStride&quot; store /* don&apos;t try to use more images than you have */ streamImageBufferSize tableSpiralStreamTakeSceneStride divide floor &quot;tableRSTSSMax&quot; store streamImageBufferSize print tableRSTSSMax print tableSpiralStreamTakeSceneStride print tableReconstructWithZTopZ &quot;tableReconstructWithZThisZ&quot; store tableReconstructWithZTopZ tableReconstructWithZTotalZ minus &quot;tableReconstructWithZBottomZ&quot; store sceneClearDepthStack oP tableReconstructWithZThisZ tableReconstructWithZBottomZ equals tableReconstructWithZThisZ tableReconstructWithZBottomZ rangle or cP oP tableReconstructWithZBottomZ &quot; &quot; tableReconstructWithZThisZ &quot; &quot; tableReconstructWithZTopZ &quot; &quot; plus plus plus plus plus print /*
    tableReconstructWithZThisZ 0.388 divide tableReconstructGridMultiplier times  &quot;slfgRebaseCellWidth&quot; store slfgRebase
    */ tableReconstructWithZTopZ 3.880000e-01 divide tableReconstructGridMultiplier times &quot;slfgRebaseCellWidth&quot; store slfgRebase sceneClearObservedMap rewindImageStreamBufferNLNK /*
      sceneRecalculateObservedMusAndSigmas
      sceneRenderObservedMap
*/ oP /*
      tableReconstructWithZThisZ sceneUpdateObservedFromStreamBufferAtZNoRecalc 
      */ lensArrayGap lensArrayStrength lensArraySize tableReconstructWithZThisZ sceneUpdateObservedFromStreamBufferAtZNoRecalcSecondStageArray oP incrementImageStreamBufferNoLoadNoKick cP tableSpiralStreamTakeSceneStride replicateWord cP tableRSTSSMax replicateWord /*
      tableSpiralStreamTakeSceneStride 
      tableReconstructWithZThisZ 
    sceneUpdateObservedFromStreamBufferAtZNoRecalcAll
    */ sceneRecalculateObservedMusAndSigmas sceneRenderObservedMap /*
    pauseStackExecution
    sceneSmoothSquaredCountsAndSamplesXY
    0.1 sceneTrimDepthWithDiscrepancy
*/ /*
      &quot;zFigure_&quot; tableReconstructWithZThisZ +
    sceneSaveScene

      &quot;high_zoom_figure_&quot; tableReconstructWithZThisZ + 
    sceneSaveScene

      &quot;slfg_giraffe_back_right_&quot; tableReconstructWithZThisZ + 
    sceneSaveScene

      &quot;/home/oberlin/dev/catkin_ws_ursula/src/ein/default/objects/aaaRSSRoomSceneHiRes/depthvideo/frame_&quot; tableReconstructWithZThisZ &quot;.png&quot; + +
    sceneSaveObservedMapImage
*/ /*
*/ scenePushOntoDepthStack /*
    sceneMinIntoRegister
*/ tableReconstructWithZThisZ tableReconstructWithZDeltaZ minus &quot;tableReconstructWithZThisZ&quot; store cP whileCollapsed tableReconstructWithZTopZ 3.880000e-01 divide tableReconstructGridMultiplier times &quot;slfgRebaseCellWidth&quot; store slfgRebase /*
  sceneMarginalizeDepthStackIntoRegister
*/ sceneMinDepthStackIntoRegister sceneRecallFromRegister sceneRenderZ sceneRenderObservedMap tableReconstructMarginalsFromStack )<br/></td><td></td></tr>
<tr><td>( tableLightSlabAutoFocus streamImageBufferSize tableReconstructStreamTakeSceneSamples min &quot;tableRSTSSMax&quot; store /* sceneInitRegisterZero */ sceneInitRegisterMax /* find the right stride */ streamImageBufferSize tableRSTSSMax divide ceil &quot;tableSpiralStreamTakeSceneStride&quot; store /* don&apos;t try to use more images than you have */ streamImageBufferSize tableSpiralStreamTakeSceneStride divide floor &quot;tableRSTSSMax&quot; store streamImageBufferSize print tableRSTSSMax print tableSpiralStreamTakeSceneStride print tableReconstructWithZTopZ &quot;tableReconstructWithZThisZ&quot; store tableReconstructWithZTopZ &quot;tableReconstructWithZBottomZ&quot; store tableReconstructWithZBottomZ &quot; &quot; tableReconstructWithZThisZ &quot; &quot; tableReconstructWithZTopZ &quot; &quot; plus plus plus plus plus print tableReconstructWithZTopZ 3.880000e-01 divide tableReconstructGridMultiplier tableReconstructLightSlabGridMultiplier times times &quot;slfgRebaseCellWidth&quot; store slfgRebase sceneClearObservedMap rewindImageStreamBufferNLNK oP /*
    lensArrayStrengthX lensArraySpacingX lensArrayPhaseX lensArrayStrengthY lensArraySpacingY lensArrayPhaseY lensArrayGap tableReconstructWithZThisZ sceneUpdateObservedFromStreamBufferAtZNoRecalcSecondStageAsymmetricArray


    phasedArrayGain phasedArrayPhase phasedArrayWavelength phasedArrayGap tableReconstructArrayZ sceneUpdateObservedFromStreamBufferAtZNoRecalcPhasedArray
      tableReconstructWithZThisZ sceneUpdateObservedFromStreamBufferAtZNoRecalc 

    lensArrayStrengthX lensArraySpacingX lensArrayPhaseX lensArrayStrengthY lensArraySpacingY lensArrayPhaseY lensArrayGap tableReconstructWithZThisZ sceneUpdateObservedFromStreamBufferAtZNoRecalcSecondStageAsymmetricArray

*/ lensArrayGap lensArrayStrength lensArraySize tableReconstructWithZThisZ sceneUpdateObservedFromStreamBufferAtZNoRecalcSecondStageArray oP incrementImageStreamBufferNoLoadNoKick cP tableSpiralStreamTakeSceneStride replicateWord /*
    endStackCollapseNoop 
    */ cP tableRSTSSMax replicateWord /*
    tableSpiralStreamTakeSceneStride 
    tableReconstructWithZThisZ 
  sceneUpdateObservedFromStreamBufferAtZNoRecalcAll
*/ /* 
    tableSpiralStreamTakeSceneStride 
    viewSynthApertureWidth
    viewSynthAperturePlane
    tableReconstructWithZThisZ 
  sceneUpdateObservedFromStreamBufferAtZNoRecalcViewSynthAll 
  */ /* 
  sceneUpdateObservedFromStreamBufferAtZNoRecalcViewSynthBeamAll
  */ sceneRecalculateObservedMusAndSigmas sceneRenderObservedMap sceneRenderZ sceneStoreObservedInRegister )<br/></td><td></td></tr>
<tr><td>( tableReconstructWithZTopZ 3.880000e-01 divide tableReconstructGridMultiplier times &quot;slfgRebaseCellWidth&quot; store slfgRebase tableReconstructMarginalsFromStackCore )<br/></td><td></td></tr>
<tr><td>( sceneInitRegisterZero sceneMarginalizeDepthStackIntoRegister sceneRecallFromRegister sceneRenderZ sceneRenderObservedMap )<br/></td><td></td></tr>
<tr><td>( tableReconstructWithZTopZ 3.880000e-01 divide tableReconstructGridMultiplier times &quot;slfgRebaseCellWidth&quot; store slfgRebase tableReconstructMaxLikelihoodFromStackCore )<br/></td><td></td></tr>
<tr><td>( /*
  sceneInitRegisterMax 
  */ sceneMinDepthStackIntoRegister sceneRecallFromRegister sceneRecalculateObservedMusAndSigmas sceneRenderZ sceneRenderObservedMap )<br/></td><td></td></tr>
<tr><td>( sceneSetDiscrepancyModeDot tableReconstructMarginalsFromStack tableUpdateMaps tableReconstructMaxLikelihoodFromStackCore 3.898000e-01 9.999999e-01 sceneTrimDepthWithDiscrepancy sceneRenderZ )<br/></td><td></td></tr>
<tr><td>( /* 
  catScan5LoadPlayBg tableUpdateMaps 0.1 sceneTrimDepthWithDiscrepancy sceneRenderZ
  3.0 sceneSmoothDepthStackInZ sceneInitRegisterMax sceneMinDepthStackIntoRegister sceneRecallFromRegister sceneRenderZ tableUpdateMaps
  */ )<br/></td><td></td></tr>
<tr><td>( tableTakeScene quarterImpulse tableServoToFocusedSceneObject pixelServoPutGripperUnderVanishingPoint waitUntilAtCurrentPosition )<br/></td><td></td></tr>
<tr><td>( tableTakeScene quarterImpulse tableServoToBestSceneObject pixelServoPutGripperUnderVanishingPoint waitUntilAtCurrentPosition )<br/></td><td></td></tr>
<tr><td>1000<br/></td><td></td></tr>
<tr><td>( oP tableReconstructCpWithOOP cP &quot;tableReconstructWithZCaster&quot; store oP sceneInitRegisterMax cP &quot;tableReconstructWithZRegisterInitializer&quot; store oP /* XXX undo to 151 */ 151 sceneSetAngularApertureRows 151 sceneSetAngularApertureCols cP &quot;tableReconstructWithZApertureSetter&quot; store tableReconstructWithZCore )<br/></td><td></td></tr>
<tr><td>( oP tableReconstructCpWithOOP cP &quot;tableReconstructWithZCaster&quot; store oP sceneInitRegisterMax cP &quot;tableReconstructWithZRegisterInitializer&quot; store oP 51 sceneSetAngularApertureRows 51 sceneSetAngularApertureCols cP &quot;tableReconstructWithZApertureSetter&quot; store tableReconstructWithZCore )<br/></td><td></td></tr>
<tr><td>( oP tableReconstructCpWithOOP cP &quot;tableReconstructWithZCaster&quot; store oP sceneInitRegisterMax cP &quot;tableReconstructWithZRegisterInitializer&quot; store oP 399 sceneSetAngularApertureRows 639 sceneSetAngularApertureCols cP &quot;tableReconstructWithZApertureSetter&quot; store tableReconstructWithZCore )<br/></td><td></td></tr>
<tr><td>( tableReconstructWithZTable2D )<br/></td><td></td></tr>
<tr><td>( /*
  171 sceneSetAngularBaffleRows 171 sceneSetAngularBaffleCols

  100 sceneSetAngularApertureRows 100 sceneSetAngularApertureCols
  0 sceneSetAngularBaffleRows 0 sceneSetAngularBaffleCols

  351 sceneSetAngularApertureRows 351 sceneSetAngularApertureCols
  151 sceneSetAngularApertureRows 151 sceneSetAngularApertureCols

  85 sceneSetAngularApertureRows 85 sceneSetAngularApertureCols
  0 sceneSetAngularBaffleRows 0 sceneSetAngularBaffleCols
  151 sceneSetAngularApertureRows 151 sceneSetAngularApertureCols
  351 sceneSetAngularApertureRows 351 sceneSetAngularApertureCols
 */ 151 sceneSetAngularApertureRows 151 sceneSetAngularApertureCols )<br/></td><td></td></tr>
<tr><td>( /*
  tableReconstructCpNoGC
  tableReconstructCpSelfGC
  tableReconstructCpLightModelGC 

  */ tableReconstructCpNoGC )<br/></td><td></td></tr>
<tr><td>( tableReconstructWithZApertureSetter streamImageBufferSize tableReconstructStreamTakeSceneSamples min &quot;tableRSTSSMax&quot; store &quot;XXX: &quot; tableReconstructStreamTakeSceneSamples plus print tableReconstructWithZTopZ 3.880000e-01 divide tableReconstructGridMultiplier times &quot;slfgRebaseCellWidth&quot; store slfgRebase /* find the right stride */ streamImageBufferSize tableRSTSSMax divide ceil &quot;tableSpiralStreamTakeSceneStride&quot; store /* don&apos;t try to use more images than you have */ streamImageBufferSize tableSpiralStreamTakeSceneStride divide floor &quot;tableRSTSSMax&quot; store streamImageBufferSize print tableRSTSSMax print tableSpiralStreamTakeSceneStride print tableReconstructWithZTopZ &quot;tableReconstructWithZThisZ&quot; store tableReconstructWithZTopZ tableReconstructWithZTotalZ minus &quot;tableReconstructWithZBottomZ&quot; store sceneClearDepthStack oP tableReconstructWithZThisZ tableReconstructWithZBottomZ equals tableReconstructWithZThisZ tableReconstructWithZBottomZ rangle or cP oP tableReconstructWithZBottomZ &quot; &quot; tableReconstructWithZThisZ &quot; &quot; tableReconstructWithZTopZ &quot; &quot; plus plus plus plus plus print /*
    tableReconstructWithZThisZ 0.388 divide tableReconstructGridMultiplier times  &quot;slfgRebaseCellWidth&quot; store slfgRebase
    tableReconstructWithZTopZ 0.388 divide tableReconstructGridMultiplier times  &quot;slfgRebaseCellWidth&quot; store slfgRebase
    */ tableReconstructWithZTopZ 3.880000e-01 divide tableReconstructGridMultiplier times &quot;slfgRebaseCellWidth&quot; store slfgRebaseNoBackground sceneClearObservedMap rewindImageStreamBufferNLNK /*
      sceneRecalculateObservedMusAndSigmas
      sceneRenderObservedMap
*/ /*
    ( 
      tableReconstructWithZThisZ sceneUpdateObservedFromStreamBufferAtZNoRecalc 


      ( 
	incrementImageStreamBufferNoLoadNoKick 
      ) tableSpiralStreamTakeSceneStride replicateWord 


      endStackCollapseNoop 
    ) tableRSTSSMax replicateWord
*/ tableReconstructWithZCaster sceneRecalculateObservedMusAndSigmas sceneRenderObservedMap /*
    sceneSmoothSquaredCountsAndSamplesXY
    0.1 sceneTrimDepthWithDiscrepancy
*/ /*
      &quot;zFigure_&quot; tableReconstructWithZThisZ +
    sceneSaveScene

      &quot;high_zoom_figure_&quot; tableReconstructWithZThisZ + 
    sceneSaveScene

      &quot;slfg_giraffe_back_right_&quot; tableReconstructWithZThisZ + 
    sceneSaveScene

      &quot;/home/oberlin/dev/catkin_ws_ursula/src/ein/default/objects/aaaRSSRoomSceneHiRes/depthvideo/frame_&quot; tableReconstructWithZThisZ &quot;.png&quot; + +
    sceneSaveObservedMapImage

      &quot;icraAsset0_351_4000_height_&quot; tableReconstructWithZThisZ + 
    sceneSaveScene

      &quot;/home/oberlin/Desktop/slfgRays/icra2016/glareRemoval/icraAsset0/icraAsset0_351_4000_height_&quot; tableReconstructWithZThisZ &quot;.png&quot; + +
    sceneSaveObservedMapImage

*/ /*
*/ scenePushOntoDepthStack tableReconstructWithZThisZ tableReconstructWithZDeltaZ minus &quot;tableReconstructWithZThisZ&quot; store cP whileCollapsed tableReconstructWithZTopZ 3.880000e-01 divide tableReconstructGridMultiplier times &quot;slfgRebaseCellWidth&quot; store slfgRebase /*
  sceneMinDepthStackIntoRegister  sceneRecallFromRegister sceneRenderZ sceneRenderObservedMap
*/ /*
  tableReconstructMarginalsFromStack
  400.0 sceneSetObservedRGBFromZ sceneRenderObservedMap
*/ tableReconstructWithZRegisterInitializer tableReconstructMaxLikelihoodFromStack )<br/></td><td></td></tr>
<tr><td>1.000000e-02<br/></td><td></td></tr>
<tr><td>( /* 
  sceneInitRegisterZero 
  sceneInitRegisterMax  
  */ sceneInitRegisterMax )<br/></td><td></td></tr>
<tr><td>( /*
  0.4183 &quot;tableReconstructWithZTopZ&quot; store 
  */ 5.000000e-02 &quot;tableReconstructWithZTotalZDefault&quot; store tableReconstructWithZTotalZDefault &quot;tableReconstructWithZTotalZ&quot; store 5.000000e-03 &quot;tableReconstructWithZDeltaZ&quot; store 10000000 &quot;tableReconstructStreamTakeSceneSamples&quot; store /*
  tableReconstructWithOOP
  */ tableReconstructGCNoneNarrow )<br/></td><td></td></tr>
<tr><td>( /*
  0.4183 &quot;tableReconstructWithZTopZ&quot; store 
  */ 0.000000e+00 &quot;tableReconstructWithZTotalZDefault&quot; store tableReconstructWithZTotalZDefault &quot;tableReconstructWithZTotalZ&quot; store 1.000000e-02 &quot;tableReconstructWithZDeltaZ&quot; store /*
  10000000 &quot;tableReconstructStreamTakeSceneSamples&quot; store
  */ 100 &quot;tableReconstructStreamTakeSceneSamples&quot; store /*
  tableReconstructWithOOP
  tableReconstructWithOOPWide
  */ tableReconstructGCNoneWide )<br/></td><td></td></tr>
<tr><td>( /*
  0.4183 &quot;tableReconstructWithZTopZ&quot; store 
  */ 0.000000e+00 &quot;tableReconstructWithZTotalZDefault&quot; store tableReconstructWithZTotalZDefault &quot;tableReconstructWithZTotalZ&quot; store 1.000000e-02 &quot;tableReconstructWithZDeltaZ&quot; store /*
  100 &quot;tableReconstructStreamTakeSceneSamples&quot; store
  */ 10000000 &quot;tableReconstructStreamTakeSceneSamples&quot; store /*
  tableReconstructGCNone
  tableReconstructWithOOP
  */ tableReconstructGCNone )<br/></td><td></td></tr>
<tr><td>( 3.883000e-01 &quot;tableReconstructWithZTopZ&quot; store 1.200000e-01 &quot;tableReconstructWithZTotalZDefault&quot; store tableReconstructWithZTotalZDefault &quot;tableReconstructWithZTotalZ&quot; store 1.000000e-02 &quot;tableReconstructWithZDeltaZ&quot; store 4000 &quot;tableReconstructStreamTakeSceneSamples&quot; store tableReconstructGCNone 1000 &quot;tableReconstructStreamTakeSceneSamples&quot; store tableReconstructGCSelfFromNone )<br/></td><td></td></tr>
<tr><td>( 3.883000e-01 &quot;tableReconstructWithZTopZ&quot; store 1.200000e-01 &quot;tableReconstructWithZTotalZDefault&quot; store tableReconstructWithZTotalZDefault &quot;tableReconstructWithZTotalZ&quot; store 2.000000e-02 &quot;tableReconstructWithZDeltaZ&quot; store 350 &quot;tableReconstructStreamTakeSceneSamples&quot; store tableReconstructGCNone 250 &quot;tableReconstructStreamTakeSceneSamples&quot; store tableReconstructGCSelfFromNone )<br/></td><td></td></tr>
<tr><td>( 4.183000e-01 &quot;tableReconstructWithZTopZ&quot; store 5.000000e-02 &quot;tableReconstructWithZTotalZDefault&quot; store tableReconstructWithZTotalZDefault &quot;tableReconstructWithZTotalZ&quot; store 5.000000e-02 &quot;tableReconstructWithZDeltaZ&quot; store 10000000 &quot;tableReconstructStreamTakeSceneSamples&quot; store tableReconstructGCNone tableReconstructMarginalsFromStack )<br/></td><td></td></tr>
<tr><td>3.883000e-01<br/></td><td></td></tr>
<tr><td>0.000000e+00<br/></td><td></td></tr>
<tr><td>0.000000e+00<br/></td><td></td></tr>
<tr><td>( 3.883000e-01 &quot;tableReconstructWithZTopZ&quot; store 1.200000e-01 &quot;tableReconstructWithZTotalZDefault&quot; store tableReconstructWithZTotalZDefault &quot;tableReconstructWithZTotalZ&quot; store 1.000000e-02 &quot;tableReconstructWithZDeltaZ&quot; store 2000 &quot;tableReconstructStreamTakeSceneSamples&quot; store tableReconstructGCNone 3.883000e-01 &quot;tableReconstructWithZTopZ&quot; store 1.200000e-01 &quot;tableReconstructWithZTotalZDefault&quot; store tableReconstructWithZTotalZDefault &quot;tableReconstructWithZTotalZ&quot; store 1.000000e-02 &quot;tableReconstructWithZDeltaZ&quot; store 500 &quot;tableReconstructStreamTakeSceneSamples&quot; store tableReconstructGCSelfFromNone 1.000000e-01 sceneSetObservedRGBFromVariance sceneRenderObservedMap )<br/></td><td></td></tr>
<tr><td>( 3.883000e-01 &quot;tableReconstructWithZTopZ&quot; store 1.200000e-01 &quot;tableReconstructWithZTotalZDefault&quot; store tableReconstructWithZTotalZDefault &quot;tableReconstructWithZTotalZ&quot; store 1.000000e-02 &quot;tableReconstructWithZDeltaZ&quot; store 1000 &quot;tableReconstructStreamTakeSceneSamples&quot; store tableReconstructGCNone tableReconstructMarginalsFromStack 2.500000e-02 sceneSetObservedRGBFromVariance sceneRenderObservedMap )<br/></td><td></td></tr>
<tr><td>( streamImageBufferSize tableReconstructStreamTakeSceneSamples min &quot;tableRSTSSMax&quot; store /* sceneInitRegisterZero */ sceneInitRegisterMax /* find the right stride */ streamImageBufferSize tableRSTSSMax divide ceil &quot;tableSpiralStreamTakeSceneStride&quot; store /* don&apos;t try to use more images than you have */ streamImageBufferSize tableSpiralStreamTakeSceneStride divide floor &quot;tableRSTSSMax&quot; store streamImageBufferSize print tableRSTSSMax print tableSpiralStreamTakeSceneStride print tableReconstructWithZTopZ &quot;tableReconstructWithZThisZ&quot; store tableReconstructWithZTopZ &quot;tableReconstructWithZBottomZ&quot; store tableReconstructWithZBottomZ &quot; &quot; tableReconstructWithZThisZ &quot; &quot; tableReconstructWithZTopZ &quot; &quot; plus plus plus plus plus print tableReconstructWithZTopZ 3.880000e-01 divide tableReconstructGridMultiplier times &quot;slfgRebaseCellWidth&quot; store slfgRebase sceneClearObservedMap rewindImageStreamBufferNLNK oP /*
    lensArrayGap lensArrayStrength lensArraySize tableReconstructWithZThisZ sceneUpdateObservedFromStreamBufferAtZNoRecalcSecondStageArray
    lensArrayStrengthX lensArraySpacingX lensArrayPhaseX lensArrayStrengthY lensArraySpacingY lensArrayPhaseY lensArrayGap tableReconstructWithZThisZ sceneUpdateObservedFromStreamBufferAtZNoRecalcSecondStageAsymmetricArray


    phasedArrayGain phasedArrayPhase phasedArrayWavelength phasedArrayGap tableReconstructArrayZ sceneUpdateObservedFromStreamBufferAtZNoRecalcPhasedArray
      tableReconstructWithZThisZ sceneUpdateObservedFromStreamBufferAtZNoRecalc 

    lensArrayStrengthX lensArraySpacingX lensArrayPhaseX lensArrayStrengthY lensArraySpacingY lensArrayPhaseY lensArrayGap tableReconstructWithZThisZ sceneUpdateObservedFromStreamBufferAtZNoRecalcSecondStageAsymmetricArray

    ( 
      incrementImageStreamBufferNoLoadNoKick 
    ) tableSpiralStreamTakeSceneStride replicateWord 
*/ /*
    endStackCollapseNoop 
    */ cP tableRSTSSMax replicateWord /*
 Console: lighting model r g b: 127.531 123.959 71.7755
  sceneUpdateObservedFromStreamBufferAtZNoRecalcAllLightModelRenderGlareOnly

    tableSpiralStreamTakeSceneStride 
    tableReconstructWithZThisZ 
    0.5
    0.5
  sceneUpdateObservedFromStreamBufferAtZNoRecalcAllLightModelRenderWithoutGlare
*/ tableSpiralStreamTakeSceneStride tableReconstructWithZThisZ sceneUpdateObservedFromStreamBufferAtZNoRecalcAll /* 
    tableSpiralStreamTakeSceneStride 
    viewSynthApertureWidth
    viewSynthAperturePlane
    tableReconstructWithZThisZ 
  sceneUpdateObservedFromStreamBufferAtZNoRecalcViewSynthAll 
  */ sceneRecalculateObservedMusAndSigmas sceneRenderObservedMap sceneRenderZ sceneStoreObservedInRegister )<br/></td><td></td></tr>
<tr><td>( /* 
 Back when calibration wasn&apos;t great, we needed regularization. Now the regularization hurts because
 sharp lines blur due to camera uncertainty when the robot shakes. Using the natural statistics is
 the right thing, because it captures uncertainty along sharp adges, as was intended. 

 Edit: actually, due to the way the predicted map is composed, background regularization via sigmasquared is overwritten with a recalculateMusAndSigmas.
 so regularization needs to happen after the predicted map is composed.
*/ /*
  4.0 sceneSetBackgroundStdDevY
  4.0 sceneSetBackgroundStdDevColor
*/ )<br/></td><td></td></tr>
<tr><td>( /*
  4.0 sceneSetFocusedSceneStdDevY
  4.0 sceneSetFocusedSceneStdDevColor
*/ )<br/></td><td></td></tr>
<tr><td>( /*
  96.0 sceneSetPredictedStdDevY
  8.0 sceneSetPredictedStdDevColor
  */ 9.400000e+01 sceneSetPredictedStdDevY 4.000000e+00 sceneSetPredictedStdDevColor )<br/></td><td></td></tr>
<tr><td>( deactivateSensorStreaming bringUpAllNonessentialSystems assumeBeeHome 1 changeToHeight quarterImpulse 1.000000e-02 setGridSize )<br/></td><td></td></tr>
<tr><td>( tableBlockUsingBlocks oP &quot;tableRestoreFromBlocks: restoring from blocks.&quot; print scenePredictedMapThreshDefault &quot;scenePredictedMapThresh&quot; store endArgs tableSwapClassLabels setClassLabels numClasses 0 rangle oP tableSwapTargetClass setFocusedClass cP oP &quot;Oops, restoring to ZERO classes!&quot; print cP ifte createCachedClassifierFromClassLabels setGraspModeTo3D 1 sceneSetClassificationMode 0 &quot;tableBlockUsingBlocks&quot; store cP oP &quot;tableRestoreFromBlocks: restoring from blocks but not holding blocks.&quot; print cP ifte )<br/></td><td></td></tr>
<tr><td>( /* save a thumbnail of the last component in the object directory */ sceneLoadFocusedObjectModel dataDirectory &quot;/objects/&quot; focusedClassLabel &quot;/rgb.png&quot; plus plus plus sceneSaveObservedMapImage dataDirectory &quot;/objects/&quot; focusedClassLabel &quot;/mask.png&quot; plus plus plus sceneSaveDiscrepancyDensityImage )<br/></td><td></td></tr>
<tr><td>( scenePredictBestObject tableUpdateMaps 0 tableMoveToSceneObject )<br/></td><td></td></tr>
<tr><td>( scenePredictFocusedObject tableUpdateMaps 0 tableMoveToSceneObject )<br/></td><td></td></tr>
<tr><td>( currentObservedMap sceneCopyGaussianMap &quot;bgRAM&quot; store currentScene bgRAM sceneCopyGaussianMap sceneSetBackgroundMap sceneRenderScene ) &quot;Set current observed map to the background map and save to RAM.&quot; setHelp<br/></td><td>Set current observed map to the background map and save to RAM.</td></tr>
<tr><td>( /* endArgs &quot;banana&quot; &quot;mediumClamp&quot; &quot;redScrewdriver&quot; setClassLabels */ /* endArgs &quot;blueScrewdriver&quot; &quot;scissors&quot; &quot;wrench&quot; setClassLabels */ /* endArgs &quot;scene_set_1/duplo&quot; &quot;scene_set_1/icraStandardDucky&quot; &quot;scene_set_1/lock&quot; &quot;scene_set_1/strawberry&quot; setClassLabels */ endArgs &quot;scene_set_1/lock&quot; setClassLabels )<br/></td><td></td></tr>
<tr><td>( /* endArgs &quot;banana&quot; &quot;mediumClamp&quot; &quot;redScrewdriver&quot; setClassLabels */ /* endArgs &quot;blueScrewdriver&quot; &quot;scissors&quot; &quot;wrench&quot; setClassLabels */ /* endArgs &quot;scene_set_1/duplo&quot; &quot;scene_set_1/icraStandardDucky&quot; &quot;scene_set_1/lock&quot; &quot;scene_set_1/strawberry&quot; setClassLabels */ /* endArgs &quot;scene_set_1/lock&quot; setClassLabels */ /* endArgs &quot;pond_duck&quot; setClassLabels */ /* endArgs &quot;scissors_blue&quot; setClassLabels */ endArgs &quot;narrow_duck_osp&quot; setClassLabels )<br/></td><td></td></tr>
<tr><td>( tableShortTakeScene tableServoToBestSceneObject )<br/></td><td></td></tr>
<tr><td>( tableShortTakeScene tableServoToFocusedSceneObject )<br/></td><td></td></tr>
<tr><td>( /* this is not consistent with tableReconstruct routines */ /*  sceneClearObservedMap ( waitUntilImageCallbackReceived sceneUpdateObservedFromWrist ) 2 replicateWord tableUpdateMaps */ sceneClearObservedMap clearStreamBuffers streamEnableSisImageAndPoses activateSensorStreaming oP waitUntilImageCallbackReceived cP 50 replicateWord deactivateSensorStreaming tableReconstructFromStream tableUpdateMaps )<br/></td><td></td></tr>
<tr><td>2.000000e-02<br/></td><td></td></tr>
<tr><td>2.000000e-02<br/></td><td></td></tr>
<tr><td>( numClasses 0 rangle oP 1.500000e-01 &quot;tableNewComponentThresh&quot; store sceneClearPredictedObjects tableUpdateMaps endStackCollapseNoop 1.000000e-01 waitForSeconds /* pauseStackExecution */ /*
	  scenePushTotalDiscrepancyMagnitude 
    */ scenePushTotalDiscrepancy dup &quot;tableSpiralIsNewComponentInPlace: total discrepancy before &quot; swap plus print scenePredictBestObject tableUpdateMaps endStackCollapseNoop 1.000000e-01 waitForSeconds /*
	  scenePushTotalDiscrepancyMagnitude 
    */ scenePushTotalDiscrepancy dup &quot;tableSpiralIsNewComponentInPlace: total discrepancy after &quot; swap plus print &quot;tableSpiralIsNewComponentInPlace_after&quot; store &quot;tableSpiralIsNewComponentInPlace_before&quot; store tableSpiralIsNewComponentInPlace_before &quot;tableSpiralIsNewComponentInPlace: total discrepancy before is &quot; swap plus print tableSpiralIsNewComponentInPlace_after tableSpiralIsNewComponentInPlace_before plus &quot;tableSpiralIsNewComponentInPlace_sum&quot; store tableSpiralIsNewComponentInPlace_sum &quot;tableSpiralIsNewComponentInPlace: before after sum is&quot; swap plus print tableSpiralIsNewComponentInPlace_after tableSpiralIsNewComponentInPlace_sum divide &quot;tableSpiralIsNewComponentInPlace_ratio&quot; store tableSpiralIsNewComponentInPlace_ratio &quot;tableSpiralIsNewComponentInPlace: after / sum ratio is &quot; swap plus print tableSpiralIsNewComponentInPlace_ratio tableNewComponentThresh rangle oP 1 dup &quot;tableSpiralIsNewComponentInPlace: IS a new component, returning &quot; swap plus print cP oP 0 dup &quot;tableSpiralIsNewComponentInPlace: AIN&apos;T a new component, returning &quot; swap plus print cP ifte dup &quot;tableSpiralIsNewComponentInPlace: returning &quot; swap plus print cP oP &quot;tableSpiralIsNewComponentInPlace: numClasses is 0 so returning 1&quot; print 1 cP ifte )<br/></td><td></td></tr>
<tr><td>( numClasses 0 rangle oP 1.500000e-01 &quot;tableNewComponentThresh&quot; store sceneClearPredictedObjects sceneClearObservedMap tableUpdateSpiral endStackCollapseNoop 1.000000e-01 waitForSeconds /* pauseStackExecution */ /*
	  scenePushTotalDiscrepancyMagnitude 
    */ scenePushTotalDiscrepancy dup &quot;tableFivePointThreeWidthIsNewComponent: total discrepancy before &quot; swap plus print scenePredictBestObject tableUpdateMaps endStackCollapseNoop 1.000000e-01 waitForSeconds /*
	  scenePushTotalDiscrepancyMagnitude 
    */ scenePushTotalDiscrepancy dup &quot;tableFivePointThreeWidthIsNewComponent: total discrepancy after &quot; swap plus print &quot;tableFivePointThreeWidthIsNewComponentNormalizedSum_after&quot; store &quot;tableFivePointThreeWidthIsNewComponentNormalizedSum_before&quot; store tableFivePointThreeWidthIsNewComponentNormalizedSum_before &quot;tableFivePointThreeWidthIsNewComponent: total discrepancy before is &quot; swap plus print tableFivePointThreeWidthIsNewComponentNormalizedSum_after tableFivePointThreeWidthIsNewComponentNormalizedSum_before plus &quot;tableFivePointThreeWidthIsNewComponentNormalizedSum_sum&quot; store tableFivePointThreeWidthIsNewComponentNormalizedSum_sum &quot;tableFivePointThreeWidthIsNewComponent: before after sum is&quot; swap plus print tableFivePointThreeWidthIsNewComponentNormalizedSum_after tableFivePointThreeWidthIsNewComponentNormalizedSum_sum divide &quot;tableFivePointThreeWidthIsNewComponentNormalizedSum_ratio&quot; store tableFivePointThreeWidthIsNewComponentNormalizedSum_ratio &quot;tableFivePointThreeWidthIsNewComponent: after / sum ratio is &quot; swap plus print tableFivePointThreeWidthIsNewComponentNormalizedSum_ratio tableNewComponentThresh rangle oP 1 dup &quot;tableFivePointThreeWidthIsNewComponent: IS a new component, returning &quot; swap plus print cP oP 0 dup &quot;tableFivePointThreeWidthIsNewComponent: AIN&apos;T a new component, returning &quot; swap plus print cP ifte dup &quot;tableFivePointThreeWidthIsNewComponent: returning &quot; swap plus print cP oP &quot;tableFivePointThreeWidthIsNewComponent: numClasses is 0 so returning 1&quot; print 1 cP ifte )<br/></td><td></td></tr>
<tr><td>( numClasses 0 rangle oP 1.000000e+00 1.200000e+00 divide &quot;tableNewComponentThresh&quot; store sceneClearPredictedObjects tableUpdateMaps endStackCollapseNoop 1.000000e-01 waitForSeconds /* pauseStackExecution */ &quot;tableSpiralIsNewComponentPseudoGeometricInPlace_tableScene&quot; &quot;_&quot; leftOrRightArm &quot;_&quot; robotSerial plus plus plus plus &quot;tableSpiralIsNewComponentPseudoGeometricInPlace_tableSceneName&quot; store tableSpiralIsNewComponentPseudoGeometricInPlace_tableSceneName sceneSaveFocusedSceneModel sceneClearPredictedObjects tableUpdateMaps tableCaptureCore sceneClearPredictedObjects tableUpdateMaps scenePredictBestObject tableUpdateMaps endStackCollapseNoop 1.000000e-01 waitForSeconds /*
	  scenePushTotalDiscrepancy 
	  scenePushTotalDiscrepancyMagnitude 
	  scenePushTotalLogDiscrepancy
	  -10.00 scenePushTotalRelevantOneMinusDiscrepancy

	    scenePushFocusedClassModelArea
	    scenePushTotalDiscrepancy 
	  -

	    scenePushFocusedClassTotalDiscrepancy
	    scenePushTotalDiscrepancy 
	  -
    */ scenePushFocusedClassModelArea scenePushTotalDiscrepancy minus dup &quot;tableSpiralIsNewComponentPseudoGeometricInPlace: total discrepancy with new component&quot; swap plus print tableSpiralIsNewComponentPseudoGeometricInPlace_tableSceneName sceneLoadFocusedSceneModel sceneClearPredictedObjects tableUpdateMaps scenePredictBestObject tableUpdateMaps endStackCollapseNoop 1.000000e-01 waitForSeconds /*
	  scenePushTotalDiscrepancy 
	  scenePushTotalDiscrepancyMagnitude 
	  scenePushTotalLogDiscrepancy
	  -10.00 scenePushTotalRelevantOneMinusDiscrepancy
    */ scenePushFocusedClassModelArea scenePushTotalDiscrepancy minus dup &quot;tableSpiralIsNewComponentPseudoGeometricInPlace: total discrepancy with best old component&quot; swap plus print &quot;tableSpiralIsNewComponentPseudoGeometricInPlace_after&quot; store &quot;tableSpiralIsNewComponentPseudoGeometricInPlace_before&quot; store tableSpiralIsNewComponentPseudoGeometricInPlace_before &quot;tableSpiralIsNewComponentPseudoGeometricInPlace: total discrepancy before is &quot; swap plus print tableSpiralIsNewComponentPseudoGeometricInPlace_after tableSpiralIsNewComponentPseudoGeometricInPlace_before plus &quot;tableSpiralIsNewComponentPseudoGeometricInPlace_sum&quot; store tableSpiralIsNewComponentPseudoGeometricInPlace_sum &quot;tableSpiralIsNewComponentPseudoGeometricInPlace: before after sum is&quot; swap plus print tableSpiralIsNewComponentPseudoGeometricInPlace_after tableSpiralIsNewComponentPseudoGeometricInPlace_sum divide &quot;tableSpiralIsNewComponentPseudoGeometricInPlace_sum_ratio&quot; store tableSpiralIsNewComponentPseudoGeometricInPlace_sum_ratio &quot;tableSpiralIsNewComponentPseudoGeometricInPlace: old / sum ratio is &quot; swap plus print tableSpiralIsNewComponentPseudoGeometricInPlace_before 0.000000e+00 equals oP -1.000000e+00 &quot;tableSpiralIsNewComponentPseudoGeometricInPlace_before&quot; store cP ift tableSpiralIsNewComponentPseudoGeometricInPlace_after tableSpiralIsNewComponentPseudoGeometricInPlace_before divide &quot;tableSpiralIsNewComponentPseudoGeometricInPlace_after_before_ratio&quot; store tableSpiralIsNewComponentPseudoGeometricInPlace_after_before_ratio &quot;tableSpiralIsNewComponentPseudoGeometricInPlace: old / new ratio (USING) is &quot; swap plus print tableSpiralIsNewComponentPseudoGeometricInPlace_after_before_ratio tableNewComponentThresh langle oP 1 dup &quot;tableSpiralIsNewComponentPseudoGeometricInPlace: IS a new component, returning &quot; swap plus print cP oP 0 dup &quot;tableSpiralIsNewComponentPseudoGeometricInPlace: AIN&apos;T a new component, returning &quot; swap plus print cP ifte dup &quot;tableSpiralIsNewComponentPseudoGeometricInPlace: returning &quot; swap plus print cP oP &quot;tableSpiralIsNewComponentPseudoGeometricInPlace: numClasses is 0 so returning 1&quot; print 1 cP ifte )<br/></td><td></td></tr>
<tr><td>1.000000e-01<br/></td><td></td></tr>
<tr><td>1.000000e-01<br/></td><td></td></tr>
<tr><td>( /* if you are in blocks, you will end up back in blocks. if not you will get whatever you had. */ tableRestoreFromBlocks tableSwapToBlocks clearClassLabels initializeAndFocusOnTempClass tableRecaptureServoSpiral tableRestoreFromBlocks )<br/></td><td></td></tr>
<tr><td>( /* if you are in blocks, you will end up back in blocks. if not you will get whatever you had. */ tableRestoreFromBlocks tableSwapToBlocks tableSpiralServoToBestSceneObject tableRestoreFromBlocks )<br/></td><td></td></tr>
<tr><td>( /*
  tableSpiralTakeScene 
  */ tableTakeScene tableServoToBestSceneObject )<br/></td><td></td></tr>
<tr><td>( /*
  tableSpiralTakeScene 
  */ tableTakeScene tableServoToFocusedSceneObject )<br/></td><td></td></tr>
<tr><td>500<br/></td><td></td></tr>
<tr><td>500<br/></td><td></td></tr>
<tr><td>( sceneClearObservedMap tableUpdateSpiral )<br/></td><td></td></tr>
<tr><td>( 3 changeToHeight cameraGetCurrentHeightReticleY cameraGetCurrentHeightReticleX sceneSetVanishingPointFromPixel /* 
  moveCropToCenterVanishingPointSlideHeightReticles
  */ )<br/></td><td></td></tr>
<tr><td>( sceneClearObservedMap 10 3.800000e-01 sceneUpdateObservedFromStreamBufferAtZNoRecalcAll sceneRecalculateObservedMusAndSigmas sceneRenderScene ) &quot;Render the stream buffer into the observed map.&quot; setHelp<br/></td><td>Render the stream buffer into the observed map.</td></tr>
<tr><td>( tableBlockUsingBlocks not oP 0.000000e+00 &quot;scenePredictedMapThresh&quot; store slide oP pushClassLabels 1 sP cP &quot;tableSwapClassLabels&quot; store focusedClassLabel &quot;tableSwapTargetClass&quot; store clearClassLabels tableBlockMaxGraspThickness &quot;thisBlockGraspThickness&quot; store oP tableBlockMaxGraspThickness thisBlockGraspThickness minus tableBlockGripperThrow langle tableBlockMaxGraspThickness thisBlockGraspThickness minus tableBlockGripperThrow equals or cP oP tableBlockCollarWidth tableBlockTargetContactWidth thisBlockGraspThickness sceneFabricateIdealBlockModel thisBlockGraspThickness tableBlockGraspResolution minus &quot;thisBlockGraspThickness&quot; store cP whileCollapsed setGraspModeTo3D 0 sceneSetClassificationMode 1 &quot;tableBlockUsingBlocks&quot; store &quot;tableSwapToBlocks: swapped to blocks.&quot; print cP oP clearClassLabels tableBlockMaxGraspThickness &quot;thisBlockGraspThickness&quot; store oP tableBlockMaxGraspThickness thisBlockGraspThickness minus tableBlockGripperThrow langle tableBlockMaxGraspThickness thisBlockGraspThickness minus tableBlockGripperThrow equals or cP oP tableBlockCollarWidth tableBlockTargetContactWidth thisBlockGraspThickness sceneFabricateIdealBlockModel thisBlockGraspThickness tableBlockGraspResolution minus &quot;thisBlockGraspThickness&quot; store cP whileCollapsed setGraspModeTo3D 0 sceneSetClassificationMode 1 &quot;tableBlockUsingBlocks&quot; store &quot;tableSwapToBlocks: swapped to blocks but already holding blocks, not storing state.&quot; print cP ifte 0.000000e+00 sceneSetScoreThresh 0.000000e+00 &quot;tableDefaultScoreThresh&quot; store )<br/></td><td></td></tr>
<tr><td>( /*
  tableTakeScene1D

  tableTakeScene2D

  tableTakeScene2DNoReconstruct
  tableReconstructLightSlabWithoutZ
  tableUpdateMaps

  tableTakeScene2DNoReconstruct
  1 &quot;tableCellCountThreshold&quot; store tableReconstructWithOOPNarrow
  tableUpdateMaps

  0.3 sceneSetObservedRGBFromVariance sceneRenderObservedMap

  0.01 setGridSize ( zDown ) 23 replicateWord waitUntilAtCurrentPosition 


  tableTakeScene2DClose
  tableTakeScene0D

  tableTakeScene2D


  (
    tableTakeScene2DNoReconstruct

    0.01 setGridSize ( localXUp ) 4 replicateWord
    0.01 setGridSize ( localYUp ) 2 replicateWord

    2 &quot;tableCellCountThreshold&quot; store 
    tableReconstructWithOOPNarrow

    0.01 setGridSize ( localXDown ) 4 replicateWord
    0.01 setGridSize ( localYDown ) 2 replicateWord
  ) &quot;tableReconstructWithZ&quot; store

  tableReconstructFromStream
  tableUpdateMaps
  */ tableTakeScene1D )<br/></td><td></td></tr>
<tr><td>( oP tableTakeScene0DNoReconstruct 1.000000e-02 setGridSize oP localXUp cP 4 replicateWord 1.000000e-02 setGridSize oP localYUp cP 2 replicateWord 2 &quot;tableCellCountThreshold&quot; store tableReconstructWithOOPWide 1.000000e-02 setGridSize oP localXDown cP 4 replicateWord 1.000000e-02 setGridSize oP localYDown cP 2 replicateWord cP &quot;tableReconstructWithZ&quot; store tableReconstructFromStream tableUpdateMaps )<br/></td><td></td></tr>
<tr><td>( sceneClearObservedMap clearStreamBuffers tableUpdatePauseCoreNoClean table0DCellCountThreshold &quot;tableCellCountThreshold&quot; store tableUpdateMaps )<br/></td><td></td></tr>
<tr><td>( tableTakeScene1DNoReconstruct /* integrate results */ /* this actually needs to happen after movement so position is still correct for FIXATION calibrators */ oP tableReconstructWithZTable1D cP &quot;tableReconstructWithZ&quot; store tableReconstructFromStream tableUpdateMaps )<br/></td><td></td></tr>
<tr><td>( quarterImpulse waitUntilAtCurrentPosition setMovementStateToMoving comeToStop currentPose &quot;tableUpdateSpiralPos&quot; store /* clear it all */ sceneClearObservedMap clearStreamBuffers 2.000000e-02 setW1AngleThresh 1.000000e-02 setW1GoThresh 1.000000e-01 setSpeed 1.000000e-02 setGridSize /* 20 */ 14 &quot;panCoreSteps&quot; store 1.000000e-02 setGridSize /*
  tableUpdatePanCoreNoClean
  tableUpdateTiltCoreNoClean
  0.02 setSpeed
  tableUpdateStrafeCoreNoClean
  0.02 setSpeed
  tableUpdateStrafeCoreNoClean
  0.02 setSpeed
  tableUpdateStrafeCoreNoClean
  0.02 setSpeed
  tableUpdateStrafeCoreNoClean
  0.02 setSpeed
  tableUpdateStrafeCoreNoClean

  tableUpdatePanCoreNoClean
  aboutFace
  tableUpdatePanCoreNoClean
*/ tableUpdatePanCoreNoClean tableUpdatePanCoreNoClean /*
  aboutFace

  tableUpdatePanCoreNoClean
*/ /*
  7 &quot;panCoreSteps&quot; store
  comeToStop
  tableUpdatePanCoreNoClean

  14 &quot;panCoreSteps&quot; store
  ( zDown ) 7 replicateWord
  comeToStop
  tableUpdatePanCoreNoClean

  21 &quot;panCoreSteps&quot; store
  ( zDown ) 7 replicateWord
  comeToStop
  tableUpdatePanCoreNoClean
*/ /*
  tableUpdatePanCoreNoClean
  0.4 setSpeed
  quarterTurn
  comeToStop
  0.07 setSpeed
  tableUpdatePanCoreNoClean
*/ table1DCellCountThreshold &quot;tableCellCountThreshold&quot; store quarterImpulse tableUpdateSpiralPos moveEeToPoseWord waitUntilAtCurrentPosition )<br/></td><td></td></tr>
<tr><td>( tableTakeScene2DNoReconstruct /* integrate results */ /* this actually needs to happen after movement so position is still correct for FIXATION calibrators */ oP tableReconstructWithZTable2D cP &quot;tableReconstructWithZ&quot; store tableReconstructFromStream tableUpdateMaps )<br/></td><td></td></tr>
<tr><td>( oP tableTakeScene2DCloseNoReconstruct 1.000000e-02 setGridSize oP localXUp cP 4 replicateWord 1.000000e-02 setGridSize oP localYUp cP 2 replicateWord 2 &quot;tableCellCountThreshold&quot; store tableReconstructWithOOPNarrow 1.000000e-02 setGridSize oP localXDown cP 4 replicateWord 1.000000e-02 setGridSize oP localYDown cP 2 replicateWord cP &quot;tableReconstructWithZ&quot; store tableReconstructFromStream tableUpdateMaps )<br/></td><td></td></tr>
<tr><td>( quarterImpulse waitUntilAtCurrentPosition 1.625000e-02 /* XXX no commit */ 3.000000e+00 divide &quot;tableSpiralGridSize&quot; store /* 0.1 18 0.02 */ 1.000000e-01 &quot;tableSpiralMoveSpeed&quot; store 1.000000e-02 setW1GoThresh 18 &quot;tableUpdateSpiralN&quot; store currentPose &quot;tableUpdateSpiralPos&quot; store /* clear it all */ sceneClearObservedMap clearStreamBuffers /*
  tableUpdateSpiralCoreNoClean tableUpdateMaps
  1 0 tableUpdateSpiralN tableUpdateSpiralEccentricCore tableUpdateMaps
  tableUpdateZoomCoreNoClean
  tableUpdateSpinCoreNoClean
  tableUpdateMagCoreNoClean

  tableUpdateMagicEyeCoreNoClean
  tableUpdatePanCoreNoClean
  */ tableUpdateSpiralCoreNoClean 2 &quot;tableCellCountThreshold&quot; store tableUpdateMaps quarterImpulse tableUpdateSpiralPos moveEeToPoseWord waitUntilAtCurrentPosition )<br/></td><td></td></tr>
<tr><td>( quarterImpulse waitUntilAtCurrentPosition 1.625000e-02 /* XXX no commit */ 1.000000e+00 divide &quot;tableSpiralGridSize&quot; store /* 0.1 18 0.02 */ 1.000000e-01 &quot;tableSpiralMoveSpeed&quot; store 3.000000e-02 setW1GoThresh 18 &quot;tableUpdateSpiralN&quot; store currentPose &quot;tableUpdateSpiralPos&quot; store /* clear it all */ sceneClearObservedMap clearStreamBuffers /*
  tableUpdateSpiralCoreNoClean tableUpdateMaps
  1 0 tableUpdateSpiralN tableUpdateSpiralEccentricCore tableUpdateMaps
  tableUpdateZoomCoreNoClean
  tableUpdateSpinCoreNoClean
  tableUpdateMagCoreNoClean

  tableUpdateMagicEyeCoreNoClean
  tableUpdatePanCoreNoClean
  */ tableUpdateSpiralCoreNoClean table2DCellCountThreshold &quot;tableCellCountThreshold&quot; store tableUpdateMaps quarterImpulse tableUpdateSpiralPos moveEeToPoseWord waitUntilAtCurrentPosition )<br/></td><td></td></tr>
<tr><td>( tableTakeScene2DNoReconstruct oP tableReconstructWithZTable cP &quot;tableReconstructWithZ&quot; store tableReconstructFromStream tableUpdateMaps )<br/></td><td></td></tr>
<tr><td>( shoreUp tableTakeScene bg sceneSaveObservedMap tableSetBackgroundFromObserved tableInit )<br/></td><td></td></tr>
<tr><td>( oP incrementTargetClass 8.516529e-01 sceneRegularizeSceneL2 tableMergeFocusedClass cP numClasses 1 minus replicateWord sceneClearPredictedObjects tableUpdateMaps /* initializeAndFocusOnNewClass
  0.1 sceneGrabDiscrepantCropAsClass
  writeFocusedClass */ )<br/></td><td></td></tr>
<tr><td>( currentPose 3.000000e-02 setGridSize tableUpdateObservedFromWristFivePoint eighthTurn 2.000000e-02 setGridSize tableUpdateObservedFromWristFivePoint eighthTurn 1.000000e-02 setGridSize tableUpdateObservedFromWristFivePoint moveEeToPoseWord )<br/></td><td></td></tr>
<tr><td>( fullImpulse 1.000000e-01 setGridSize xUp yUp waitUntilAtCurrentPosition setMovementStateToMoving comeToStop 3.000000e-02 setSpeed oP yDown waitUntilAtCurrentPosition xDown xDown oP sceneUpdateObservedFromWrist 2.000000e-01 waitForSeconds cP doUntilAtCurrentPosition cP 2 replicateWord )<br/></td><td></td></tr>
<tr><td>( tableTakeScene /*
  shutdownToSensorsAndMovement
  disableDiskStreaming

    1 0 1 0 0 0 
  setSisFlags

  0.02 setSpeed

  0.02 setGridSize

  0.02 setW1AngleThresh
  0.01 setW1GoThresh

  waitUntilAtCurrentPosition
  activateSensorStreaming

  ( xUp ) 6 replicateWord
  waitUntilAtCurrentPosition

  ( yUp ) 6 replicateWord
  waitUntilAtCurrentPosition

  ( xDown ) 6 replicateWord
  waitUntilAtCurrentPosition

  ( yDown ) 6 replicateWord
  waitUntilAtCurrentPosition

  deactivateSensorStreaming
  bringUpAllNonessentialSystems
  */ )<br/></td><td></td></tr>
<tr><td>( /* turn streaming on, no disk streaming */ shutdownToSensorsAndMovement disableDiskStreaming /* Pose Range Image Joints Word Label */ 1 0 1 0 0 0 setSisFlags /* spiral scan pattern */ 3.000000e-02 setSpeed 1.000000e-01 setSpeed 1.000000e-02 setGridSize 10 &quot;panCoreSteps&quot; store 7.500000e-03 setW1GoThresh 2.000000e-02 setW1AngleThresh ikModeIkFast 0 setCurrentIKFastMode oP localXUp cP panCoreSteps replicateWord waitUntilAtCurrentPosition setMovementStateToMoving comeToStop waitUntilAtCurrentPosition setMovementStateToMoving comeToStop activateSensorStreaming 2.000000e+00 waitForSeconds deactivateSensorStreaming oP localXDown cP panCoreSteps replicateWord waitUntilAtCurrentPosition setMovementStateToMoving comeToStop waitUntilAtCurrentPosition setMovementStateToMoving comeToStop activateSensorStreaming 2.000000e+00 waitForSeconds deactivateSensorStreaming /* turn streaming off */ bringUpAllNonessentialSystems 2.000000e-02 setW1GoThresh )<br/></td><td></td></tr>
<tr><td>( sceneScoreThresh sceneComposePredictedMapThreshed tableRegularizePredictedMap sceneUpdateDiscrepancy sceneDensityFromDiscrepancy )<br/></td><td></td></tr>
<tr><td>( setMovementStateToMoving xUp yUp waitWord oP sceneUpdateObservedFromWrist cP 2 replicateWord yDown yDown waitWord oP sceneUpdateObservedFromWrist cP 2 replicateWord xDown xDown waitWord oP sceneUpdateObservedFromWrist cP 2 replicateWord yUp yUp waitWord oP sceneUpdateObservedFromWrist cP 2 replicateWord xUp yDown waitWord oP sceneUpdateObservedFromWrist cP 2 replicateWord )<br/></td><td></td></tr>
<tr><td>( /* turn streaming on, no disk streaming */ shutdownToSensorsAndMovement disableDiskStreaming /* Pose Range Image Joints Word Label */ 1 0 1 0 0 0 setSisFlags shoreUp /*
  ikModeIkFast 0 setCurrentIKFastMode
  */ activateSensorStreaming oP localXUp waitUntilAtCurrentPosition cP panCoreSteps replicateWord oP localXDown waitUntilAtCurrentPosition cP panCoreSteps replicateWord oP localXDown waitUntilAtCurrentPosition cP panCoreSteps replicateWord oP localXUp waitUntilAtCurrentPosition cP panCoreSteps replicateWord deactivateSensorStreaming shoreUp /* turn streaming off */ bringUpAllNonessentialSystems )<br/></td><td></td></tr>
<tr><td>( /* turn streaming on, no disk streaming */ shutdownToSensorsAndMovement disableDiskStreaming /* Pose Range Image Joints Word Label */ 1 0 1 0 0 0 setSisFlags ikModeIkFast 0 setCurrentIKFastMode activateSensorStreaming pauseCoreSeconds waitForSeconds deactivateSensorStreaming shoreUp /* turn streaming off */ bringUpAllNonessentialSystems )<br/></td><td></td></tr>
<tr><td>( /* turn streaming on, no disk streaming */ shutdownToSensorsAndMovement disableDiskStreaming /* Pose Range Image Joints Word Label */ 1 0 1 0 0 0 setSisFlags 2.000000e-02 setW1AngleThresh /*
  0.005 setGridSize
  ( xUp yUp ) 3 replicateWord
  waitUntilAtCurrentPosition
  activateSensorStreaming
  ( ( oZDown ) 30 replicateWord waitUntilAtCurrentPosition ) 8 replicateWord
  ( ( oZUp ) 30 replicateWord waitUntilAtCurrentPosition ) 8 replicateWord
  deactivateSensorStreaming

  ( xDown ) 6 replicateWord
  waitUntilAtCurrentPosition
  activateSensorStreaming
  ( ( oZDown ) 30 replicateWord waitUntilAtCurrentPosition ) 8 replicateWord
  ( ( oZUp ) 30 replicateWord waitUntilAtCurrentPosition ) 8 replicateWord
  deactivateSensorStreaming

  ( yDown ) 6 replicateWord
  waitUntilAtCurrentPosition
  activateSensorStreaming
  ( ( oZDown ) 30 replicateWord waitUntilAtCurrentPosition ) 8 replicateWord
  ( ( oZUp ) 30 replicateWord waitUntilAtCurrentPosition ) 8 replicateWord
  deactivateSensorStreaming

  ( xUp ) 6 replicateWord
  waitUntilAtCurrentPosition
  activateSensorStreaming
  ( ( oZDown ) 30 replicateWord waitUntilAtCurrentPosition ) 8 replicateWord
  ( ( oZUp ) 30 replicateWord waitUntilAtCurrentPosition ) 8 replicateWord
  deactivateSensorStreaming

  ( xDown yDown ) 3 replicateWord
  waitUntilAtCurrentPosition
  activateSensorStreaming
  ( ( oZDown ) 30 replicateWord waitUntilAtCurrentPosition ) 8 replicateWord
  ( ( oZUp ) 30 replicateWord waitUntilAtCurrentPosition ) 8 replicateWord
  deactivateSensorStreaming
  */ 1.000000e-02 setGridSize 1.500000e-01 setSpeed oP setMovementStateToMoving oP oZDown cP 30 replicateWord waitUntilAtCurrentPosition comeToStop activateSensorStreaming 1.000000e+00 waitForSeconds deactivateSensorStreaming cP 20 replicateWord waitUntilAtCurrentPosition /* turn streaming off */ bringUpAllNonessentialSystems )<br/></td><td></td></tr>
<tr><td>( &quot;tableUpdateSpiral, pointing to another&quot; print 10 tableUpdateSpiralCore )<br/></td><td></td></tr>
<tr><td>( &quot;tableUpdateSpiralN&quot; store currentPose &quot;tableUpdateSpiralPos&quot; store /* clear it all */ sceneClearObservedMap clearStreamBuffers 3.000000e-02 setW1GoThresh tableUpdateSpiralCoreNoClean /* integrate results */ tableUpdateSpiralCoreIntegrate tableUpdateMaps quarterImpulse tableUpdateSpiralPos moveEeToPoseWord waitUntilAtCurrentPosition )<br/></td><td></td></tr>
<tr><td>( tableSpiralStreamTakeSceneSamples &quot;tableReconstructStreamTakeSceneSamples&quot; store tableReconstructFromStream )<br/></td><td></td></tr>
<tr><td>( /* turn streaming on, no disk streaming */ shutdownToSensorsAndMovement disableDiskStreaming /* Pose Range Image Joints Word Label */ 1 0 1 0 0 0 setSisFlags activateSensorStreaming /* spiral scan pattern */ tableSpiralMoveSpeed setSpeed tableSpiralGridSize setGridSize /* shiftIntoGraspGear1 waitUntilAtCurrentPosition */ 1 &quot;tableUpdateSpiralIdx&quot; store oP tableUpdateSpiralIdx tableUpdateSpiralN langle cP oP oP localXUp waitUntilAtCurrentPosition cP tableUpdateSpiralIdx replicateWord oP 2.000000e-01 waitForSeconds cP doUntilAtCurrentPosition oP localYUp waitUntilAtCurrentPosition cP tableUpdateSpiralIdx replicateWord oP 2.000000e-01 waitForSeconds cP doUntilAtCurrentPosition oP localXDown waitUntilAtCurrentPosition cP tableUpdateSpiralIdx 1 plus replicateWord oP 2.000000e-01 waitForSeconds cP doUntilAtCurrentPosition oP localYDown waitUntilAtCurrentPosition cP tableUpdateSpiralIdx 1 plus replicateWord oP 2.000000e-01 waitForSeconds cP doUntilAtCurrentPosition &quot;tableUpdateSpiralCoreNoClean&quot; print tableUpdateSpiralIdx 2 plus &quot;tableUpdateSpiralIdx&quot; store cP whileCollapsed /* turn streaming off */ deactivateSensorStreaming bringUpAllNonessentialSystems )<br/></td><td></td></tr>
<tr><td>( &quot;tableUpdateSpiralN&quot; store &quot;tableUpdateSpiralYNum&quot; store &quot;tableUpdateSpiralXNum&quot; store currentPose &quot;tableUpdateSpiralPos&quot; store /* clear it all */ sceneClearObservedMap sceneClearPredictedObjects clearStreamBuffers tableUpdateSpiralEccentricCoreNoClean /* integrate results */ tableUpdateSpiralCoreIntegrate tableUpdateMaps quarterImpulse tableUpdateSpiralPos moveEeToPoseWord waitUntilAtCurrentPosition )<br/></td><td></td></tr>
<tr><td>( /* turn streaming on, no disk streaming */ shutdownToSensorsAndMovement disableDiskStreaming /* Pose Range Image Joints Word Label */ 1 0 1 0 0 0 setSisFlags activateSensorStreaming /* spiral scan pattern */ tableSpiralMoveSpeed setSpeed tableSpiralGridSize setGridSize 1 &quot;tableUpdateSpiralIdx&quot; store oP tableUpdateSpiralIdx tableUpdateSpiralN langle cP oP oP xUp waitUntilAtCurrentPosition cP tableUpdateSpiralIdx tableUpdateSpiralXNum times replicateWord oP 2.000000e-01 waitForSeconds cP doUntilAtCurrentPosition oP yUp waitUntilAtCurrentPosition cP tableUpdateSpiralIdx tableUpdateSpiralYNum times replicateWord oP 2.000000e-01 waitForSeconds cP doUntilAtCurrentPosition oP xDown waitUntilAtCurrentPosition cP tableUpdateSpiralIdx tableUpdateSpiralXNum times 1 tableUpdateSpiralXNum times plus replicateWord oP 2.000000e-01 waitForSeconds cP doUntilAtCurrentPosition oP yDown waitUntilAtCurrentPosition cP tableUpdateSpiralIdx tableUpdateSpiralYNum times 1 tableUpdateSpiralYNum times plus replicateWord oP 2.000000e-01 waitForSeconds cP doUntilAtCurrentPosition &quot;tableUpdateSpiralEccentricCore&quot; print tableUpdateSpiralIdx 2 plus &quot;tableUpdateSpiralIdx&quot; store cP whileCollapsed /* turn streaming off */ deactivateSensorStreaming bringUpAllNonessentialSystems )<br/></td><td></td></tr>
<tr><td>( 5.000000e-02 setSpeed 3.000000e-02 setW1GoThresh &quot;tableUpdateSpiralN&quot; store 1 &quot;tableUpdateSpiralIdx&quot; store oP tableUpdateSpiralIdx tableUpdateSpiralN langle cP oP oP xUp cP tableUpdateSpiralIdx replicateWord oP 2.000000e-01 waitForSeconds sceneUpdateObservedFromWrist cP doUntilAtCurrentPosition oP yUp cP tableUpdateSpiralIdx replicateWord oP 2.000000e-01 waitForSeconds sceneUpdateObservedFromWrist cP doUntilAtCurrentPosition oP xDown cP tableUpdateSpiralIdx 1 plus replicateWord oP 2.000000e-01 waitForSeconds sceneUpdateObservedFromWrist cP doUntilAtCurrentPosition oP yDown cP tableUpdateSpiralIdx 1 plus replicateWord oP 2.000000e-01 waitForSeconds sceneUpdateObservedFromWrist cP doUntilAtCurrentPosition &quot;tableUpdateSpiralRing&quot; print tableUpdateSpiralIdx 2 plus &quot;tableUpdateSpiralIdx&quot; store cP whileCollapsed )<br/></td><td></td></tr>
<tr><td>( 5.000000e-02 setSpeed 3.000000e-02 setW1GoThresh &quot;tableUpdateSpiralN&quot; store 1 &quot;tableUpdateSpiralIdx&quot; store oP tableUpdateSpiralIdx tableUpdateSpiralN langle cP oP oP xUp cP tableUpdateSpiralIdx replicateWord waitWord sceneUpdateObservedFromWrist oP yUp cP tableUpdateSpiralIdx replicateWord waitWord sceneUpdateObservedFromWrist oP xDown cP tableUpdateSpiralIdx 1 plus replicateWord waitWord sceneUpdateObservedFromWrist oP yDown cP tableUpdateSpiralIdx 1 plus replicateWord waitWord sceneUpdateObservedFromWrist &quot;tableUpdateSpiralStop&quot; print tableUpdateSpiralIdx 2 plus &quot;tableUpdateSpiralIdx&quot; store cP whileCollapsed )<br/></td><td></td></tr>
<tr><td>( /* turn streaming on, no disk streaming */ shutdownToSensorsAndMovement disableDiskStreaming /* Pose Range Image Joints Word Label */ 1 0 1 0 0 0 setSisFlags /*
  ikModeIkFast 0 setCurrentIKFastMode
  */ activateSensorStreaming oP localYUp waitUntilAtCurrentPosition cP panCoreSteps replicateWord oP localYDown waitUntilAtCurrentPosition cP panCoreSteps replicateWord oP localYDown waitUntilAtCurrentPosition cP panCoreSteps replicateWord oP localYUp waitUntilAtCurrentPosition cP panCoreSteps replicateWord deactivateSensorStreaming shoreUp /* turn streaming off */ bringUpAllNonessentialSystems )<br/></td><td></td></tr>
<tr><td>( tiltCoreGridSize setGridSize currentPose &quot;tiltCoreHome&quot; store oP 8.000000e-01 setSpeed oP oXDown cP tiltCoreAmount replicateWord setMovementStateToMoving comeToStop 1.000000e-02 setSpeed tableUpdatePauseCoreNoClean cP tiltCoreTimes replicateWord quarterImpulse tiltCoreHome moveEeToPoseWord oP 8.000000e-01 setSpeed oP oXUp cP tiltCoreAmount replicateWord setMovementStateToMoving comeToStop 1.000000e-02 setSpeed tableUpdatePauseCoreNoClean cP tiltCoreTimes replicateWord quarterImpulse tiltCoreHome moveEeToPoseWord oP 8.000000e-01 setSpeed oP oYDown cP tiltCoreAmount replicateWord setMovementStateToMoving comeToStop 1.000000e-02 setSpeed tableUpdatePauseCoreNoClean cP tiltCoreTimes replicateWord quarterImpulse tiltCoreHome moveEeToPoseWord oP 8.000000e-01 setSpeed oP oYUp cP tiltCoreAmount replicateWord setMovementStateToMoving comeToStop 1.000000e-02 setSpeed tableUpdatePauseCoreNoClean cP tiltCoreTimes replicateWord quarterImpulse tiltCoreHome moveEeToPoseWord )<br/></td><td></td></tr>
<tr><td>( /* turn streaming on, no disk streaming */ shutdownToSensorsAndMovement disableDiskStreaming /* Pose Range Image Joints Word Label */ 1 0 1 0 0 0 setSisFlags /* spiral scan pattern */ 3.000000e-02 setSpeed 2.000000e-02 setW1AngleThresh 1.000000e-02 setW1GoThresh /*
  0.005 setGridSize
  40 &quot;zoomCoreSteps&quot; store
  (
    ( setMovementStateToMoving localZDown waitUntilAtCurrentPosition comeToStop activateSensorStreaming 1.0 waitForSeconds deactivateSensorStreaming ) zoomCoreSteps replicateWord
    gridSize 2.0 divide setGridSize
    zDown
    gridSize 2.0 times setGridSize
    ( setMovementStateToMoving localZUp waitUntilAtCurrentPosition comeToStop activateSensorStreaming 1.0 waitForSeconds deactivateSensorStreaming ) zoomCoreSteps replicateWord
  ) 1 replicateWord
  */ 2.000000e-02 setSpeed 5.000000e-03 setGridSize 100 &quot;zoomCoreSteps&quot; store ikModeIkFast 0 setCurrentIKFastMode waitUntilAtCurrentPosition setMovementStateToMoving comeToStop 3.000000e+00 waitForSeconds activateSensorStreaming oP zUp waitUntilAtCurrentPosition cP zoomCoreSteps replicateWord oP zDown waitUntilAtCurrentPosition cP zoomCoreSteps replicateWord deactivateSensorStreaming /* turn streaming off */ bringUpAllNonessentialSystems )<br/></td><td></td></tr>
<tr><td>( &quot;scene&quot; import tableInit assumeBeeHome 1 changeToHeight waitUntilAtCurrentPosition tableShortTakeScene sceneClearPredictedObjects &quot;brush&quot; tablePredictAndRenderFile clearMapForPatrol clearBlueBoxMemories tableMapFocusedClass waitUntilAtCurrentPosition setMovementStateToMoving comeToStop tableMapFocusedClass deliverTargetObject )<br/></td><td></td></tr>
<tr><td>( 1.000000e-02 setGridSize 1 setCurrentIKBoundaryMode assumeBeeHome oP yUp cP 15 replicateWord oP xUp cP 30 replicateWord oP oP yDown cP 5 replicateWord oP oP xDown cP 10 replicateWord waitUntilAtCurrentPosition temp_mapFrame cP 11 replicateWord oP xUp cP 110 replicateWord waitUntilAtCurrentPosition cP 7 replicateWord )<br/></td><td></td></tr>
<tr><td>( 1.000000e-02 setGridSize 1 setCurrentIKBoundaryMode assumeBeeHome 0 changeToHeight oP yUp cP 15 replicateWord oP xUp cP 10 replicateWord oP oP yDown cP 5 replicateWord oP oP xDown cP 10 replicateWord comeToStop temp_mapFrame setMovementStateToMoving cP 5 replicateWord oP xUp cP 50 replicateWord comeToStop cP 7 replicateWord )<br/></td><td></td></tr>
<tr><td>( density mapEmptySpace mapClosestBlueBox )<br/></td><td></td></tr>
<tr><td>tenthImpulse<br/></td><td></td></tr>
<tr><td>throw<br/></td><td></td></tr>
<tr><td>throwOpenCV<br/></td><td></td></tr>
<tr><td>40<br/></td><td></td></tr>
<tr><td>1.000000e-02<br/></td><td></td></tr>
<tr><td>1<br/></td><td></td></tr>
<tr><td>time<br/></td><td></td></tr>
<tr><td>times<br/>*<br/></td><td>Multiply two numeric arguments.</td></tr>
<tr><td>toggleDrawClearanceMap<br/></td><td></td></tr>
<tr><td>toggleDrawIKMap<br/></td><td></td></tr>
<tr><td>toggleShouldIDoIK<br/></td><td></td></tr>
<tr><td>toggleShouldIRender<br/></td><td></td></tr>
<tr><td>toggleUseFade<br/></td><td></td></tr>
<tr><td>toggleUseGlow<br/></td><td></td></tr>
<tr><td>torsoFanAuto<br/></td><td></td></tr>
<tr><td>torsoFanOff<br/></td><td></td></tr>
<tr><td>torsoFanOn<br/></td><td></td></tr>
<tr><td>torsoFanState<br/></td><td></td></tr>
<tr><td>touchDown<br/></td><td></td></tr>
<tr><td>trainAndWriteFocusedClassKnn<br/></td><td></td></tr>
<tr><td>trainModels<br/></td><td>Rebuild the kNN model for the detectors.</td></tr>
<tr><td>trainModelsFromLabels<br/></td><td></td></tr>
<tr><td>transformPath<br/></td><td></td></tr>
<tr><td>( tableReconstructMaxLikelihoodFromStack 3.000000e-02 sceneSetObservedRGBFromVariance sceneRenderObservedMap tableUpdateMaps 2.500000e+01 sceneSmoothDiscrepancyDensity sceneRenderDiscrepancy &quot;foreground200&quot; sceneSaveObservedMap tableReconstructMaxLikelihoodFromStack 3.000000e-02 sceneSetObservedRGBFromVariance sceneRenderObservedMap tableUpdateMaps 2.500000e+01 sceneSmoothDiscrepancyDensity sceneRenderDiscrepancy &quot;foreground200&quot; sceneLoadObservedMap )<br/></td><td></td></tr>
<tr><td>trueCameraPose<br/></td><td></td></tr>
<tr><td>truePose<br/></td><td></td></tr>
<tr><td>tryToMoveToTheLastPickHeight<br/></td><td></td></tr>
<tr><td>tryToMoveToTheLastPrePickHeight<br/></td><td></td></tr>
<tr><td>tuckArms<br/></td><td></td></tr>
<tr><td>turnAboutY<br/></td><td></td></tr>
<tr><td>turnOffScanning<br/></td><td></td></tr>
<tr><td>turnOnRecordRangeMap<br/></td><td></td></tr>
<tr><td>twistThresh<br/></td><td></td></tr>
<tr><td>twistWords<br/></td><td></td></tr>
<tr><td>twoDPatrolContinue<br/></td><td></td></tr>
<tr><td>twoDPatrolStart<br/></td><td></td></tr>
<tr><td>twoPartPlaceObjectOnObject<br/></td><td></td></tr>
<tr><td>unFixCameraLighting<br/></td><td>Let the camera parmeters automatically update (this is the Baxter default).</td></tr>
<tr><td>unFixCameraLightingNoUpdate<br/></td><td></td></tr>
<tr><td>unSilenceSonar<br/></td><td></td></tr>
<tr><td>unTurnAboutY<br/></td><td></td></tr>
<tr><td>uniformlySampleHeight<br/></td><td></td></tr>
<tr><td>unmapTargetBlueBox<br/></td><td></td></tr>
<tr><td>unsubscribeCameraParameterTrackerToRosOut<br/></td><td>Unsubscribe from rosout.  We don&apos;t want to stay plugged into rosut for very long since it&apos;s so noisy.</td></tr>
<tr><td>untuckArms<br/></td><td></td></tr>
<tr><td>uploadObjectToDatabase<br/></td><td></td></tr>
<tr><td>( endArgs &quot;kr_bars/10_5_2&quot; &quot;kr_bars/10_5_4&quot; &quot;kr_bars/10_5_6&quot; &quot;kr_bars/10_5_8&quot; &quot;kr_bars/10_5_10&quot; setClassLabels incrementTargetClass 4 setMapServoMode 1 setGradientServoMode setIdleModeToEmpty /* 
  assumeBeeHome 1 changeToHeight
  clearMapForPatrol clearBlueBoxMemories mapLocal
  deliverTargetObject
  */ leftOrRightArm &quot;left&quot; equals oP -4.000000e-01 setMapSearchFenceXMin 5.000000e-01 setMapSearchFenceXMax 4.200000e-01 setMapSearchFenceYMin 1.000000e+00 setMapSearchFenceYMax cP ift leftOrRightArm &quot;right&quot; oP -4.000000e-01 setMapSearchFenceXMin 5.000000e-01 setMapSearchFenceXMax -4.200000e-01 setMapSearchFenceYMax -1.000000e+00 setMapSearchFenceYMin cP ift 140 setMapGrayBoxPixelSkirtCols 70 setMapGrayBoxPixelSkirtRows 100 setGripperMovingForce 2 setGradientServoSoftMaxIterations 2 setGradientServoHardMaxIterations 1 mappingServoTimeout createCachedClassifierFromClassLabels 1 setMapAutoPick 2 setMapServoMode 1 setSnapToFlushGrasp 1 setRandomPositionAfterPick oB sB 1.000000e-01 &quot;gazeDelta&quot; store oB sB oP 1 cP oP blink_lightshow cP whileCollapsed cB oB sB mapAndPickL cB oB sB oP 1 cP oP drand48 -5.000000e-01 plus 4.000000e+00 times 5 setHeadPanTargetSpeed drand48 20 times spinForSeconds endStackCollapseNoop cP whileCollapsed cB oB sB oP 1 cP oP 30006 &quot;gazeNumber&quot; store &quot;gaze&quot; gazeNumber &quot;.tif&quot; plus plus publishImageFileToFace gazeDelta spinForSeconds oP gazeNumber 1 plus &quot;gazeNumber&quot; store &quot;gaze&quot; gazeNumber &quot;.tif&quot; plus plus publishImageFileToFace gazeDelta spinForSeconds cP 6 replicateWord oP gazeNumber -1 plus &quot;gazeNumber&quot; store &quot;gaze&quot; gazeNumber &quot;.tif&quot; plus plus publishImageFileToFace gazeDelta spinForSeconds cP 5 replicateWord endStackCollapseNoop cP whileCollapsed cB oB sB oP 1 cP oP isGripperGripping oP nod cP ift cP whileCollapsed cB cB oP 1 cP oP slip cP whileCollapsed )<br/></td><td></td></tr>
<tr><td>1.000000e-02<br/></td><td></td></tr>
<tr><td>visionCycle<br/></td><td></td></tr>
<tr><td>visionCycleNoClassify<br/></td><td></td></tr>
<tr><td>voidCurrentMapRegion<br/></td><td></td></tr>
<tr><td>w1AngleThresh<br/></td><td></td></tr>
<tr><td>w1GoThresh<br/></td><td></td></tr>
<tr><td>waitForSeconds<br/></td><td></td></tr>
<tr><td>waitForSecondsA<br/></td><td></td></tr>
<tr><td>waitForTugThenOpenGripper<br/></td><td></td></tr>
<tr><td>waitForTugThenOpenGripperA<br/></td><td></td></tr>
<tr><td>waitGetCurrentWaitMode<br/></td><td></td></tr>
<tr><td>waitSetCurrentWaitMode<br/></td><td></td></tr>
<tr><td>waitUntilAccelerometerCallbackReceived<br/></td><td></td></tr>
<tr><td>waitUntilAccelerometerCallbackReceivedA<br/></td><td></td></tr>
<tr><td>waitUntilAtCurrentPosition<br/></td><td></td></tr>
<tr><td>waitUntilAtCurrentPositionB<br/></td><td></td></tr>
<tr><td>waitUntilAtCurrentPositionCollapse<br/></td><td></td></tr>
<tr><td>waitUntilEffort<br/></td><td></td></tr>
<tr><td>waitUntilEffortA<br/></td><td></td></tr>
<tr><td>waitUntilEndpointCallbackReceived<br/></td><td></td></tr>
<tr><td>waitUntilEndpointCallbackReceivedA<br/></td><td></td></tr>
<tr><td>waitUntilGripperNotMoving<br/></td><td></td></tr>
<tr><td>waitUntilGripperNotMovingB<br/></td><td></td></tr>
<tr><td>waitUntilGripperNotMovingC<br/></td><td></td></tr>
<tr><td>waitUntilImageCallbackReceived<br/></td><td></td></tr>
<tr><td>waitUntilImageCallbackReceivedA<br/></td><td></td></tr>
<tr><td>waitUntilOnSideOfPlane<br/></td><td></td></tr>
<tr><td>waitUntilOnSideOfPlaneB<br/></td><td></td></tr>
<tr><td>waitUntilRingBufferImageAtCurrentPosition<br/></td><td></td></tr>
<tr><td>( waitUntilRingBufferImageAtCurrentPosition setMovementStateToMoving comeToStop setMovementStateToMoving comeToStop )<br/></td><td></td></tr>
<tr><td>( oP 1 cP oP dup exec 1 waitForSeconds pop cP whileCollapsed )<br/></td><td></td></tr>
<tr><td>while<br/></td><td>While loop.  Usage:  ( 1 ) ( torsoFanOn 1 waitForSeconds torsoFanOff 1 waitForSeconds )  while</td></tr>
<tr><td>whileCollapsed<br/></td><td>While loop.  Use as in while, but collaspses the stack.  This means that if you don&apos;t exit the while, Ein will also never exit the while, and be in an infinite loop, even if you clear the stacks.</td></tr>
<tr><td>eePose: { px:-3.4999999999999998e-01, py:5.6874999999999998e-01,
    pz:2.0000000000000001e-01, qw:-2.8010000000000001e-03,
    qx:-1.5540000000000000e-03, qy:9.9999000000000005e-01,
    qz:3.0990000000000002e-03 }
<br/></td><td></td></tr>
<tr><td>eePose: { px:-6.8750000000000006e-02, py:7.1250000000000002e-01,
    pz:2.0000000000000001e-01, qw:-2.8010000000000001e-03,
    qx:-1.5540000000000000e-03, qy:9.9999000000000005e-01,
    qz:3.0990000000000002e-03 }
<br/></td><td></td></tr>
<tr><td>eePose: { px:2.8125000000000000e-01, py:8.0125000000000002e-01,
    pz:2.0000000000000001e-01, qw:-2.8010000000000001e-03,
    qx:-1.5540000000000000e-03, qy:9.9999000000000005e-01,
    qz:3.0990000000000002e-03 }
<br/></td><td></td></tr>
<tr><td>eePose: { px:6.8750000000000006e-02, py:8.1250000000000000e-01,
    pz:2.0000000000000001e-01, qw:-2.8010000000000001e-03,
    qx:-1.5540000000000000e-03, qy:9.9999000000000005e-01,
    qz:3.0990000000000002e-03 }
<br/></td><td></td></tr>
<tr><td>eePose: { px:5.7499999999999996e-01, py:3.6875000000000002e-01,
    pz:2.0124500000000001e-01, qw:-2.8010000000000001e-03,
    qx:-1.5540000000000000e-03, qy:9.9999000000000005e-01,
    qz:3.0990000000000002e-03 }
<br/></td><td></td></tr>
<tr><td>writeAlphaObjectToBetaFolders<br/></td><td></td></tr>
<tr><td>writeAlphaObjectToBetaFoldersA<br/></td><td></td></tr>
<tr><td>writeFocusedClass<br/></td><td></td></tr>
<tr><td>writeFocusedClassGrasps<br/></td><td></td></tr>
<tr><td>writeXMLEnvironment<br/></td><td></td></tr>
<tr><td>xDown<br/></td><td></td></tr>
<tr><td>xUp<br/></td><td>Move end effector up in the x dimension one unit.  Change unit size with setGridSize.  Usage:  xUp</td></tr>
<tr><td>yDown<br/></td><td></td></tr>
<tr><td>yUp<br/></td><td></td></tr>
<tr><td>zDown<br/></td><td></td></tr>
<tr><td>zUp<br/></td><td></td></tr>
<tr><td>zeroGMode<br/></td><td></td></tr>
<tr><td>zeroGOff<br/></td><td>Turns off zero gravity mode, so Ein will publish the current pose as the desired target position.</td></tr>
<tr><td>zeroGOn<br/></td><td>Turns on zero gravity mode, so that you can move the arm where you want and it will stay there.  Ein will publish the true joint position as the desired joint position.</td></tr>
<tr><td>zeroGToggle<br/></td><td>Toggle zero gravity mode.</td></tr>
<tr><td>zeroIROffset<br/></td><td></td></tr>
<tr><td>oB<br/>{<br/></td><td></td></tr>
<tr><td>sB<br/>|B<br/></td><td></td></tr>
<tr><td>sP<br/>|S<br/></td><td></td></tr>
<tr><td>or<br/>||<br/></td><td>Returns logical or of its numeric arguments. Back does not have booleans so it treats 0 (and 0.0) as false, and all other numbers as true.</td></tr>
<tr><td>cB<br/>}<br/></td><td></td></tr>
</table>
