<table><tr><th>Word</th><th>Description</th></tr>
<tr><td>not<br/>!<br/></td><td>Pops a word; pushes a 0 or a 1 depending on its truth value.</td></tr>
<tr><td>mod<br/>%<br/></td><td>Takes two ints and pushes the mod of the two ints on the stack.  25 4 % returns 1.</td></tr>
<tr><td>and<br/>&amp;&amp;<br/></td><td>Returns logical and of its numeric arguments. Back does not have booleans so it treats 0 (and 0.0) as false, and all other numbers as true.</td></tr>
<tr><td>slide<br/>&apos;<br/></td><td>Moves a word from the call stack to the data stack.</td></tr>
<tr><td>oP<br/>(<br/></td><td>Open paren; begin a compound word.</td></tr>
<tr><td>cP<br/>)<br/></td><td>Close paren; end a compound word.</td></tr>
<tr><td>times<br/>*<br/></td><td>Multiply two numeric arguments.</td></tr>
<tr><td>plus<br/>+<br/></td><td>Takes two numbers and adds them.  If two ints, returns an int; otherwise returns a double; otherwise does string.</td></tr>
<tr><td>minus<br/>-<br/></td><td>Takes two numbers and subtracts them.  `2 1 - ` produces 1.  1 2 - produces -1.</td></tr>
<tr><td>divide<br/>/<br/></td><td>Divide two numeric arguments.</td></tr>
<tr><td>executeStack<br/>;<br/></td><td></td></tr>
<tr><td>langle<br/>&lt;<br/></td><td>Takes two words and returns 1 if they are less than (by value) and 0 otherwise.  1 3 &lt; returns true, and 3 1 &lt; returns false.</td></tr>
<tr><td>leq<br/>&lt;=<br/></td><td>Takes two words and returns 1 if they are less than or equal to (by value) and 0 otherwise.</td></tr>
<tr><td>equals<br/>=<br/></td><td>Takes two words and returns 1 if they are equal (by value) and 0 otherwise.</td></tr>
<tr><td>rangle<br/>&gt;<br/></td><td>Takes two words and returns 1 if they are greater than (by value) and 0 otherwise.  1 3 &lt; returns false, and 3 1 &lt; returns true</td></tr>
<tr><td>geq<br/>&gt;=<br/></td><td>Takes two words and returns 1 if they are greater than or equal to (by value) and 0 otherwise.</td></tr>
<tr><td>car<br/>First<br/>Head<br/></td><td>Takes a compound word on the stack and returns the first word in the list.</td></tr>
<tr><td>car<br/>First<br/>Head<br/></td><td>Takes a compound word on the stack and returns the first word in the list.</td></tr>
<tr><td>pauseStackExecution<br/>Pause<br/></td><td></td></tr>
<tr><td>cdr<br/>Rest<br/>Tail<br/></td><td>Takes a compound word on the stack and returns the rest of the word (as a compound word), minus the first word.</td></tr>
<tr><td>cdr<br/>Rest<br/>Tail<br/></td><td>Takes a compound word on the stack and returns the rest of the word (as a compound word), minus the first word.</td></tr>
<tr><td>oSB<br/>[<br/></td><td></td></tr>
<tr><td>cSB<br/>]<br/></td><td></td></tr>
<tr><td>aboutFace<br/></td><td>Rotate the gripper in oZ by 180 degrees.</td></tr>
<tr><td>abs<br/></td><td>Returns the absolute value of its argument.</td></tr>
<tr><td>accumulate<br/></td><td>Accumulate entries in a compound word using an operator word.  Usage:  ( 1 1 1 ) ( + ) accumulate -&gt; 3.</td></tr>
<tr><td>activateSensorStreaming<br/></td><td>Start streaming data; you might want to set the SiS (&quot;Should I Stream?&quot;) first using setSisFlags or streamSetSis.</td></tr>
<tr><td>add3dGrasp<br/></td><td>Add the current pose as a 3D grasp relative to the focused object.  Must have locked the 3d grasp first so it knows what pose to use relative to the object.</td></tr>
<tr><td>add3dGraspPoseWord<br/></td><td>Takes an argument on the stack of an EEPose and adds that pose as a 3d grasp relative to the base object.</td></tr>
<tr><td>addPlaceOverPoint<br/></td><td></td></tr>
<tr><td>addPlaceUnderPoint<br/></td><td></td></tr>
<tr><td>analogIOCommand<br/></td><td></td></tr>
<tr><td>and<br/>&amp;&amp;<br/></td><td>Returns logical and of its numeric arguments. Back does not have booleans so it treats 0 (and 0.0) as false, and all other numbers as true.</td></tr>
<tr><td>append<br/></td><td></td></tr>
<tr><td>approachSpeed<br/></td><td></td></tr>
<tr><td>arm1By<br/></td><td></td></tr>
<tr><td>arm1Current<br/></td><td></td></tr>
<tr><td>arm1Down<br/></td><td></td></tr>
<tr><td>arm1To<br/></td><td></td></tr>
<tr><td>arm1True<br/></td><td></td></tr>
<tr><td>arm1Up<br/></td><td></td></tr>
<tr><td>arm2By<br/></td><td></td></tr>
<tr><td>arm2Current<br/></td><td></td></tr>
<tr><td>arm2Down<br/></td><td></td></tr>
<tr><td>arm2To<br/></td><td></td></tr>
<tr><td>arm2True<br/></td><td></td></tr>
<tr><td>arm2Up<br/></td><td></td></tr>
<tr><td>arm3By<br/></td><td></td></tr>
<tr><td>arm3Current<br/></td><td></td></tr>
<tr><td>arm3Down<br/></td><td></td></tr>
<tr><td>arm3To<br/></td><td></td></tr>
<tr><td>arm3True<br/></td><td></td></tr>
<tr><td>arm3Up<br/></td><td></td></tr>
<tr><td>arm4By<br/></td><td></td></tr>
<tr><td>arm4Current<br/></td><td></td></tr>
<tr><td>arm4Down<br/></td><td></td></tr>
<tr><td>arm4To<br/></td><td></td></tr>
<tr><td>arm4True<br/></td><td></td></tr>
<tr><td>arm4Up<br/></td><td></td></tr>
<tr><td>arm5By<br/></td><td></td></tr>
<tr><td>arm5Current<br/></td><td></td></tr>
<tr><td>arm5Down<br/></td><td></td></tr>
<tr><td>arm5To<br/></td><td></td></tr>
<tr><td>arm5True<br/></td><td></td></tr>
<tr><td>arm5Up<br/></td><td></td></tr>
<tr><td>arm6By<br/></td><td></td></tr>
<tr><td>arm6Current<br/></td><td></td></tr>
<tr><td>arm6Down<br/></td><td></td></tr>
<tr><td>arm6To<br/></td><td></td></tr>
<tr><td>arm6True<br/></td><td></td></tr>
<tr><td>arm6Up<br/></td><td></td></tr>
<tr><td>arm7By<br/></td><td></td></tr>
<tr><td>arm7Current<br/></td><td></td></tr>
<tr><td>arm7Down<br/></td><td></td></tr>
<tr><td>arm7To<br/></td><td></td></tr>
<tr><td>arm7True<br/></td><td></td></tr>
<tr><td>arm7Up<br/></td><td></td></tr>
<tr><td>armBackButtonState<br/></td><td></td></tr>
<tr><td>armOkButtonState<br/></td><td></td></tr>
<tr><td>armPose1Get<br/></td><td></td></tr>
<tr><td>armPose1Set<br/></td><td></td></tr>
<tr><td>armPose2Get<br/></td><td></td></tr>
<tr><td>armPose2Set<br/></td><td></td></tr>
<tr><td>armPose3Get<br/></td><td></td></tr>
<tr><td>armPose3Set<br/></td><td></td></tr>
<tr><td>armPose4Get<br/></td><td></td></tr>
<tr><td>armPose4Set<br/></td><td></td></tr>
<tr><td>armPose5Get<br/></td><td></td></tr>
<tr><td>armPose5Set<br/></td><td></td></tr>
<tr><td>armPose6Get<br/></td><td></td></tr>
<tr><td>armPose6Set<br/></td><td></td></tr>
<tr><td>armPose7Get<br/></td><td></td></tr>
<tr><td>armPose7Set<br/></td><td></td></tr>
<tr><td>armPoseToEePose<br/></td><td></td></tr>
<tr><td>armPublishJointPositionCommand<br/></td><td></td></tr>
<tr><td>armShowButtonState<br/></td><td></td></tr>
<tr><td>armedThreshold<br/></td><td></td></tr>
<tr><td>assert<br/></td><td></td></tr>
<tr><td>assertNo<br/></td><td></td></tr>
<tr><td>assumeAimedPose<br/></td><td></td></tr>
<tr><td>assumeAny3dGrasp<br/></td><td></td></tr>
<tr><td>assumeBackScanningPose<br/></td><td></td></tr>
<tr><td>assumeBeeHome<br/></td><td></td></tr>
<tr><td>assumeBest3dGrasp<br/></td><td></td></tr>
<tr><td>assumeCalibrationPose<br/></td><td></td></tr>
<tr><td>assumeCrane1<br/></td><td></td></tr>
<tr><td>assumeCurrent3dGrasp<br/></td><td></td></tr>
<tr><td>assumeDeliveryPose<br/></td><td></td></tr>
<tr><td>assumeFacePose<br/></td><td></td></tr>
<tr><td>assumeHandingPose<br/></td><td></td></tr>
<tr><td>assumePose<br/></td><td></td></tr>
<tr><td>assumeShrugPose<br/></td><td></td></tr>
<tr><td>assumeZOfPoseWord<br/></td><td></td></tr>
<tr><td>beeHome<br/></td><td></td></tr>
<tr><td>beep<br/></td><td></td></tr>
<tr><td>blankFace<br/></td><td></td></tr>
<tr><td>blur<br/></td><td></td></tr>
<tr><td>bringUpAllNonessentialSystems<br/></td><td>Bring up systems that are not important for streaming data.</td></tr>
<tr><td>buildClassSimilarityMatrix<br/></td><td>Builds the matrix of gradients of the current class labels.</td></tr>
<tr><td>buildClassSimilarityMatrixFromDensity<br/></td><td>Builds the matrix of gradients of the current class labels.</td></tr>
<tr><td>c3dPoseBase<br/></td><td></td></tr>
<tr><td>cB<br/>}<br/></td><td></td></tr>
<tr><td>cP<br/>)<br/></td><td>Close paren; end a compound word.</td></tr>
<tr><td>cSB<br/>]<br/></td><td></td></tr>
<tr><td>calibrateCameraAToB<br/></td><td></td></tr>
<tr><td>calibrateGripper<br/></td><td></td></tr>
<tr><td>calibrateRGBCameraIntrinsicsPoint<br/></td><td>Run the old wrist camera calibration, that uses a single black dot to calibrate.  You should use the new light field calibration with magic paper instead.</td></tr>
<tr><td>cameraCenterX<br/></td><td></td></tr>
<tr><td>cameraCenterY<br/></td><td></td></tr>
<tr><td>cameraCreate<br/></td><td>Creates a new camera, usage in kinect2.back</td></tr>
<tr><td>cameraCropUpperLeftCornerX<br/></td><td></td></tr>
<tr><td>cameraCropUpperLeftCornerY<br/></td><td></td></tr>
<tr><td>cameraExposure<br/></td><td></td></tr>
<tr><td>cameraFitHyperbolic<br/></td><td></td></tr>
<tr><td>cameraFitQuadratic<br/></td><td></td></tr>
<tr><td>cameraGain<br/></td><td></td></tr>
<tr><td>cameraGetCalibrationMode<br/></td><td></td></tr>
<tr><td>cameraGetCurrentHeightReticleX<br/></td><td>Height reticle x</td></tr>
<tr><td>cameraGetCurrentHeightReticleY<br/></td><td>Height reticle y</td></tr>
<tr><td>cameraGetIdxMagX<br/></td><td></td></tr>
<tr><td>cameraGetIdxMagY<br/></td><td></td></tr>
<tr><td>cameraGetTransformMatrix<br/></td><td></td></tr>
<tr><td>cameraGetVpX<br/></td><td>Vanishing point of camera.</td></tr>
<tr><td>cameraGetVpY<br/></td><td>Vanishing point of camera.</td></tr>
<tr><td>cameraInitializeConfig<br/></td><td>Initialize the configuration of the camera (reticles) with reasonable default values based on image size.</td></tr>
<tr><td>cameraKappaX<br/></td><td></td></tr>
<tr><td>cameraKappaY<br/></td><td></td></tr>
<tr><td>cameraMuX<br/></td><td></td></tr>
<tr><td>cameraMuY<br/></td><td></td></tr>
<tr><td>cameraName<br/></td><td>The name of the focused camera.</td></tr>
<tr><td>cameraPrintParams<br/></td><td></td></tr>
<tr><td>cameraR00<br/></td><td></td></tr>
<tr><td>cameraR01<br/></td><td></td></tr>
<tr><td>cameraR10<br/></td><td></td></tr>
<tr><td>cameraR11<br/></td><td></td></tr>
<tr><td>cameraSetCalibrationMode<br/></td><td></td></tr>
<tr><td>cameraSetCurrentHeightReticleX<br/></td><td></td></tr>
<tr><td>cameraSetCurrentHeightReticleY<br/></td><td></td></tr>
<tr><td>cameraSetIdxMagX<br/></td><td></td></tr>
<tr><td>cameraSetIdxMagY<br/></td><td></td></tr>
<tr><td>cameraSetTransformMatrix<br/></td><td></td></tr>
<tr><td>cameraSetVpX<br/></td><td></td></tr>
<tr><td>cameraSetVpY<br/></td><td></td></tr>
<tr><td>cameraWhiteBalanceBlue<br/></td><td></td></tr>
<tr><td>cameraWhiteBalanceGreen<br/></td><td></td></tr>
<tr><td>cameraWhiteBalanceRed<br/></td><td></td></tr>
<tr><td>cameraZeroNonLinear<br/></td><td></td></tr>
<tr><td>car<br/>First<br/>Head<br/></td><td>Takes a compound word on the stack and returns the first word in the list.</td></tr>
<tr><td>castToInteger<br/></td><td></td></tr>
<tr><td>catScan5VarianceTrialAuditClassNames<br/></td><td></td></tr>
<tr><td>catScan5VarianceTrialAutolabelClassNames<br/></td><td></td></tr>
<tr><td>catScan5VarianceTrialCalculateAllClassesAccuracy<br/></td><td></td></tr>
<tr><td>catScan5VarianceTrialCalculateConfigurationAccuracy<br/></td><td></td></tr>
<tr><td>catScan5VarianceTrialCalculatePoseVariances<br/></td><td></td></tr>
<tr><td>cdr<br/>Rest<br/>Tail<br/></td><td>Takes a compound word on the stack and returns the rest of the word (as a compound word), minus the first word.</td></tr>
<tr><td>ceil<br/></td><td></td></tr>
<tr><td>centerHead<br/></td><td></td></tr>
<tr><td>changeAnimationState<br/></td><td></td></tr>
<tr><td>changeTargetClassToClosestBlueBox<br/></td><td></td></tr>
<tr><td>changeToCounterTable<br/></td><td></td></tr>
<tr><td>changeToHeight<br/></td><td></td></tr>
<tr><td>changeToHeight0<br/></td><td></td></tr>
<tr><td>changeToHeight1<br/></td><td></td></tr>
<tr><td>changeToHeight2<br/></td><td></td></tr>
<tr><td>changeToHeight3<br/></td><td></td></tr>
<tr><td>changeToPantryTable<br/></td><td></td></tr>
<tr><td>checkAndCountGrasp<br/></td><td></td></tr>
<tr><td>checkGrasp<br/></td><td></td></tr>
<tr><td>checkIfJammed<br/></td><td></td></tr>
<tr><td>clearBlueBoxMemories<br/></td><td></td></tr>
<tr><td>clearStack<br/>clearCallStack<br/></td><td>Clear the call stack.</td></tr>
<tr><td>clearClass3dGrasps<br/></td><td></td></tr>
<tr><td>clearClassLabels<br/></td><td></td></tr>
<tr><td>clearConsole<br/></td><td>Prints a lot of newlines to the console to clear it.</td></tr>
<tr><td>clearData<br/>clearDataStack<br/></td><td>Clear the data stack.</td></tr>
<tr><td>clearData<br/>clearDataStack<br/></td><td>Clear the data stack.</td></tr>
<tr><td>clearIkMap<br/></td><td>Reset the IK Map so that every cell is good.</td></tr>
<tr><td>clearMapForPatrol<br/></td><td></td></tr>
<tr><td>clearStack<br/>clearCallStack<br/></td><td>Clear the call stack.</td></tr>
<tr><td>clearStackIntoMappingPatrol<br/></td><td></td></tr>
<tr><td>clearStacks<br/></td><td>Clear the call stack and the data stack.</td></tr>
<tr><td>clearStreamBuffers<br/></td><td></td></tr>
<tr><td>closeGripper<br/></td><td></td></tr>
<tr><td>cmp<br/></td><td>Takes two words and returns 0 if they are equal, -1 if they are less than, and 1 if they are greater than.  Works on integers, doubles and strings.</td></tr>
<tr><td>collapseStack<br/></td><td></td></tr>
<tr><td>collectMoreCrops<br/></td><td></td></tr>
<tr><td>collectMoreStreams<br/></td><td></td></tr>
<tr><td>comeToHover<br/></td><td></td></tr>
<tr><td>comeToHoverA<br/></td><td></td></tr>
<tr><td>comeToStop<br/></td><td></td></tr>
<tr><td>comeToStopA<br/></td><td></td></tr>
<tr><td>commandOtherArm<br/></td><td>Send a command to the other arm.  It takes a string on the stack and sends it as a program to be executed on the other arm.</td></tr>
<tr><td>copyIkMapToHeightIdx<br/></td><td>Copy the ik map to the height index.</td></tr>
<tr><td>cornellMugsOnTables<br/></td><td></td></tr>
<tr><td>cos<br/></td><td></td></tr>
<tr><td>createArmPose<br/></td><td></td></tr>
<tr><td>createCachedClassifierFromClassLabels<br/></td><td></td></tr>
<tr><td>createEEPose<br/></td><td></td></tr>
<tr><td>cruisingSpeed<br/></td><td></td></tr>
<tr><td>currentBackgroundMap<br/></td><td>Pushes the current background map on the stack.</td></tr>
<tr><td>currentIKBoundaryMode<br/></td><td></td></tr>
<tr><td>currentIKFastMode<br/></td><td></td></tr>
<tr><td>currentIKMode<br/></td><td></td></tr>
<tr><td>currentIKModeString<br/></td><td></td></tr>
<tr><td>currentJointWord<br/></td><td></td></tr>
<tr><td>currentObservedMap<br/></td><td>Pushes the current observed map on the stack.</td></tr>
<tr><td>currentPose<br/></td><td></td></tr>
<tr><td>currentPoseToWord<br/></td><td></td></tr>
<tr><td>currentPredictedMap<br/></td><td>Pushes the current predicted map on the stack.</td></tr>
<tr><td>currentScene<br/></td><td>Pushes the current scene on the stack.</td></tr>
<tr><td>currentSceneFixationMode<br/></td><td></td></tr>
<tr><td>currentTableZ<br/></td><td>Current location of the table at z in base.</td></tr>
<tr><td>dataDirectory<br/></td><td>The directory where data is stored.</td></tr>
<tr><td>dateString<br/></td><td></td></tr>
<tr><td>deactivateSensorStreaming<br/></td><td>Stop streaming data.</td></tr>
<tr><td>decMx<br/></td><td></td></tr>
<tr><td>decMy<br/></td><td></td></tr>
<tr><td>decrementCamera<br/></td><td></td></tr>
<tr><td>decrementCurrentCornellTable<br/></td><td></td></tr>
<tr><td>decrementTargetClass<br/></td><td></td></tr>
<tr><td>decrementTargetInstanceSprite<br/></td><td></td></tr>
<tr><td>decrementTargetMasterSprite<br/></td><td></td></tr>
<tr><td>define<br/></td><td>Store a new compound word with specified body, description, and name.  Usage:  &lt;compound word&gt; &lt; help text &gt; &lt; name &gt; define. </td></tr>
<tr><td>deliverObject<br/></td><td></td></tr>
<tr><td>deliverTargetBoxMemory<br/></td><td></td></tr>
<tr><td>deliverTargetObject<br/></td><td></td></tr>
<tr><td>density<br/></td><td></td></tr>
<tr><td>departureSpeed<br/></td><td></td></tr>
<tr><td>deref<br/></td><td>Takes a symbol word argument from the data stack and pushes its current value back onto the data stack.  Usage:  &lt; symbol word &gt; deref -&gt; &lt; value &gt; </td></tr>
<tr><td>derefToTruth<br/></td><td>Takes a symbol word argument from the data stack and pushes its current value back onto the data stack.  Usage:  &lt; symbol word &gt; deref -&gt; &lt; value &gt; </td></tr>
<tr><td>destroyObjectInEndEffector<br/></td><td></td></tr>
<tr><td>destroyTargetInstanceSprite<br/></td><td></td></tr>
<tr><td>detectionSpin<br/></td><td></td></tr>
<tr><td>diagnosticRelativePose<br/></td><td></td></tr>
<tr><td>digitalIOCommand<br/></td><td></td></tr>
<tr><td>disableDiskStreaming<br/></td><td></td></tr>
<tr><td>disableRobot<br/></td><td></td></tr>
<tr><td>dislodgeEndEffectorFromTable<br/></td><td></td></tr>
<tr><td>divide<br/>/<br/></td><td>Divide two numeric arguments.</td></tr>
<tr><td>drand48<br/></td><td></td></tr>
<tr><td>dsr<br/></td><td></td></tr>
<tr><td>ducksInARow<br/></td><td></td></tr>
<tr><td>dup<br/></td><td></td></tr>
<tr><td>eePoseApplyRelativePoseTo<br/></td><td></td></tr>
<tr><td>eePoseGetPoseRelativeTo<br/></td><td></td></tr>
<tr><td>eePosePX<br/></td><td></td></tr>
<tr><td>eePosePY<br/></td><td></td></tr>
<tr><td>eePosePZ<br/></td><td></td></tr>
<tr><td>eePoseQW<br/></td><td></td></tr>
<tr><td>eePoseQX<br/></td><td></td></tr>
<tr><td>eePoseQY<br/></td><td></td></tr>
<tr><td>eePoseQZ<br/></td><td></td></tr>
<tr><td>eePoseRPYOnQ<br/></td><td></td></tr>
<tr><td>eePoseToArmPose<br/></td><td></td></tr>
<tr><td>eeRange<br/></td><td>Range reading.</td></tr>
<tr><td>eeRangeMaxValue<br/></td><td>Range max value.</td></tr>
<tr><td>effortThresh<br/></td><td></td></tr>
<tr><td>eighthTurn<br/></td><td></td></tr>
<tr><td>einSoftwareVersion<br/></td><td>Ein&apos;s version.</td></tr>
<tr><td>enableDiskStreaming<br/></td><td></td></tr>
<tr><td>enableRobot<br/></td><td></td></tr>
<tr><td>endArgs<br/></td><td></td></tr>
<tr><td>endStackCollapse<br/></td><td></td></tr>
<tr><td>endStackCollapseNoop<br/></td><td></td></tr>
<tr><td>equals<br/>=<br/></td><td>Takes two words and returns 1 if they are equal (by value) and 0 otherwise.</td></tr>
<tr><td>eval<br/></td><td>Takes a string from the data stack; evaluates the string as a back program.  Usage:  &lt; string &gt; eval -&gt; whatever the program does</td></tr>
<tr><td>exec<br/></td><td></td></tr>
<tr><td>executePreparedGrasp<br/></td><td></td></tr>
<tr><td>executeStack<br/>;<br/></td><td></td></tr>
<tr><td>executionModeInstant<br/></td><td></td></tr>
<tr><td>executionModeStep<br/></td><td></td></tr>
<tr><td>exp<br/></td><td></td></tr>
<tr><td>expand<br/></td><td></td></tr>
<tr><td>exportDoc<br/></td><td>Export words to an html file which is displayed on the website.</td></tr>
<tr><td>exportWords<br/></td><td>Export words to a text file for documentation purposes.</td></tr>
<tr><td>faceAnimationFindEmotions<br/></td><td></td></tr>
<tr><td>faceAnimationGetMode<br/></td><td></td></tr>
<tr><td>faceAnimationGetRate<br/></td><td>Rate of the face animation in hz</td></tr>
<tr><td>faceAnimationLoadAllEmotions<br/></td><td></td></tr>
<tr><td>faceAnimationLoadEmotion<br/></td><td></td></tr>
<tr><td>faceAnimationSetEmotionValue<br/></td><td></td></tr>
<tr><td>faceAnimationSetMode<br/></td><td></td></tr>
<tr><td>faceAnimationSetRate<br/></td><td></td></tr>
<tr><td>fakeBBWidth<br/></td><td></td></tr>
<tr><td>fasterRasterScanningSpeed<br/></td><td></td></tr>
<tr><td>fetch<br/></td><td></td></tr>
<tr><td>fileClose<br/></td><td>Close the file.  If you forget to do this, it will be closed automatically when the word is deallocated.</td></tr>
<tr><td>fileOpenInput<br/></td><td>Open an input file for reading; takes a file name as an argument.</td></tr>
<tr><td>fileOpenOutput<br/></td><td>Open an output file for writing; takes a file name as an argument.</td></tr>
<tr><td>fileReadAll<br/></td><td>Read the contents of the file into a string and push it on the data stack.</td></tr>
<tr><td>fileReadLine<br/></td><td>Read one line from the file into a string and leave it on the data stack.</td></tr>
<tr><td>fileWrite<br/></td><td>Write a string to the file.  Takes a file and a word, which is written.  if it is a string, writes it as-is.  Otherwise writes it with repr.</td></tr>
<tr><td>fileWriteLine<br/></td><td>Write a line to the file.  Takes a file and a word, which is written.  if it is a string, writes it as-is.  Otherwise writes it with repr.</td></tr>
<tr><td>fillClearanceMap<br/></td><td></td></tr>
<tr><td>fillIkMap<br/></td><td>Fill the IK map for the current range starting at the i and j and height on the stack.</td></tr>
<tr><td>fillIkMapAtCurrentHeight<br/></td><td>Fill the IK map using data at the current EE height.  We run at height 2 usually.</td></tr>
<tr><td>fillIkMapAtHeights<br/></td><td>Fill the IK map at different heights.</td></tr>
<tr><td>fillIkMapFromCachedHeightIdx<br/></td><td>Fill the IK map by taking the height idx from the cache.</td></tr>
<tr><td>fillIkMapFromCachedHeights<br/></td><td>Fill the IK map by taking the and of the result at all the different heights.</td></tr>
<tr><td>filterBoxMemories<br/></td><td></td></tr>
<tr><td>fixCameraLighting<br/></td><td>Fix the camera lighting.  Usage:  &lt;exposure&gt; &lt;gain&gt; &lt;red&gt; &lt;green&gt; &lt;blue&gt; fixCameraLighting.  You can see the current values with cameraGain, cameraExposure, cameraWhiteBalanceRed, cameraWhiteBlanaceGreen, cameraWhiteBalanceBlue.</td></tr>
<tr><td>fixCameraLightingNoUpdate<br/></td><td></td></tr>
<tr><td>fixCameraLightingToAutomaticParameters<br/></td><td>Fix the camera lighting using autogain.  The camera parameters will first adjust automatically, then ein will fix them to the automatically adjusted values.</td></tr>
<tr><td>fixCameraLightingToObservedValues<br/></td><td></td></tr>
<tr><td>floor<br/></td><td></td></tr>
<tr><td>focusedCamera<br/></td><td></td></tr>
<tr><td>focusedClassLabel<br/></td><td>The focused class.</td></tr>
<tr><td>followPath<br/></td><td></td></tr>
<tr><td>fullImpulse<br/></td><td></td></tr>
<tr><td>gaitAnchoredTranslation<br/></td><td></td></tr>
<tr><td>geq<br/>&gt;=<br/></td><td>Takes two words and returns 1 if they are greater than or equal to (by value) and 0 otherwise.</td></tr>
<tr><td>get<br/></td><td>Takes a compound word on the stack and an int.  Returns the ith entry of the compound word.  Uses zero based indexing.</td></tr>
<tr><td>getSpeed<br/></td><td></td></tr>
<tr><td>goClassifyBlueBoxes<br/></td><td></td></tr>
<tr><td>goFindBlueBoxes<br/></td><td></td></tr>
<tr><td>gradientServoHardMaxIterations<br/></td><td></td></tr>
<tr><td>gradientServoMode<br/></td><td></td></tr>
<tr><td>gradientServoSoftMaxIterations<br/></td><td></td></tr>
<tr><td>graspBackoffDistance<br/></td><td></td></tr>
<tr><td>gridSize<br/></td><td></td></tr>
<tr><td>gripperMaskThresh<br/></td><td>Threshold for the gripper mask bmp.</td></tr>
<tr><td>guiCustom1<br/></td><td></td></tr>
<tr><td>guiHideAll<br/></td><td></td></tr>
<tr><td>guiShowAll<br/></td><td></td></tr>
<tr><td>halfImpulse<br/></td><td></td></tr>
<tr><td>handCameraOffset<br/></td><td></td></tr>
<tr><td>handEndEffectorOffset<br/></td><td></td></tr>
<tr><td>happyFace<br/></td><td></td></tr>
<tr><td>help<br/></td><td>Return help text for a word.  Takes a compound word as an argument with a single word inside.  Usage:  ( word ) help.</td></tr>
<tr><td>histgramAllExamplesFocusedClass<br/></td><td></td></tr>
<tr><td>histogramDetection<br/></td><td></td></tr>
<tr><td>histogramDetectionIfBlueBoxes<br/></td><td></td></tr>
<tr><td>histogramDetectionInit<br/></td><td></td></tr>
<tr><td>histogramDetectionNormalize<br/></td><td></td></tr>
<tr><td>histogramDetectionReport<br/></td><td></td></tr>
<tr><td>histogramExampleAsFocusedClass<br/></td><td></td></tr>
<tr><td>hover<br/></td><td></td></tr>
<tr><td>hoverA<br/></td><td></td></tr>
<tr><td>hoverThreshold<br/></td><td></td></tr>
<tr><td>hundredthImpulse<br/></td><td></td></tr>
<tr><td>iRCalibrationSpeed<br/></td><td></td></tr>
<tr><td>idler<br/></td><td></td></tr>
<tr><td>ifGrasp<br/></td><td></td></tr>
<tr><td>ifNoGrasp<br/></td><td></td></tr>
<tr><td>ift<br/></td><td>Takes two words on the stack, executes the second word if the first word is true.  For example, &quot; ( &quot;hello&quot; print ) 1 ift&quot; will print hello, while &quot; ( &quot;hello&quot; print ) 0 ift&quot; will not do it.</td></tr>
<tr><td>ifte<br/></td><td>If then else takes two compound words and a condition and does the first one if the condition is true and the second if it is false.   Usage: 0 ( &quot;condition was true&quot; print ) ( &quot;condition was false&quot; print )   ifte</td></tr>
<tr><td>ikMapEndHeight<br/></td><td>End height for making the IP map.</td></tr>
<tr><td>ikMapStartHeight<br/></td><td>Start height at which we make the IK map.</td></tr>
<tr><td>ikModeIkFast<br/></td><td></td></tr>
<tr><td>ikModeIkFastDebug<br/></td><td></td></tr>
<tr><td>ikModeService<br/></td><td></td></tr>
<tr><td>imageStreamBufferLoadCurrent<br/></td><td></td></tr>
<tr><td>import<br/></td><td></td></tr>
<tr><td>inc<br/></td><td>Adds one to its argument.  1 inc produces 2.</td></tr>
<tr><td>incMx<br/></td><td></td></tr>
<tr><td>incMy<br/></td><td></td></tr>
<tr><td>incrementCamera<br/></td><td></td></tr>
<tr><td>incrementCurrentCornellTable<br/></td><td></td></tr>
<tr><td>incrementImageStreamBuffer<br/></td><td>Increments the current location in the image stream buffer.  Loads it into memory and kicks it out when done.</td></tr>
<tr><td>incrementImageStreamBufferNoLoad<br/></td><td>Increments the current location in the image stream buffer.  Does not load the image into memory, but kicks it out when done.</td></tr>
<tr><td>incrementImageStreamBufferNoLoadNoKick<br/></td><td>Increments the current location in the image stream buffer.  Does not load the image into memory or kick it out when done.</td></tr>
<tr><td>incrementTargetClass<br/></td><td></td></tr>
<tr><td>incrementTargetInstanceSprite<br/></td><td></td></tr>
<tr><td>incrementTargetMasterSprite<br/></td><td></td></tr>
<tr><td>initCumulativeGripperMask<br/></td><td></td></tr>
<tr><td>initializeAndFocusOnNewClass<br/></td><td>Initialize a new class with a default date-based name and focus on it.  It will be created in the file system with default values and focused on.</td></tr>
<tr><td>initializeAndFocusOnTempClass<br/></td><td></td></tr>
<tr><td>initializeConfig<br/></td><td></td></tr>
<tr><td>initializeMap<br/></td><td></td></tr>
<tr><td>integrateImageStreamBufferCrops<br/></td><td></td></tr>
<tr><td>integrateImageStreamBufferServoImages<br/></td><td></td></tr>
<tr><td>integrateRangeStreamBuffer<br/></td><td></td></tr>
<tr><td>interlaceBottom<br/></td><td></td></tr>
<tr><td>interlaceTop<br/></td><td></td></tr>
<tr><td>interpolatePath<br/></td><td></td></tr>
<tr><td>irFixPick<br/></td><td></td></tr>
<tr><td>isAtCurrentPosition<br/></td><td></td></tr>
<tr><td>isGripperGripping<br/></td><td></td></tr>
<tr><td>isGripperMoving<br/></td><td></td></tr>
<tr><td>iterateIsbAndAccumulateHeightImages<br/></td><td></td></tr>
<tr><td>sum<br/>join<br/></td><td>Pops a compound word; sums the entries; pushes the result.  Usage:  ( 1 1 1 ) sum -&gt; 3.</td></tr>
<tr><td>langle<br/>&lt;<br/></td><td>Takes two words and returns 1 if they are less than (by value) and 0 otherwise.  1 3 &lt; returns true, and 3 1 &lt; returns false.</td></tr>
<tr><td>leftOrRightArm<br/></td><td></td></tr>
<tr><td>leq<br/>&lt;=<br/></td><td>Takes two words and returns 1 if they are less than or equal to (by value) and 0 otherwise.</td></tr>
<tr><td>lightsOff<br/></td><td></td></tr>
<tr><td>lightsOn<br/></td><td></td></tr>
<tr><td>loadCalibration<br/></td><td></td></tr>
<tr><td>loadCalibrationRaw<br/></td><td></td></tr>
<tr><td>loadConfig<br/></td><td></td></tr>
<tr><td>loadDefaultCalibration<br/></td><td></td></tr>
<tr><td>loadGripperMask<br/></td><td></td></tr>
<tr><td>loadIkMap<br/></td><td></td></tr>
<tr><td>loadIkMapAtHeight<br/></td><td></td></tr>
<tr><td>localXDown<br/></td><td></td></tr>
<tr><td>localXUp<br/></td><td></td></tr>
<tr><td>localYDown<br/></td><td></td></tr>
<tr><td>localYUp<br/></td><td></td></tr>
<tr><td>localZDown<br/></td><td></td></tr>
<tr><td>localZUp<br/></td><td></td></tr>
<tr><td>lock3dGraspBase<br/></td><td></td></tr>
<tr><td>map<br/></td><td></td></tr>
<tr><td>mapAndPick<br/></td><td></td></tr>
<tr><td>mapAndPickL<br/></td><td></td></tr>
<tr><td>mapClosestBlueBox<br/></td><td></td></tr>
<tr><td>mapEmptySpace<br/></td><td></td></tr>
<tr><td>mapFreeSpacePixelSkirt<br/></td><td></td></tr>
<tr><td>mapGrayBoxPixelSkirtCols<br/></td><td></td></tr>
<tr><td>mapGrayBoxPixelSkirtRows<br/></td><td></td></tr>
<tr><td>mapGrayBoxPixelWaistCols<br/></td><td></td></tr>
<tr><td>mapGrayBoxPixelWaistRows<br/></td><td></td></tr>
<tr><td>mapLocal<br/></td><td></td></tr>
<tr><td>mapSearchFenceXMax<br/></td><td>Xmax for the map in base.</td></tr>
<tr><td>mapSearchFenceXMin<br/></td><td>Xmin for the map in base.</td></tr>
<tr><td>mapSearchFenceYMax<br/></td><td>YMax for the map in base.</td></tr>
<tr><td>mapSearchFenceYMin<br/></td><td>Ymin for the map in base.</td></tr>
<tr><td>mapServo<br/></td><td></td></tr>
<tr><td>mapWaypoints<br/></td><td>Maps objects at locations specified by EePoseWords underneath.</td></tr>
<tr><td>mappingPatrol<br/></td><td></td></tr>
<tr><td>mappingPatrolA<br/></td><td></td></tr>
<tr><td>mappingServoTimeout<br/></td><td></td></tr>
<tr><td>markMapAsCompleted<br/></td><td></td></tr>
<tr><td>max<br/></td><td></td></tr>
<tr><td>measureTime<br/></td><td></td></tr>
<tr><td>measureTimeA<br/></td><td></td></tr>
<tr><td>measureTimeEnd<br/></td><td></td></tr>
<tr><td>measureTimeInit<br/></td><td></td></tr>
<tr><td>measureTimeInitSinceStart<br/></td><td></td></tr>
<tr><td>measureTimeSetPeriod<br/></td><td></td></tr>
<tr><td>measureTimeSinceStart<br/></td><td></td></tr>
<tr><td>measureTimeStart<br/></td><td></td></tr>
<tr><td>min<br/></td><td></td></tr>
<tr><td>minus<br/>-<br/></td><td>Takes two numbers and subtracts them.  `2 1 - ` produces 1.  1 2 - produces -1.</td></tr>
<tr><td>mkdir<br/></td><td></td></tr>
<tr><td>mkdirs<br/></td><td></td></tr>
<tr><td>mod<br/>%<br/></td><td>Takes two ints and pushes the mod of the two ints on the stack.  25 4 % returns 1.</td></tr>
<tr><td>mostRecentUntabledZ<br/></td><td></td></tr>
<tr><td>moveAndStreamAimedShot<br/></td><td></td></tr>
<tr><td>moveArmToPoseWord<br/></td><td></td></tr>
<tr><td>moveCropToCenter<br/></td><td></td></tr>
<tr><td>moveCropToCenterVanishingPoint<br/></td><td>Move the crop to the center/vanishing point of the camera.</td></tr>
<tr><td>moveCropToCenterVanishingPointSlideHeightReticles<br/></td><td></td></tr>
<tr><td>moveCropToProperValue<br/></td><td></td></tr>
<tr><td>moveCropToProperValueNoUpdate<br/></td><td></td></tr>
<tr><td>moveEeToPoseWord<br/></td><td></td></tr>
<tr><td>moveJointsByAngles<br/></td><td></td></tr>
<tr><td>moveJointsToAngles<br/></td><td></td></tr>
<tr><td>moveObjectBetweenObjectAndObject<br/></td><td></td></tr>
<tr><td>moveObjectToObjectByAmount<br/></td><td></td></tr>
<tr><td>moveObjectToPose<br/></td><td></td></tr>
<tr><td>moveTargetObjectToPose<br/></td><td></td></tr>
<tr><td>moveToCurrentCornellTable<br/></td><td></td></tr>
<tr><td>moveToEEPose<br/></td><td></td></tr>
<tr><td>moveToNextMapPosition<br/></td><td></td></tr>
<tr><td>moveToRegister<br/></td><td></td></tr>
<tr><td>moveToRegister1<br/></td><td></td></tr>
<tr><td>moveToRegister2<br/></td><td></td></tr>
<tr><td>moveToRegister3<br/></td><td></td></tr>
<tr><td>moveToRegister4<br/></td><td></td></tr>
<tr><td>moveToRegister5<br/></td><td></td></tr>
<tr><td>moveToRegister6<br/></td><td></td></tr>
<tr><td>moveToSetVanishingPointHeightHigh<br/></td><td></td></tr>
<tr><td>moveToSetVanishingPointHeightLow<br/></td><td></td></tr>
<tr><td>moveToTargetZAndGrasp<br/></td><td></td></tr>
<tr><td>moveToTargetZAndGraspA<br/></td><td></td></tr>
<tr><td>movingThreshold<br/></td><td></td></tr>
<tr><td>neutralFace<br/></td><td></td></tr>
<tr><td>next<br/></td><td></td></tr>
<tr><td>nil<br/></td><td>The empty list.  ( ) .</td></tr>
<tr><td>nod<br/></td><td></td></tr>
<tr><td>noop<br/></td><td></td></tr>
<tr><td>not<br/>!<br/></td><td>Pops a word; pushes a 0 or a 1 depending on its truth value.</td></tr>
<tr><td>now<br/></td><td></td></tr>
<tr><td>numBlueBoxes<br/></td><td></td></tr>
<tr><td>numCameras<br/></td><td></td></tr>
<tr><td>numClasses<br/></td><td></td></tr>
<tr><td>oB<br/>{<br/></td><td></td></tr>
<tr><td>oP<br/>(<br/></td><td>Open paren; begin a compound word.</td></tr>
<tr><td>oSB<br/>[<br/></td><td></td></tr>
<tr><td>oXDown<br/></td><td></td></tr>
<tr><td>oXUp<br/></td><td></td></tr>
<tr><td>oYDown<br/></td><td></td></tr>
<tr><td>oYUp<br/></td><td></td></tr>
<tr><td>oZDown<br/></td><td></td></tr>
<tr><td>oZUp<br/></td><td></td></tr>
<tr><td>observedCameraExposure<br/></td><td></td></tr>
<tr><td>observedCameraFlip<br/></td><td></td></tr>
<tr><td>observedCameraGain<br/></td><td></td></tr>
<tr><td>observedCameraMirror<br/></td><td></td></tr>
<tr><td>observedCameraWhiteBalanceBlue<br/></td><td></td></tr>
<tr><td>observedCameraWhiteBalanceGreen<br/></td><td></td></tr>
<tr><td>observedCameraWhiteBalanceRed<br/></td><td></td></tr>
<tr><td>observedCameraWindowX<br/></td><td></td></tr>
<tr><td>observedCameraWindowY<br/></td><td></td></tr>
<tr><td>openGripper<br/></td><td></td></tr>
<tr><td>openGripperInt<br/></td><td></td></tr>
<tr><td>or<br/>||<br/></td><td>Returns logical or of its numeric arguments. Back does not have booleans so it treats 0 (and 0.0) as false, and all other numbers as true.</td></tr>
<tr><td>pauseAndReset<br/></td><td></td></tr>
<tr><td>pauseStackExecution<br/>Pause<br/></td><td></td></tr>
<tr><td>perturbPosition<br/></td><td></td></tr>
<tr><td>perturbPositionScale<br/></td><td></td></tr>
<tr><td>photoSpin<br/></td><td></td></tr>
<tr><td>pi<br/></td><td></td></tr>
<tr><td>pickAllBlueBoxes<br/></td><td></td></tr>
<tr><td>pickClosestBlueBox<br/></td><td></td></tr>
<tr><td>pickFlushFactor<br/></td><td>How close we get when picking.</td></tr>
<tr><td>pickObjectUnderEndEffector<br/></td><td></td></tr>
<tr><td>pixelGlobalTest<br/></td><td></td></tr>
<tr><td>placeHeldObjectOnObject<br/></td><td></td></tr>
<tr><td>placeObjectInDeliveryZone<br/></td><td></td></tr>
<tr><td>placeObjectInEndEffector<br/></td><td></td></tr>
<tr><td>planCommandJointsAtRateSpin<br/></td><td></td></tr>
<tr><td>planToPointCraneFourStroke<br/></td><td></td></tr>
<tr><td>planToPointCraneThreeStroke<br/></td><td></td></tr>
<tr><td>planToPointCraneThreeStrokeOpenJointHyperPlanner<br/></td><td></td></tr>
<tr><td>plus<br/>+<br/></td><td>Takes two numbers and adds them.  If two ints, returns an int; otherwise returns a double; otherwise does string.</td></tr>
<tr><td>pointToClearanceMap<br/></td><td></td></tr>
<tr><td>pop<br/></td><td></td></tr>
<tr><td>populateStreamBuffers<br/></td><td></td></tr>
<tr><td>pow<br/></td><td></td></tr>
<tr><td>prepareForAndExecuteGraspFromMemory<br/></td><td></td></tr>
<tr><td>pressAndGrasp<br/></td><td></td></tr>
<tr><td>pressAndGraspA<br/></td><td></td></tr>
<tr><td>pressAndRelease<br/></td><td></td></tr>
<tr><td>pressAndReleaseA<br/></td><td></td></tr>
<tr><td>pressUntilEffort<br/></td><td></td></tr>
<tr><td>pressUntilEffortA<br/></td><td></td></tr>
<tr><td>pressUntilEffortAllInOne<br/></td><td>Push down until there is effort sensed; top level word that can be called all in one.</td></tr>
<tr><td>pressUntilEffortCombo<br/></td><td>Press down until effort is larger than a threshold.  Pushes down once more quickly with a coarse press, then does a fine-grained press (to unwined the springs), so at the end you are lightly touching the surface.</td></tr>
<tr><td>pressUntilEffortInit<br/></td><td>Initialize parameters for pressUntilEffort.</td></tr>
<tr><td>pressUntilEffortOrTwist<br/></td><td></td></tr>
<tr><td>pressUntilEffortOrTwistA<br/></td><td></td></tr>
<tr><td>pressUntilEffortOrTwistInit<br/></td><td></td></tr>
<tr><td>pressUntilEffortStart<br/></td><td></td></tr>
<tr><td>print<br/></td><td>Pop a word from the stack and print it to the Ein console.</td></tr>
<tr><td>printClassLabels<br/></td><td>Print class labels to standard output.</td></tr>
<tr><td>printJointAngles<br/></td><td></td></tr>
<tr><td>printStacks<br/></td><td></td></tr>
<tr><td>printState<br/></td><td></td></tr>
<tr><td>prod<br/></td><td>Pops a compound word; multiplies the entries; pushes the result.  Usage:  ( 1 1 1 ) prod -&gt; 1.</td></tr>
<tr><td>publishCommandsMode<br/></td><td></td></tr>
<tr><td>publishCommandsOff<br/></td><td>Do not publish commands to the robot; useful if someone else (like MoveIt) is going to move the robot.</td></tr>
<tr><td>publishCommandsOn<br/></td><td>Turn on publishing movement commands and other changing commands (lights, sonar).</td></tr>
<tr><td>publishImageFileToFace<br/></td><td></td></tr>
<tr><td>publishImageToFace<br/></td><td></td></tr>
<tr><td>publishRecognizedObjectArrayFromBlueBoxMemory<br/></td><td></td></tr>
<tr><td>publishRecognizedObjectArrayFromPredictedMap<br/></td><td>Publish recognized obejcts from predicted map.</td></tr>
<tr><td>publishState<br/></td><td></td></tr>
<tr><td>publishWristViewToFace<br/></td><td></td></tr>
<tr><td>pursuitProximity<br/></td><td></td></tr>
<tr><td>pushClassLabels<br/></td><td>Push the class labels on the stack.</td></tr>
<tr><td>pushClassLabelsReport<br/></td><td></td></tr>
<tr><td>pushCurrentJointAngle<br/></td><td></td></tr>
<tr><td>pushCurrentJointAngles<br/></td><td></td></tr>
<tr><td>pushHelp<br/></td><td>Push help text for the word on the data stack.</td></tr>
<tr><td>pushState<br/></td><td></td></tr>
<tr><td>putCameraOverPhotoPin<br/></td><td></td></tr>
<tr><td>quarterImpulse<br/></td><td></td></tr>
<tr><td>quarterTurn<br/></td><td></td></tr>
<tr><td>quiveringPalm<br/></td><td></td></tr>
<tr><td>rangle<br/>&gt;<br/></td><td>Takes two words and returns 1 if they are greater than (by value) and 0 otherwise.  1 3 &lt; returns false, and 3 1 &lt; returns true</td></tr>
<tr><td>rasterScanningSpeed<br/></td><td></td></tr>
<tr><td>rayBufferInit<br/></td><td></td></tr>
<tr><td>rayBufferPopulateFromImageBuffer<br/></td><td></td></tr>
<tr><td>rayBufferSaveRaw<br/></td><td></td></tr>
<tr><td>rayBufferSize<br/></td><td></td></tr>
<tr><td>recordAllBlueBoxes<br/></td><td></td></tr>
<tr><td>recordAllExamplesFocusedClass<br/></td><td></td></tr>
<tr><td>recordExampleAsFocusedClass<br/></td><td></td></tr>
<tr><td>recordGraspZ<br/></td><td></td></tr>
<tr><td>recordPostTargetLock<br/></td><td></td></tr>
<tr><td>recordPreTargetLock<br/></td><td></td></tr>
<tr><td>registerEffort<br/></td><td></td></tr>
<tr><td>registerEffortA<br/></td><td></td></tr>
<tr><td>registerWrench<br/></td><td></td></tr>
<tr><td>registerWrenchA<br/></td><td></td></tr>
<tr><td>reloadCamera<br/></td><td></td></tr>
<tr><td>reloadClassLabels<br/></td><td></td></tr>
<tr><td>renameFocusedClass<br/></td><td></td></tr>
<tr><td>renderSetWristViewBrightnessScalar<br/></td><td></td></tr>
<tr><td>renderWristViewBrightnessScalar<br/></td><td></td></tr>
<tr><td>repeatHalo<br/></td><td></td></tr>
<tr><td>replaceBlueBoxesWithFocusedClass<br/></td><td></td></tr>
<tr><td>replaceBlueBoxesWithHistogramWinner<br/></td><td></td></tr>
<tr><td>replicateWord<br/></td><td></td></tr>
<tr><td>repr<br/></td><td>Takes an argument from the data stack pushes the string representation onto the data stack.  Usage:  &lt; word &gt; repr -&gt; string</td></tr>
<tr><td>resetAccumulatedStreamImage<br/></td><td></td></tr>
<tr><td>resetAuxiliary<br/></td><td></td></tr>
<tr><td>resetAveragedWrenchNorm<br/></td><td></td></tr>
<tr><td>resetCurrentFocusedClass<br/></td><td></td></tr>
<tr><td>resetTemporalMap<br/></td><td></td></tr>
<tr><td>resetW1ThreshToDefault<br/></td><td></td></tr>
<tr><td>restoreIkShare<br/></td><td></td></tr>
<tr><td>retrainVocabOff<br/></td><td></td></tr>
<tr><td>retrainVocabOn<br/></td><td></td></tr>
<tr><td>returnObject<br/></td><td></td></tr>
<tr><td>reverseCompound<br/></td><td></td></tr>
<tr><td>reversePath<br/></td><td></td></tr>
<tr><td>rewindImageStreamBuffer<br/></td><td></td></tr>
<tr><td>rewindImageStreamBufferNLNK<br/></td><td></td></tr>
<tr><td>rgbScan<br/></td><td></td></tr>
<tr><td>robotSerial<br/></td><td>The robot serial number, used for naming configuration files uniquely.</td></tr>
<tr><td>robotSoftwareVersion<br/></td><td>The robot software version.  used for baxter sdk versions.</td></tr>
<tr><td>robotType<br/></td><td>The type of the robot.</td></tr>
<tr><td>sB<br/>|B<br/></td><td></td></tr>
<tr><td>sP<br/>|S<br/></td><td></td></tr>
<tr><td>sadFace<br/></td><td></td></tr>
<tr><td>save3dGrasps<br/></td><td></td></tr>
<tr><td>saveCalibration<br/></td><td></td></tr>
<tr><td>saveCalibrationToClass<br/></td><td></td></tr>
<tr><td>saveConfig<br/></td><td></td></tr>
<tr><td>saveGripperMask<br/></td><td></td></tr>
<tr><td>saveIkMap<br/></td><td></td></tr>
<tr><td>saveIkMapAtHeight<br/></td><td></td></tr>
<tr><td>saveRegister1<br/></td><td></td></tr>
<tr><td>saveRegister2<br/></td><td></td></tr>
<tr><td>saveRegister3<br/></td><td></td></tr>
<tr><td>saveRegister4<br/></td><td></td></tr>
<tr><td>scanCentered<br/></td><td></td></tr>
<tr><td>scanGroup<br/></td><td>The scan group, for saving groups of scans organized by objects.</td></tr>
<tr><td>scanObjectFast<br/></td><td>Scans an object without an IR scan, and with an annotated grasp.</td></tr>
<tr><td>scanObjectScene<br/></td><td>Scans a stack of objects in stream mode with an annotated 3d grasps in stack.</td></tr>
<tr><td>scanObjectStream<br/></td><td>Scans an object in stream mode with an annotated grasp.</td></tr>
<tr><td>scanObjectStreamAnnotated<br/></td><td>Scans an object in stream mode with an annotated grasp.</td></tr>
<tr><td>scanObjectStreamWaypoints<br/></td><td>Scans a stack of objects in stream mode with an annotated grasps in stack.</td></tr>
<tr><td>scanObjectStreamWaypoints3d<br/></td><td>Scans a stack of objects in stream mode with an annotated 3d grasps in stack.</td></tr>
<tr><td>scanObjectStreamWaypoints3dNoPick<br/></td><td>Scans a stack of objects in stream mode with an annotated 3d grasps in stack.</td></tr>
<tr><td>scanObjectStreamWaypointsIR<br/></td><td>Scans a stack of objects in stream mode using IR raster scan to infer grasp points.</td></tr>
<tr><td>sceneAddDiscrepantPredictedToObserved<br/></td><td></td></tr>
<tr><td>sceneAddPredictedFocusedObject<br/></td><td></td></tr>
<tr><td>sceneAddPredictedObject<br/></td><td></td></tr>
<tr><td>sceneAddPredictedToObserved<br/></td><td></td></tr>
<tr><td>sceneAnchorPose<br/></td><td>Takes a gaussian map on the stack and returns its anchor eePose.</td></tr>
<tr><td>sceneAngularApertureCols<br/></td><td></td></tr>
<tr><td>sceneAngularApertureRows<br/></td><td></td></tr>
<tr><td>sceneAngularBaffleCols<br/></td><td></td></tr>
<tr><td>sceneAngularBaffleRows<br/></td><td></td></tr>
<tr><td>sceneBackgroundMap<br/></td><td>Takes a scene on the stack and returns its background map.</td></tr>
<tr><td>sceneCellCountThreshold<br/></td><td></td></tr>
<tr><td>sceneCellWidth<br/></td><td>Cell width of scene.</td></tr>
<tr><td>sceneClearDepthStack<br/></td><td></td></tr>
<tr><td>sceneClearObservedMap<br/></td><td></td></tr>
<tr><td>sceneClearPredictedObjects<br/></td><td></td></tr>
<tr><td>sceneCoalesceClassHarmonics<br/></td><td></td></tr>
<tr><td>sceneComposePredictedMap<br/></td><td></td></tr>
<tr><td>sceneComposePredictedMapThreshed<br/></td><td></td></tr>
<tr><td>sceneComputeProbabilityOfMap<br/></td><td></td></tr>
<tr><td>sceneComputeScore<br/></td><td></td></tr>
<tr><td>sceneCopyGaussianMap<br/></td><td>Takes a gaussian map on the stack and performs a deep copy, leaving a new gaussian map on the stack.</td></tr>
<tr><td>sceneCopyObservedToReprojectionBuffer<br/></td><td></td></tr>
<tr><td>sceneCopyScene<br/></td><td>Takes a scene on the stack and performs a deep copy, leaving a new scene on the stack.</td></tr>
<tr><td>sceneCountDiscrepantCells<br/></td><td></td></tr>
<tr><td>sceneCropToDiscrepantRegion<br/></td><td></td></tr>
<tr><td>sceneDepthPatchHalfWidth<br/></td><td></td></tr>
<tr><td>sceneDepthStackLoadAndCropRaw<br/></td><td></td></tr>
<tr><td>sceneDepthStackLoadAndMarginalizeRaw<br/></td><td></td></tr>
<tr><td>sceneDepthStackLoadAndMinRaw<br/></td><td></td></tr>
<tr><td>sceneDepthStackLoadAndPushRaw<br/></td><td></td></tr>
<tr><td>sceneDepthStackSavePngRaw<br/></td><td></td></tr>
<tr><td>sceneDepthStackSaveRaw<br/></td><td></td></tr>
<tr><td>sceneDiscrepancyMode<br/></td><td></td></tr>
<tr><td>sceneDiscrepancySearchDepth<br/></td><td></td></tr>
<tr><td>sceneExponentialAverageObservedIntoBackground<br/></td><td></td></tr>
<tr><td>sceneFabricateIdealBlockModel<br/></td><td></td></tr>
<tr><td>sceneFlattenUncertainZWithDepthStack<br/></td><td></td></tr>
<tr><td>sceneGetAnnotatedClassName<br/></td><td>The annotated class, for evaluation purposes.</td></tr>
<tr><td>sceneGetClassificationMode<br/></td><td></td></tr>
<tr><td>sceneGetFixationMode<br/></td><td></td></tr>
<tr><td>sceneGetPredictedClassName<br/></td><td>The predicted class.</td></tr>
<tr><td>sceneGrabDiscrepantCropAsClass<br/></td><td></td></tr>
<tr><td>sceneHighPrecisionBeforeAfterDiffOfLogs<br/></td><td></td></tr>
<tr><td>sceneInit<br/></td><td></td></tr>
<tr><td>sceneInitDefaultBackgroundMap<br/></td><td>Check if the map exists; otherwise create a default one.</td></tr>
<tr><td>sceneInitDimensions<br/></td><td></td></tr>
<tr><td>sceneInitFromEePose<br/></td><td></td></tr>
<tr><td>sceneInitFromEePoseScale<br/></td><td></td></tr>
<tr><td>sceneInitFromEePoseScaleDimensions<br/></td><td></td></tr>
<tr><td>sceneInitRegisterMax<br/></td><td></td></tr>
<tr><td>sceneInitRegisterZero<br/></td><td></td></tr>
<tr><td>sceneInitSmall<br/></td><td></td></tr>
<tr><td>sceneIsNewConfiguration<br/></td><td></td></tr>
<tr><td>sceneLoadBackgroundMap<br/></td><td></td></tr>
<tr><td>sceneLoadDiscrepancyMap<br/></td><td></td></tr>
<tr><td>sceneLoadFocusedObjectModel<br/></td><td>Load the object model of the focused class from disk.</td></tr>
<tr><td>sceneLoadFocusedSceneModel<br/></td><td>Loads a scene from disk into the scene model for the focused class.  Requires the name of a scene that is saved to disk.</td></tr>
<tr><td>sceneLoadGaussianMap<br/></td><td>Takes a string, loads the gaussian map and puts it on the stack.</td></tr>
<tr><td>sceneLoadLightingModelFromGaussianMapFile<br/></td><td></td></tr>
<tr><td>sceneLoadMonochromeBackground<br/></td><td></td></tr>
<tr><td>sceneLoadObjectModel<br/></td><td>Load the object model.  Takes an object name as argument, which must be a directory name in the objects directory.</td></tr>
<tr><td>sceneLoadObservedMap<br/></td><td></td></tr>
<tr><td>sceneLoadScene<br/></td><td></td></tr>
<tr><td>sceneLoadSceneRaw<br/></td><td></td></tr>
<tr><td>sceneMapSceneObject<br/></td><td></td></tr>
<tr><td>sceneMarginalizeDepthStackIntoRegister<br/></td><td></td></tr>
<tr><td>sceneMinDepthStackIntoRegister<br/></td><td></td></tr>
<tr><td>sceneMinIntoRegister<br/></td><td></td></tr>
<tr><td>sceneMinSigmaSquared<br/></td><td>Variance on scene</td></tr>
<tr><td>sceneNumPredictedObjects<br/></td><td></td></tr>
<tr><td>sceneObjectLabelToSceneObjectIdx<br/></td><td></td></tr>
<tr><td>sceneObservedMap<br/></td><td>Takes a scene on the stack and returns its observed map.</td></tr>
<tr><td>scenePredictBestObject<br/></td><td></td></tr>
<tr><td>scenePredictFocusedObject<br/></td><td></td></tr>
<tr><td>scenePredictedMap<br/></td><td>Takes a scene on the stack and returns its predicted map.</td></tr>
<tr><td>scenePushAnchorPose<br/></td><td></td></tr>
<tr><td>scenePushAverageCrCbSigmaSquared<br/></td><td></td></tr>
<tr><td>scenePushDepthStackSize<br/></td><td></td></tr>
<tr><td>scenePushFocusedClassModelArea<br/></td><td></td></tr>
<tr><td>scenePushFocusedClassTotalDiscrepancy<br/></td><td></td></tr>
<tr><td>scenePushLightingModel<br/></td><td></td></tr>
<tr><td>scenePushNumSceneObjects<br/></td><td></td></tr>
<tr><td>scenePushOntoDepthStack<br/></td><td></td></tr>
<tr><td>scenePushPixelOfMinStackVariance<br/></td><td></td></tr>
<tr><td>scenePushPixelOfMinVariance<br/></td><td></td></tr>
<tr><td>scenePushSceneObjectLabel<br/></td><td></td></tr>
<tr><td>scenePushSceneObjectPose<br/></td><td>Takes an index; pushes the pose for this predicted object.</td></tr>
<tr><td>scenePushTotalDiscrepancy<br/></td><td></td></tr>
<tr><td>scenePushTotalDiscrepancyMagnitude<br/></td><td></td></tr>
<tr><td>scenePushTotalLogDiscrepancy<br/></td><td></td></tr>
<tr><td>scenePushTotalRelevantOneMinusDiscrepancy<br/></td><td></td></tr>
<tr><td>sceneRecalculateObservedMusAndSigmas<br/></td><td></td></tr>
<tr><td>sceneRecallDepthStackIndex<br/></td><td></td></tr>
<tr><td>sceneRecallFromRegister<br/></td><td></td></tr>
<tr><td>sceneRegularizeSceneL2<br/></td><td></td></tr>
<tr><td>sceneRenderBackgroundMap<br/></td><td></td></tr>
<tr><td>sceneRenderDiscrepancy<br/></td><td></td></tr>
<tr><td>sceneRenderObservedMap<br/></td><td></td></tr>
<tr><td>sceneRenderPredictedMap<br/></td><td></td></tr>
<tr><td>sceneRenderScene<br/></td><td></td></tr>
<tr><td>sceneRenderZ<br/></td><td></td></tr>
<tr><td>sceneSaveBackgroundMap<br/></td><td></td></tr>
<tr><td>sceneSaveDiscrepancyDensityImage<br/></td><td></td></tr>
<tr><td>sceneSaveDiscrepancyMap<br/></td><td></td></tr>
<tr><td>sceneSaveFocusedSceneModel<br/></td><td></td></tr>
<tr><td>sceneSaveGaussianMap<br/></td><td>Takes a string and saves a gaussian map to that string.</td></tr>
<tr><td>sceneSaveLightingModelToGaussianMapFile<br/></td><td></td></tr>
<tr><td>sceneSaveObservedMap<br/></td><td></td></tr>
<tr><td>sceneSaveObservedMapImage<br/></td><td></td></tr>
<tr><td>sceneSaveScene<br/></td><td></td></tr>
<tr><td>sceneSaveSceneAbsolute<br/></td><td></td></tr>
<tr><td>sceneScoreObjectAtPose<br/></td><td></td></tr>
<tr><td>sceneScoreThresh<br/></td><td>Score threshold for discrepancy.</td></tr>
<tr><td>sceneSetAngularApertureCols<br/></td><td></td></tr>
<tr><td>sceneSetAngularApertureRows<br/></td><td></td></tr>
<tr><td>sceneSetAngularBaffleCols<br/></td><td></td></tr>
<tr><td>sceneSetAngularBaffleRows<br/></td><td></td></tr>
<tr><td>sceneSetAnnotatedClassName<br/></td><td></td></tr>
<tr><td>sceneSetAnnotatedClassNameToFocusedClass<br/></td><td></td></tr>
<tr><td>sceneSetBackgroundFromObserved<br/></td><td></td></tr>
<tr><td>sceneSetBackgroundMap<br/></td><td>Takes a scene and a background map and sets the scene with the background map. </td></tr>
<tr><td>sceneSetBackgroundStdDevColor<br/></td><td></td></tr>
<tr><td>sceneSetBackgroundStdDevY<br/></td><td></td></tr>
<tr><td>sceneSetCellCountThreshold<br/></td><td></td></tr>
<tr><td>sceneSetClassificationMode<br/></td><td></td></tr>
<tr><td>sceneSetCurrentScene<br/></td><td>Sets the current scene with its argument.</td></tr>
<tr><td>sceneSetDepthPatchHalfWidth<br/></td><td></td></tr>
<tr><td>sceneSetDiscrepancyDensityFromZ<br/></td><td></td></tr>
<tr><td>sceneSetDiscrepancyModeDot<br/></td><td></td></tr>
<tr><td>sceneSetDiscrepancyModeNoisyAnd<br/></td><td></td></tr>
<tr><td>sceneSetDiscrepancyModeNoisyOr<br/></td><td></td></tr>
<tr><td>sceneSetDiscrepancyModePoint<br/></td><td></td></tr>
<tr><td>sceneSetDiscrepancySearchDepth<br/></td><td></td></tr>
<tr><td>sceneSetFixationMode<br/></td><td></td></tr>
<tr><td>sceneSetFocusedSceneStdDevColor<br/></td><td></td></tr>
<tr><td>sceneSetFocusedSceneStdDevY<br/></td><td></td></tr>
<tr><td>sceneSetHeightReticleFromPixel<br/></td><td></td></tr>
<tr><td>sceneSetHeightReticleFromVariance<br/></td><td></td></tr>
<tr><td>sceneSetLightModelFromDiscrepancy<br/></td><td></td></tr>
<tr><td>sceneSetLightingModelFromStack<br/></td><td></td></tr>
<tr><td>sceneSetLightingModelStdDevColor<br/></td><td></td></tr>
<tr><td>sceneSetLightingModelStdDevY<br/></td><td></td></tr>
<tr><td>sceneSetMinSigmaSquared<br/></td><td></td></tr>
<tr><td>sceneSetObservedMap<br/></td><td>Takes a scene and an observed map and sets the scene with the observed map. </td></tr>
<tr><td>sceneSetObservedRGBFromVariance<br/></td><td></td></tr>
<tr><td>sceneSetObservedRGBFromZ<br/></td><td></td></tr>
<tr><td>sceneSetPredictedClassName<br/></td><td></td></tr>
<tr><td>sceneSetPredictedClassNameToFocusedClass<br/></td><td></td></tr>
<tr><td>sceneSetPredictedStdDevColor<br/></td><td></td></tr>
<tr><td>sceneSetPredictedStdDevY<br/></td><td></td></tr>
<tr><td>sceneSetScoreThresh<br/></td><td></td></tr>
<tr><td>sceneSetVanishingPointFromPixel<br/></td><td></td></tr>
<tr><td>sceneSetVanishingPointFromVariance<br/></td><td></td></tr>
<tr><td>sceneSmoothDepthStackInZ<br/></td><td></td></tr>
<tr><td>sceneSmoothDiscrepancyDensity<br/></td><td></td></tr>
<tr><td>sceneSmoothSquaredCountsAndSamplesXY<br/></td><td></td></tr>
<tr><td>sceneSpawnClassHarmonics<br/></td><td></td></tr>
<tr><td>sceneStoreObservedInRegister<br/></td><td></td></tr>
<tr><td>sceneTakeAfterDensity<br/></td><td></td></tr>
<tr><td>sceneTakeBeforeDensity<br/></td><td></td></tr>
<tr><td>sceneTrimDepthWithDiscrepancy<br/></td><td></td></tr>
<tr><td>sceneUpdateAllClassDiscrepancies<br/></td><td></td></tr>
<tr><td>sceneUpdateDiscrepancy<br/></td><td></td></tr>
<tr><td>sceneUpdateObservedFromRegisterAtZNoRecalcPhasedArray<br/></td><td></td></tr>
<tr><td>sceneUpdateObservedFromRegisterAtZNoRecalcPhasedArrayKernel<br/></td><td></td></tr>
<tr><td>sceneUpdateObservedFromReprojectionBufferAtZNoRecalc<br/></td><td></td></tr>
<tr><td>sceneUpdateObservedFromStreamBuffer<br/></td><td></td></tr>
<tr><td>sceneUpdateObservedFromStreamBufferAtZ<br/></td><td></td></tr>
<tr><td>sceneUpdateObservedFromStreamBufferAtZNoRecalc<br/></td><td></td></tr>
<tr><td>sceneUpdateObservedFromStreamBufferAtZNoRecalcAll<br/></td><td>Updates the observed map from the stream buffer in a big for loop; fastest version without GPU.  This is the one to copy and call.</td></tr>
<tr><td>sceneUpdateObservedFromStreamBufferAtZNoRecalcAllLightModelRenderGlareOnly<br/></td><td></td></tr>
<tr><td>sceneUpdateObservedFromStreamBufferAtZNoRecalcAllLightModelRenderGlareOnlyRising<br/></td><td></td></tr>
<tr><td>sceneUpdateObservedFromStreamBufferAtZNoRecalcAllLightModelRenderWithoutGlare<br/></td><td></td></tr>
<tr><td>sceneUpdateObservedFromStreamBufferAtZNoRecalcAllLightModelRenderWithoutGlareRising<br/></td><td></td></tr>
<tr><td>sceneUpdateObservedFromStreamBufferAtZNoRecalcAllOOP<br/></td><td></td></tr>
<tr><td>sceneUpdateObservedFromStreamBufferAtZNoRecalcAllSelfModelRenderGlareOnly<br/></td><td></td></tr>
<tr><td>sceneUpdateObservedFromStreamBufferAtZNoRecalcAllSelfModelRenderWithoutGlare<br/></td><td></td></tr>
<tr><td>sceneUpdateObservedFromStreamBufferAtZNoRecalcEPI<br/></td><td></td></tr>
<tr><td>sceneUpdateObservedFromStreamBufferAtZNoRecalcPhasedArray<br/></td><td></td></tr>
<tr><td>sceneUpdateObservedFromStreamBufferAtZNoRecalcSecondStageArray<br/></td><td></td></tr>
<tr><td>sceneUpdateObservedFromStreamBufferAtZNoRecalcSecondStageAsymmetricArray<br/></td><td></td></tr>
<tr><td>sceneUpdateObservedFromStreamBufferAtZNoRecalcViewSynthAll<br/></td><td></td></tr>
<tr><td>sceneUpdateObservedFromStreamBufferAtZNoRecalcViewSynthAllGCLightModelRenderGlareOnly<br/></td><td></td></tr>
<tr><td>sceneUpdateObservedFromStreamBufferAtZNoRecalcViewSynthAllGCLightModelRenderWithoutGlare<br/></td><td></td></tr>
<tr><td>sceneUpdateObservedFromStreamBufferAtZNoRecalcViewSynthAllGCSelfRenderGlareOnly<br/></td><td></td></tr>
<tr><td>sceneUpdateObservedFromStreamBufferAtZNoRecalcViewSynthAllGCSelfRenderWithoutGlare<br/></td><td></td></tr>
<tr><td>sceneUpdateObservedFromStreamBufferDepthMap<br/></td><td>Updates the observed map from the stream buffer as a depth map.  Used for the Kinect 2.</td></tr>
<tr><td>sceneUpdateObservedFromStreamBufferNoRecalc<br/></td><td></td></tr>
<tr><td>sceneUpdateObservedFromWrist<br/></td><td></td></tr>
<tr><td>sceneZeroBox<br/></td><td></td></tr>
<tr><td>sceneZeroLowerX<br/></td><td></td></tr>
<tr><td>sceneZeroLowerY<br/></td><td></td></tr>
<tr><td>sceneZeroUpperX<br/></td><td></td></tr>
<tr><td>sceneZeroUpperY<br/></td><td></td></tr>
<tr><td>searchProximity<br/></td><td></td></tr>
<tr><td>seeHz<br/></td><td></td></tr>
<tr><td>setArmedThreshold<br/></td><td></td></tr>
<tr><td>setBeeHome<br/></td><td></td></tr>
<tr><td>setBreakGraspTiesWithNoise<br/></td><td></td></tr>
<tr><td>setC3dPoseBase<br/></td><td></td></tr>
<tr><td>setCameraCenterX<br/></td><td></td></tr>
<tr><td>setCameraCenterY<br/></td><td></td></tr>
<tr><td>setCameraCropUpperLeftCornerX<br/></td><td></td></tr>
<tr><td>setCameraCropUpperLeftCornerY<br/></td><td></td></tr>
<tr><td>setCameraKappaX<br/></td><td></td></tr>
<tr><td>setCameraKappaY<br/></td><td></td></tr>
<tr><td>setCameraMuX<br/></td><td></td></tr>
<tr><td>setCameraMuY<br/></td><td></td></tr>
<tr><td>setCameraR00<br/></td><td></td></tr>
<tr><td>setCameraR01<br/></td><td></td></tr>
<tr><td>setCameraR10<br/></td><td></td></tr>
<tr><td>setCameraR11<br/></td><td></td></tr>
<tr><td>setClassLabels<br/></td><td>Set the active classes.  useage:  endArgs &quot;class1&quot; &quot;class2&quot; setClassLabels.  The class names must be directorys in the ein/default/objects folder.</td></tr>
<tr><td>setClassLabelsBaseClassAbsolute<br/></td><td></td></tr>
<tr><td>setClassLabelsObjectFolderAbsolute<br/></td><td></td></tr>
<tr><td>setColorReticles<br/></td><td></td></tr>
<tr><td>setColorReticlesA<br/></td><td></td></tr>
<tr><td>setControlModeAngles<br/></td><td></td></tr>
<tr><td>setControlModeEePosition<br/></td><td></td></tr>
<tr><td>setCurrentCornellTableToZero<br/></td><td></td></tr>
<tr><td>setCurrentIKBoundaryMode<br/></td><td></td></tr>
<tr><td>setCurrentIKFastMode<br/></td><td></td></tr>
<tr><td>setCurrentPoseFromJoints<br/></td><td></td></tr>
<tr><td>setCurrentPoseToTruePose<br/></td><td></td></tr>
<tr><td>setCurrentTableZ<br/></td><td></td></tr>
<tr><td>setDefaultHandCameraOffset<br/></td><td>Sets the hand camera offset to the default value (obtained for Baxter&apos;s RGB wrist camera.</td></tr>
<tr><td>setEEPosePX<br/></td><td></td></tr>
<tr><td>setEEPosePY<br/></td><td></td></tr>
<tr><td>setEEPosePZ<br/></td><td></td></tr>
<tr><td>setEEPoseQW<br/></td><td></td></tr>
<tr><td>setEEPoseQX<br/></td><td></td></tr>
<tr><td>setEEPoseQY<br/></td><td></td></tr>
<tr><td>setEEPoseQZ<br/></td><td></td></tr>
<tr><td>setEffortHere<br/></td><td></td></tr>
<tr><td>setEffortThresh<br/></td><td></td></tr>
<tr><td>setExpectedCropsToStream<br/></td><td></td></tr>
<tr><td>setFakeBBWidth<br/></td><td></td></tr>
<tr><td>setFocusedClass<br/>setTargetClass<br/></td><td></td></tr>
<tr><td>setFocusedClassIdx<br/>setTargetClassIdx<br/></td><td></td></tr>
<tr><td>setGradientServoHardMaxIterations<br/></td><td></td></tr>
<tr><td>setGradientServoMode<br/></td><td></td></tr>
<tr><td>setGradientServoSoftMaxIterations<br/></td><td></td></tr>
<tr><td>setGraspBackoffDistance<br/></td><td></td></tr>
<tr><td>setGraspModeTo3D<br/></td><td></td></tr>
<tr><td>setGraspModeToCrane<br/></td><td></td></tr>
<tr><td>setGreenHalo<br/></td><td></td></tr>
<tr><td>setGridSize<br/></td><td></td></tr>
<tr><td>setGridSizeCoarse<br/></td><td></td></tr>
<tr><td>setGridSizeCoarser<br/></td><td></td></tr>
<tr><td>setGridSizeEvenCoarser<br/></td><td></td></tr>
<tr><td>setGridSizeFine<br/></td><td></td></tr>
<tr><td>setGridSizeMedium<br/></td><td></td></tr>
<tr><td>setGridSizeNowThatsCoarse<br/></td><td></td></tr>
<tr><td>setGridSizeVeryFine<br/></td><td></td></tr>
<tr><td>setGripperMask<br/></td><td></td></tr>
<tr><td>setGripperMaskA<br/></td><td></td></tr>
<tr><td>setGripperMaskAA<br/></td><td></td></tr>
<tr><td>setGripperMaskB<br/></td><td></td></tr>
<tr><td>setGripperMaskBA<br/></td><td></td></tr>
<tr><td>setGripperMaskCA<br/></td><td></td></tr>
<tr><td>setGripperMaskCB<br/></td><td></td></tr>
<tr><td>setGripperMaskOnes<br/></td><td></td></tr>
<tr><td>setGripperMaskThresh<br/></td><td></td></tr>
<tr><td>setGripperMaskWithMotion<br/></td><td></td></tr>
<tr><td>setGripperMaskWithMotionA<br/></td><td></td></tr>
<tr><td>setGripperMovingForce<br/></td><td>Set the moving force of the gripper.  Takes an integer between 0-100. </td></tr>
<tr><td>setGripperThresh<br/></td><td></td></tr>
<tr><td>setHandCameraOffset<br/></td><td></td></tr>
<tr><td>setHandCameraOffsetFromTf<br/></td><td>Sets the hand camera  from tf using the links.</td></tr>
<tr><td>setHandEndEffectorOffset<br/></td><td></td></tr>
<tr><td>setHeadPanTargetSpeed<br/></td><td></td></tr>
<tr><td>setHeightReticles<br/></td><td></td></tr>
<tr><td>setHeightReticlesA<br/></td><td></td></tr>
<tr><td>setHelp<br/></td><td>Make a new compound word with specified description text.  Usage:  &lt;compound word&gt; &lt; help text &gt; setHelp -&gt; &lt; compound word with help text &gt;. </td></tr>
<tr><td>setHoverThreshold<br/></td><td></td></tr>
<tr><td>setIROffset<br/></td><td></td></tr>
<tr><td>setIdleModeToCrane<br/></td><td></td></tr>
<tr><td>setIdleModeToEmpty<br/></td><td></td></tr>
<tr><td>setIdleModeToPatrol<br/></td><td></td></tr>
<tr><td>setIdleModeToShrug<br/></td><td></td></tr>
<tr><td>setIdleModeToStopClear<br/></td><td></td></tr>
<tr><td>setLastLabelLearned<br/></td><td></td></tr>
<tr><td>setMagnification<br/></td><td></td></tr>
<tr><td>setMagnificationA<br/></td><td></td></tr>
<tr><td>setMagnificationB<br/></td><td></td></tr>
<tr><td>setMapAutoPick<br/></td><td></td></tr>
<tr><td>setMapFreeSpacePixelSkirt<br/></td><td></td></tr>
<tr><td>setMapGrayBoxPixelSkirtCols<br/></td><td></td></tr>
<tr><td>setMapGrayBoxPixelSkirtRows<br/></td><td></td></tr>
<tr><td>setMapGrayBoxPixelWaistCols<br/></td><td></td></tr>
<tr><td>setMapGrayBoxPixelWaistRows<br/></td><td></td></tr>
<tr><td>setMapSearchFenceXMax<br/></td><td></td></tr>
<tr><td>setMapSearchFenceXMin<br/></td><td></td></tr>
<tr><td>setMapSearchFenceYMax<br/></td><td></td></tr>
<tr><td>setMapSearchFenceYMin<br/></td><td></td></tr>
<tr><td>setMapServoMode<br/></td><td></td></tr>
<tr><td>setMappingServoTimeout<br/></td><td></td></tr>
<tr><td>setMovementStateToMoving<br/></td><td></td></tr>
<tr><td>setMovingThreshold<br/></td><td></td></tr>
<tr><td>setNumClasses<br/></td><td></td></tr>
<tr><td>setPatrolModeToLoop<br/></td><td></td></tr>
<tr><td>setPatrolModeToOnce<br/></td><td></td></tr>
<tr><td>setPatrolStateToHanding<br/></td><td></td></tr>
<tr><td>setPatrolStateToIdling<br/></td><td></td></tr>
<tr><td>setPatrolStateToPatrolling<br/></td><td></td></tr>
<tr><td>setPatrolStateToPicking<br/></td><td></td></tr>
<tr><td>setPatrolStateToPlacing<br/></td><td></td></tr>
<tr><td>setPhotoPinHere<br/></td><td></td></tr>
<tr><td>setPickFlushFactor<br/></td><td></td></tr>
<tr><td>setPlaceModeToHand<br/></td><td></td></tr>
<tr><td>setPlaceModeToHold<br/></td><td></td></tr>
<tr><td>setPlaceModeToRegister<br/></td><td></td></tr>
<tr><td>setPlaceModeToShake<br/></td><td></td></tr>
<tr><td>setPressPose<br/></td><td></td></tr>
<tr><td>setPursuitProximity<br/></td><td></td></tr>
<tr><td>setRandomOrientationForPhotospin<br/></td><td></td></tr>
<tr><td>setRandomPositionAfterPick<br/></td><td></td></tr>
<tr><td>setRedHalo<br/></td><td></td></tr>
<tr><td>setRepeatHalo<br/></td><td></td></tr>
<tr><td>setScanGroup<br/></td><td></td></tr>
<tr><td>setScanModeCentered<br/></td><td></td></tr>
<tr><td>setScanModeNotCentered<br/></td><td></td></tr>
<tr><td>setSearchProximity<br/></td><td></td></tr>
<tr><td>setSisFlags<br/></td><td>Set whether we should save different sensor streams. &lt;pose&gt; &lt;range&gt; &lt;image&gt; &lt;joints&gt; &lt;word&gt; &lt;label&gt; setSisFlags</td></tr>
<tr><td>setSnapToFlushGrasp<br/></td><td></td></tr>
<tr><td>setSonarLed<br/></td><td></td></tr>
<tr><td>setSpeed<br/></td><td></td></tr>
<tr><td>setStiffness<br/></td><td></td></tr>
<tr><td>setStreamPicks<br/></td><td></td></tr>
<tr><td>setTable<br/></td><td></td></tr>
<tr><td>setTableA<br/></td><td></td></tr>
<tr><td>setFocusedClass<br/>setTargetClass<br/></td><td></td></tr>
<tr><td>setFocusedClassIdx<br/>setTargetClassIdx<br/></td><td></td></tr>
<tr><td>setTheYcbTable<br/></td><td></td></tr>
<tr><td>setTorsoFanLevel<br/></td><td></td></tr>
<tr><td>setTrackbarLoHi<br/></td><td></td></tr>
<tr><td>setTwistThresh<br/></td><td></td></tr>
<tr><td>setVanishingPoint<br/></td><td></td></tr>
<tr><td>setVanishingPointA<br/></td><td></td></tr>
<tr><td>setVanishingPointB<br/></td><td></td></tr>
<tr><td>setVanishingPointPrep<br/></td><td></td></tr>
<tr><td>setW1AngleThresh<br/></td><td></td></tr>
<tr><td>setW1GoThresh<br/></td><td></td></tr>
<tr><td>shakeHeadNegative<br/></td><td></td></tr>
<tr><td>shakeHeadPositive<br/></td><td></td></tr>
<tr><td>shakeItOff1<br/></td><td></td></tr>
<tr><td>shakeItUpAndDown<br/></td><td></td></tr>
<tr><td>shutdownAllNonessentialSystems<br/></td><td>Shut down all systems that are not important for streaming data, to maximize the framerate we stream.</td></tr>
<tr><td>shutdownToSensorsAndMovement<br/></td><td></td></tr>
<tr><td>silenceSonar<br/></td><td></td></tr>
<tr><td>sin<br/></td><td></td></tr>
<tr><td>size<br/></td><td>Takes a compound word on the stack and an int.  Returns the ith entry of the compound word.  Uses zero based indexing.</td></tr>
<tr><td>slide<br/>&apos;<br/></td><td>Moves a word from the call stack to the data stack.</td></tr>
<tr><td>slip<br/></td><td>Moves a word from the data stack to the call stack.</td></tr>
<tr><td>spawnTargetClassAtEndEffector<br/></td><td></td></tr>
<tr><td>spawnTargetMasterSpriteAtEndEffector<br/></td><td></td></tr>
<tr><td>spinForSeconds<br/></td><td></td></tr>
<tr><td>spinForSecondsA<br/></td><td></td></tr>
<tr><td>spinForSecondsInit<br/></td><td></td></tr>
<tr><td>squeezeDuck<br/></td><td></td></tr>
<tr><td>start<br/></td><td></td></tr>
<tr><td>start3dGraspAnnotation<br/></td><td></td></tr>
<tr><td>start3dGraspAnnotationNoChange<br/></td><td></td></tr>
<tr><td>stay<br/></td><td></td></tr>
<tr><td>stayNoRoll<br/></td><td></td></tr>
<tr><td>stayZOnly<br/></td><td></td></tr>
<tr><td>stereoCalculate<br/></td><td></td></tr>
<tr><td>stereoDisplay<br/></td><td></td></tr>
<tr><td>stereoPair<br/></td><td></td></tr>
<tr><td>stereoPairCache1<br/></td><td></td></tr>
<tr><td>stereoPairCache2<br/></td><td></td></tr>
<tr><td>stereoPrep<br/></td><td></td></tr>
<tr><td>store<br/></td><td>Create a new variable.  Usage  &lt;value&gt; &quot;&lt;name&gt;&quot; store.  After that you can say &lt;name&gt; and it will push its contents on the call stack.</td></tr>
<tr><td>streamBasePoseForCurrentImage<br/></td><td>Push the arm pose for the current image in the stream buffer.</td></tr>
<tr><td>streamCenterCropAsFocusedClass<br/></td><td></td></tr>
<tr><td>streamCropsAsFocusedClass<br/></td><td></td></tr>
<tr><td>streamDisableAllSisFlags<br/></td><td>Enable all SIS flags.</td></tr>
<tr><td>streamDiskStreaming<br/></td><td></td></tr>
<tr><td>streamEnableAllSisFlags<br/></td><td>Enable all SIS flags.</td></tr>
<tr><td>streamEnableSisImageAndPoses<br/></td><td>Configure Ein to stream images and poses only.</td></tr>
<tr><td>streamGraspResult<br/></td><td></td></tr>
<tr><td>streamImageBufferCurrentIdx<br/></td><td></td></tr>
<tr><td>streamImageBufferSize<br/></td><td></td></tr>
<tr><td>streamImageSpeed<br/></td><td></td></tr>
<tr><td>streamIncrementImageStreamBuffer<br/></td><td>Increments the current location in the image stream buffer.  The new default word, which does no load and no kick.</td></tr>
<tr><td>streamJointBufferSize<br/></td><td></td></tr>
<tr><td>streamLabel<br/></td><td></td></tr>
<tr><td>streamLabelBufferSize<br/></td><td></td></tr>
<tr><td>streamPlayStreamBuffer<br/></td><td>Play back the stream buffer.  Plays back at a constant rate; is not careful to wait the &apos;correct&apos; amount of time between frames.</td></tr>
<tr><td>streamPoseBufferSize<br/></td><td></td></tr>
<tr><td>streamPoseForCurrentImage<br/></td><td>Push the pose for the current image in the stream buffer.</td></tr>
<tr><td>streamRangeBufferSize<br/></td><td></td></tr>
<tr><td>streamRenderStreamWindow<br/></td><td>Render the stream buffer window.</td></tr>
<tr><td>streamScanCentered<br/></td><td></td></tr>
<tr><td>streamSetDiskStreaming<br/></td><td></td></tr>
<tr><td>streamSetImageBufferCurrentIdx<br/></td><td></td></tr>
<tr><td>streamSetSisImage<br/></td><td></td></tr>
<tr><td>streamSetSisJoints<br/></td><td></td></tr>
<tr><td>streamSetSisLabel<br/></td><td></td></tr>
<tr><td>streamSetSisPose<br/></td><td></td></tr>
<tr><td>streamSetSisRange<br/></td><td></td></tr>
<tr><td>streamSetSisWord<br/></td><td></td></tr>
<tr><td>streamSisImage<br/></td><td></td></tr>
<tr><td>streamSisJoints<br/></td><td></td></tr>
<tr><td>streamSisLabel<br/></td><td></td></tr>
<tr><td>streamSisPose<br/></td><td></td></tr>
<tr><td>streamSisRange<br/></td><td></td></tr>
<tr><td>streamSisWord<br/></td><td></td></tr>
<tr><td>streamSpin<br/></td><td></td></tr>
<tr><td>streamWordBufferSize<br/></td><td></td></tr>
<tr><td>streamWriteBuffersToDisk<br/></td><td>Write what is in the stream buffer to disk.</td></tr>
<tr><td>subscribeCameraParameterTrackerToRosOut<br/></td><td>Subscribe to rosout.  We don&apos;t want to do this for long periods since it&apos;s very noisy, but this is how we see the current camera parameters, since they aren&apos;t published any other way.</td></tr>
<tr><td>sum<br/>join<br/></td><td>Pops a compound word; sums the entries; pushes the result.  Usage:  ( 1 1 1 ) sum -&gt; 3.</td></tr>
<tr><td>swap<br/></td><td></td></tr>
<tr><td>switchSonarLed<br/></td><td></td></tr>
<tr><td>tenthImpulse<br/></td><td></td></tr>
<tr><td>throw<br/></td><td></td></tr>
<tr><td>throwOpenCV<br/></td><td></td></tr>
<tr><td>time<br/></td><td></td></tr>
<tr><td>times<br/>*<br/></td><td>Multiply two numeric arguments.</td></tr>
<tr><td>toggleDrawClearanceMap<br/></td><td></td></tr>
<tr><td>toggleDrawIKMap<br/></td><td></td></tr>
<tr><td>toggleShouldIDoIK<br/></td><td></td></tr>
<tr><td>toggleShouldIRender<br/></td><td></td></tr>
<tr><td>toggleUseFade<br/></td><td></td></tr>
<tr><td>toggleUseGlow<br/></td><td></td></tr>
<tr><td>torsoFanAuto<br/></td><td></td></tr>
<tr><td>torsoFanOff<br/></td><td></td></tr>
<tr><td>torsoFanOn<br/></td><td></td></tr>
<tr><td>torsoFanState<br/></td><td></td></tr>
<tr><td>touchDown<br/></td><td></td></tr>
<tr><td>trainAndWriteFocusedClassKnn<br/></td><td></td></tr>
<tr><td>trainModels<br/></td><td>Rebuild the kNN model for the detectors.</td></tr>
<tr><td>trainModelsFromLabels<br/></td><td></td></tr>
<tr><td>transformPath<br/></td><td></td></tr>
<tr><td>trueCameraPose<br/></td><td></td></tr>
<tr><td>truePose<br/></td><td></td></tr>
<tr><td>tryToMoveToTheLastPickHeight<br/></td><td></td></tr>
<tr><td>tryToMoveToTheLastPrePickHeight<br/></td><td></td></tr>
<tr><td>tuckArms<br/></td><td></td></tr>
<tr><td>turnAboutY<br/></td><td></td></tr>
<tr><td>twistThresh<br/></td><td></td></tr>
<tr><td>twistWords<br/></td><td></td></tr>
<tr><td>twoPartPlaceObjectOnObject<br/></td><td></td></tr>
<tr><td>unFixCameraLighting<br/></td><td>Let the camera parmeters automatically update (this is the Baxter default).</td></tr>
<tr><td>unFixCameraLightingNoUpdate<br/></td><td></td></tr>
<tr><td>unSilenceSonar<br/></td><td></td></tr>
<tr><td>unTurnAboutY<br/></td><td></td></tr>
<tr><td>unmapTargetBlueBox<br/></td><td></td></tr>
<tr><td>unsubscribeCameraParameterTrackerToRosOut<br/></td><td>Unsubscribe from rosout.  We don&apos;t want to stay plugged into rosut for very long since it&apos;s so noisy.</td></tr>
<tr><td>untuckArms<br/></td><td></td></tr>
<tr><td>uploadObjectToDatabase<br/></td><td></td></tr>
<tr><td>visionCycle<br/></td><td></td></tr>
<tr><td>visionCycleNoClassify<br/></td><td></td></tr>
<tr><td>voidCurrentMapRegion<br/></td><td></td></tr>
<tr><td>w1AngleThresh<br/></td><td>When we do wait until at current position</td></tr>
<tr><td>w1GoThresh<br/></td><td>When we do wait until at current position</td></tr>
<tr><td>waitForSeconds<br/></td><td></td></tr>
<tr><td>waitForSecondsA<br/></td><td></td></tr>
<tr><td>waitForTugThenOpenGripper<br/></td><td></td></tr>
<tr><td>waitForTugThenOpenGripperA<br/></td><td></td></tr>
<tr><td>waitGetCurrentWaitMode<br/></td><td></td></tr>
<tr><td>waitSetCurrentWaitMode<br/></td><td></td></tr>
<tr><td>waitUntilAccelerometerCallbackReceived<br/></td><td></td></tr>
<tr><td>waitUntilAccelerometerCallbackReceivedA<br/></td><td></td></tr>
<tr><td>waitUntilAtCurrentPosition<br/></td><td></td></tr>
<tr><td>waitUntilAtCurrentPositionB<br/></td><td></td></tr>
<tr><td>waitUntilAtCurrentPositionCollapse<br/></td><td></td></tr>
<tr><td>waitUntilEffort<br/></td><td></td></tr>
<tr><td>waitUntilEffortA<br/></td><td></td></tr>
<tr><td>waitUntilEndpointCallbackReceived<br/></td><td></td></tr>
<tr><td>waitUntilEndpointCallbackReceivedA<br/></td><td></td></tr>
<tr><td>waitUntilGripperNotMoving<br/></td><td></td></tr>
<tr><td>waitUntilGripperNotMovingB<br/></td><td></td></tr>
<tr><td>waitUntilGripperNotMovingC<br/></td><td></td></tr>
<tr><td>waitUntilImageCallbackReceived<br/></td><td></td></tr>
<tr><td>waitUntilImageCallbackReceivedA<br/></td><td></td></tr>
<tr><td>waitUntilOnSideOfPlane<br/></td><td></td></tr>
<tr><td>waitUntilOnSideOfPlaneB<br/></td><td></td></tr>
<tr><td>waitUntilRingBufferImageAtCurrentPosition<br/></td><td></td></tr>
<tr><td>while<br/></td><td>While loop.  Usage:  ( 1 ) ( torsoFanOn 1 waitForSeconds torsoFanOff 1 waitForSeconds )  while</td></tr>
<tr><td>whileCollapsed<br/></td><td>While loop.  Use as in while, but collaspses the stack.  This means that if you don&apos;t exit the while, Ein will also never exit the while, and be in an infinite loop, even if you clear the stacks.</td></tr>
<tr><td>writeAlphaObjectToBetaFolders<br/></td><td></td></tr>
<tr><td>writeAlphaObjectToBetaFoldersA<br/></td><td></td></tr>
<tr><td>writeFocusedClass<br/></td><td></td></tr>
<tr><td>writeFocusedClassGrasps<br/></td><td></td></tr>
<tr><td>writeXMLEnvironment<br/></td><td></td></tr>
<tr><td>xDown<br/></td><td></td></tr>
<tr><td>xUp<br/></td><td>Move end effector up in the x dimension one unit.  Change unit size with setGridSize.  Usage:  xUp</td></tr>
<tr><td>yDown<br/></td><td></td></tr>
<tr><td>yUp<br/></td><td></td></tr>
<tr><td>zDown<br/></td><td></td></tr>
<tr><td>zUp<br/></td><td></td></tr>
<tr><td>zeroGMode<br/></td><td></td></tr>
<tr><td>zeroGOff<br/></td><td>Turns off zero gravity mode, so Ein will publish the current pose as the desired target position.</td></tr>
<tr><td>zeroGOn<br/></td><td>Turns on zero gravity mode, so that you can move the arm where you want and it will stay there.  Ein will publish the true joint position as the desired joint position.</td></tr>
<tr><td>zeroGToggle<br/></td><td>Toggle zero gravity mode.</td></tr>
<tr><td>oB<br/>{<br/></td><td></td></tr>
<tr><td>sB<br/>|B<br/></td><td></td></tr>
<tr><td>sP<br/>|S<br/></td><td></td></tr>
<tr><td>or<br/>||<br/></td><td>Returns logical or of its numeric arguments. Back does not have booleans so it treats 0 (and 0.0) as false, and all other numbers as true.</td></tr>
<tr><td>cB<br/>}<br/></td><td></td></tr>
</table>
